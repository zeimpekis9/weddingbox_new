"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase";
exports.ids = ["vendor-chunks/@supabase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi); //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBQzlDLE1BQU1DLGVBQWVELHVEQUFjQTtBQUNuQyxpRUFBZUMsWUFBWUEsRUFBQyxDQUM1Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQWRtaW5BcGkuanM/MjA2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5jb25zdCBBdXRoQWRtaW5BcGkgPSBHb1RydWVBZG1pbkFwaTtcbmV4cG9ydCBkZWZhdWx0IEF1dGhBZG1pbkFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhBZG1pbkFwaS5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQWRtaW5BcGkiLCJBdXRoQWRtaW5BcGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient); //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUMxQyxNQUFNQyxhQUFhRCxxREFBWUE7QUFDL0IsaUVBQWVDLFVBQVVBLEVBQUMsQ0FDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcz80ZjhmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuY29uc3QgQXV0aENsaWVudCA9IEdvVHJ1ZUNsaWVudDtcbmV4cG9ydCBkZWZhdWx0IEF1dGhDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVDbGllbnQiLCJBdXRoQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\n\nclass GoTrueAdminApi {\n    /**\n     * Creates an admin API client that can be used to manage users and OAuth clients.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueAdminApi } from '@supabase/auth-js'\n     *\n     * const admin = new GoTrueAdminApi({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { Authorization: `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}` },\n     * })\n     * ```\n     */ constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n        this.oauth = {\n            listClients: this._listOAuthClients.bind(this),\n            createClient: this._createOAuthClient.bind(this),\n            getClient: this._getOAuthClient.bind(this),\n            updateClient: this._updateOAuthClient.bind(this),\n            deleteClient: this._deleteOAuthClient.bind(this),\n            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt, scope = _lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES[0]) {\n        if (_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.join(\", \")}`);\n        }\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/invite`, {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async updateUserById(uid, attributes) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id, shouldSoftDelete = false) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(id);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.id);\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth clients with optional pagination.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _listOAuthClients(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const clients = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, clients), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        clients: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _createOAuthClient(params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets details of a specific OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _getOAuthClient(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates an existing OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _updateOAuthClient(clientId, params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Deletes an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _deleteOAuthClient(clientId) {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Regenerates the secret for an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _regenerateOAuthClientSecret(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n} //# sourceMappingURL=GoTrueAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ3VFO0FBQzNDO0FBQ1o7QUFDSjtBQUM1QixNQUFNUztJQUNqQjs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREMsWUFBWSxFQUFFQyxNQUFNLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxFQUFHLENBQUU7UUFDNUMsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdSLDBEQUFZQSxDQUFDUTtRQUMxQixJQUFJLENBQUNDLEdBQUcsR0FBRztZQUNQQyxhQUFhLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsSUFBSTtZQUN4Q0MsY0FBYyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDOUM7UUFDQSxJQUFJLENBQUNHLEtBQUssR0FBRztZQUNUQyxhQUFhLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNMLElBQUksQ0FBQyxJQUFJO1lBQzdDTSxjQUFjLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNQLElBQUksQ0FBQyxJQUFJO1lBQy9DUSxXQUFXLElBQUksQ0FBQ0MsZUFBZSxDQUFDVCxJQUFJLENBQUMsSUFBSTtZQUN6Q1UsY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDWCxJQUFJLENBQUMsSUFBSTtZQUMvQ1ksY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDYixJQUFJLENBQUMsSUFBSTtZQUMvQ2Msd0JBQXdCLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNmLElBQUksQ0FBQyxJQUFJO1FBQ3ZFO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTWdCLFFBQVFDLEdBQUcsRUFBRUMsUUFBUTVCLHVEQUFlLENBQUMsRUFBRSxFQUFFO1FBQzNDLElBQUlBLHVEQUFlQSxD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T0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1ULDZCQUE2QnFFLFFBQVEsRUFBRTtRQUN6QyxJQUFJO1lBQ0EsT0FBTyxNQUFNbEcsb0RBQVFBLENBQUMsSUFBSSxDQUFDVSxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMscUJBQXFCLEVBQUUwRixTQUFTLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ3ZHekYsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCbUMsT0FBTyxDQUFDcUQ7b0JBQ0osT0FBTzt3QkFBRTVELE1BQU00RDt3QkFBUTNELE9BQU87b0JBQUs7Z0JBQ3ZDO1lBQ0o7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJakMsd0RBQVdBLENBQUNpQyxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanM/NGEwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSwgX25vUmVzb2x2ZUpzb25SZXNwb25zZSwgX3JlcXVlc3QsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoLCB2YWxpZGF0ZVVVSUQgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IFNJR05fT1VUX1NDT1BFUywgfSBmcm9tICcuL2xpYi90eXBlcyc7XG5pbXBvcnQgeyBpc0F1dGhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhZG1pbiBBUEkgY2xpZW50IHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFuYWdlIHVzZXJzIGFuZCBPQXV0aCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEdvVHJ1ZUFkbWluQXBpIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gICAgICpcbiAgICAgKiBjb25zdCBhZG1pbiA9IG5ldyBHb1RydWVBZG1pbkFwaSh7XG4gICAgICogICB1cmw6ICdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vYXV0aC92MScsXG4gICAgICogICBoZWFkZXJzOiB7IEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHtwcm9jZXNzLmVudi5TVVBBQkFTRV9TRVJWSUNFX1JPTEVfS0VZfWAgfSxcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgdXJsID0gJycsIGhlYWRlcnMgPSB7fSwgZmV0Y2gsIH0pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpO1xuICAgICAgICB0aGlzLm1mYSA9IHtcbiAgICAgICAgICAgIGxpc3RGYWN0b3JzOiB0aGlzLl9saXN0RmFjdG9ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZGVsZXRlRmFjdG9yOiB0aGlzLl9kZWxldGVGYWN0b3IuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYXV0aCA9IHtcbiAgICAgICAgICAgIGxpc3RDbGllbnRzOiB0aGlzLl9saXN0T0F1dGhDbGllbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBjcmVhdGVDbGllbnQ6IHRoaXMuX2NyZWF0ZU9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRDbGllbnQ6IHRoaXMuX2dldE9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICB1cGRhdGVDbGllbnQ6IHRoaXMuX3VwZGF0ZU9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVDbGllbnQ6IHRoaXMuX2RlbGV0ZU9BdXRoQ2xpZW50LmJpbmQodGhpcyksXG4gICAgICAgICAgICByZWdlbmVyYXRlQ2xpZW50U2VjcmV0OiB0aGlzLl9yZWdlbmVyYXRlT0F1dGhDbGllbnRTZWNyZXQuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGxvZ2dlZC1pbiBzZXNzaW9uLlxuICAgICAqIEBwYXJhbSBqd3QgQSB2YWxpZCwgbG9nZ2VkLWluIEpXVC5cbiAgICAgKiBAcGFyYW0gc2NvcGUgVGhlIGxvZ291dCBzb3BlLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25PdXQoand0LCBzY29wZSA9IFNJR05fT1VUX1NDT1BFU1swXSkge1xuICAgICAgICBpZiAoU0lHTl9PVVRfU0NPUEVTLmluZGV4T2Yoc2NvcGUpIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogUGFyYW1ldGVyIHNjb3BlIG11c3QgYmUgb25lIG9mICR7U0lHTl9PVVRfU0NPUEVTLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2xvZ291dD9zY29wZT0ke3Njb3BlfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgand0LFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGFuIGludml0ZSBsaW5rIHRvIGFuIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIG9mIHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBpbmNsdWRlZCB3aGVuIGludml0aW5nLlxuICAgICAqL1xuICAgIGFzeW5jIGludml0ZVVzZXJCeUVtYWlsKGVtYWlsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9pbnZpdGVgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogeyBlbWFpbCwgZGF0YTogb3B0aW9ucy5kYXRhIH0sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGVtYWlsIGxpbmtzIGFuZCBPVFBzIHRvIGJlIHNlbnQgdmlhIGEgY3VzdG9tIGVtYWlsIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBlbWFpbCBUaGUgdXNlcidzIGVtYWlsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhc3N3b3JkIFVzZXIgcGFzc3dvcmQuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kYXRhIE9wdGlvbmFsIHVzZXIgbWV0YWRhdGEuIEZvciBzaWdudXAgb25seS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIFRoZSByZWRpcmVjdCB1cmwgd2hpY2ggc2hvdWxkIGJlIGFwcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgbGlua1xuICAgICAqL1xuICAgIGFzeW5jIGdlbmVyYXRlTGluayhwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gcGFyYW1zLCByZXN0ID0gX19yZXN0KHBhcmFtcywgW1wib3B0aW9uc1wiXSk7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoJ25ld0VtYWlsJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVwbGFjZSBuZXdFbWFpbCB3aXRoIG5ld19lbWFpbCBpbiByZXF1ZXN0IGJvZHlcbiAgICAgICAgICAgICAgICBib2R5Lm5ld19lbWFpbCA9IHJlc3QgPT09IG51bGwgfHwgcmVzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdC5uZXdFbWFpbDtcbiAgICAgICAgICAgICAgICBkZWxldGUgYm9keVsnbmV3RW1haWwnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9nZW5lcmF0ZV9saW5rYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZXIgQWRtaW4gQVBJXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVXNlcihhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnNgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGxpc3Qgb2YgdXNlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQW4gb2JqZWN0IHdoaWNoIHN1cHBvcnRzIGBwYWdlYCBhbmQgYHBlclBhZ2VgIGFzIG51bWJlcnMsIHRvIGFsdGVyIHRoZSBwYWdpbmF0ZWQgcmVzdWx0cy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VXNlcnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBwYWdlOiAoX2IgPSAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLFxuICAgICAgICAgICAgICAgICAgICBwZXJfcGFnZTogKF9kID0gKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBlclBhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzcG9uc2UuZXJyb3I7XG4gICAgICAgICAgICBjb25zdCB1c2VycyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gKF9nID0gKF9mID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNwbGl0KCcsJykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1c2VycyksIHBhZ2luYXRpb24pLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcnM6IFtdIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdXNlciBieSBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1aWQgVGhlIHVzZXIncyB1bmlxdWUgaWRlbnRpZmllclxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VyQnlJZCh1aWQpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHVpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3VpZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlcyBUaGUgZGF0YSB5b3Ugd2FudCB0byB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXJCeUlkKHVpZCwgYXR0cmlidXRlcykge1xuICAgICAgICB2YWxpZGF0ZVVVSUQodWlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgdXNlci4gUmVxdWlyZXMgYSBgc2VydmljZV9yb2xlYCBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIHVzZXIgaWQgeW91IHdhbnQgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSBzaG91bGRTb2Z0RGVsZXRlIElmIHRydWUsIHRoZW4gdGhlIHVzZXIgd2lsbCBiZSBzb2Z0LWRlbGV0ZWQgZnJvbSB0aGUgYXV0aCBzY2hlbWEuIFNvZnQgZGVsZXRpb24gYWxsb3dzIHVzZXIgaWRlbnRpZmljYXRpb24gZnJvbSB0aGUgaGFzaGVkIHVzZXIgSUQgYnV0IGlzIG5vdCByZXZlcnNpYmxlLlxuICAgICAqIERlZmF1bHRzIHRvIGZhbHNlIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGVVc2VyKGlkLCBzaG91bGRTb2Z0RGVsZXRlID0gZmFsc2UpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKGlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7aWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZF9zb2Z0X2RlbGV0ZTogc2hvdWxkU29mdERlbGV0ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbGlzdEZhY3RvcnMocGFyYW1zKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRChwYXJhbXMudXNlcklkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGZhY3RvcnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBmYWN0b3JzIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2RlbGV0ZUZhY3RvcihwYXJhbXMpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHBhcmFtcy51c2VySWQpO1xuICAgICAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLmlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7cGFyYW1zLnVzZXJJZH0vZmFjdG9ycy8ke3BhcmFtcy5pZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgT0F1dGggY2xpZW50cyB3aXRoIG9wdGlvbmFsIHBhZ2luYXRpb24uXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX2xpc3RPQXV0aENsaWVudHMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2luYXRpb24gPSB7IG5leHRQYWdlOiBudWxsLCBsYXN0UGFnZTogMCwgdG90YWw6IDAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IChfYiA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHBlcl9wYWdlOiAoX2QgPSAoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGVyUGFnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudHMgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbCA9IChfZSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXRvdGFsLWNvdW50JykpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IChfZyA9IChfZiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdsaW5rJykpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zcGxpdCgnLCcpKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBbXTtcbiAgICAgICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGlua3MuZm9yRWFjaCgobGluaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlID0gcGFyc2VJbnQobGluay5zcGxpdCgnOycpWzBdLnNwbGl0KCc9JylbMV0uc3Vic3RyaW5nKDAsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsID0gSlNPTi5wYXJzZShsaW5rLnNwbGl0KCc7JylbMV0uc3BsaXQoJz0nKVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRpb25bYCR7cmVsfVBhZ2VgXSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcGFnaW5hdGlvbi50b3RhbCA9IHBhcnNlSW50KHRvdGFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2xpZW50cyksIHBhZ2luYXRpb24pLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgY2xpZW50czogW10gfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9jcmVhdGVPQXV0aENsaWVudChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRPQXV0aENsaWVudChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IChjbGllbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogY2xpZW50LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbiBleGlzdGluZyBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX3VwZGF0ZU9BdXRoQ2xpZW50KGNsaWVudElkLCBwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH1gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGFuIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfZGVsZXRlT0F1dGhDbGllbnQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZXMgdGhlIHNlY3JldCBmb3IgYW4gT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWdlbmVyYXRlT0F1dGhDbGllbnRTZWNyZXQoY2xpZW50SWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9L3JlZ2VuZXJhdGVfc2VjcmV0YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdvVHJ1ZUFkbWluQXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJfX3Jlc3QiLCJfZ2VuZXJhdGVMaW5rUmVzcG9uc2UiLCJfbm9SZXNvbHZlSnNvblJlc3BvbnNlIiwiX3JlcXVlc3QiLCJfdXNlclJlc3BvbnNlIiwicmVzb2x2ZUZldGNoIiwidmFsaWRhdGVVVUlEIiwiU0lHTl9PVVRfU0NPUEVTIiwiaXNBdXRoRXJyb3IiLCJHb1RydWVBZG1pbkFwaSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImZldGNoIiwibWZhIiwibGlzdEZhY3RvcnMiLCJfbGlzdEZhY3RvcnMiLCJiaW5kIiwiZGVsZXRlRmFjdG9yIiwiX2RlbGV0ZUZhY3RvciIsIm9hdXRoIiwibGlzdENsaWVudHMiLCJfbGlzdE9BdXRoQ2xpZW50cyIsImNyZWF0ZUNsaWVudCIsIl9jcmVhdGVPQXV0aENsaWVudCIsImdldENsaWVudCIsIl9nZXRPQXV0aENsaWVudCIsInVwZGF0ZUNsaWVudCIsIl91cGRhdGVPQXV0aENsaWVudCIsImRlbGV0ZUNsaWVudCIsIl9kZWxldGVPQXV0aENsaWVudCIsInJlZ2VuZXJhdGVDbGllbnRTZWNyZXQiLCJfcmVnZW5lcmF0ZU9BdXRoQ2xpZW50U2VjcmV0Iiwic2lnbk91dCIsImp3dCIsInNjb3BlIiwiaW5kZXhPZiIsIkVycm9yIiwiam9pbiIsIm5vUmVzb2x2ZUpzb24iLCJkYXRhIiwiZXJyb3IiLCJpbnZpdGVVc2VyQnlFbWFpbCIsImVtYWlsIiwib3B0aW9ucyIsImJvZHkiLCJyZWRpcmVjdFRvIiwieGZvcm0iLCJ1c2VyIiwiZ2VuZXJhdGVMaW5rIiwicGFyYW1zIiwicmVzdCIsIk9iamVjdCIsImFzc2lnbiIsIm5ld19lbWFpbCIsIm5ld0VtYWlsIiwicHJvcGVydGllcyIsImNyZWF0ZVVzZXIiLCJhdHRyaWJ1dGVzIiwibGlzdFVzZXJzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJwYWdpbmF0aW9uIiwibmV4dFBhZ2UiLCJsYXN0UGFnZSIsInRvdGFsIiwicmVzcG9uc2UiLCJxdWVyeSIsInBhZ2UiLCJ0b1N0cmluZyIsInBlcl9wYWdlIiwicGVyUGFnZSIsInVzZXJzIiwianNvbiIsImdldCIsImxpbmtzIiwic3BsaXQiLCJsZW5ndGgiLCJmb3JFYWNoIiwibGluayIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwicmVsIiwiSlNPTiIsInBhcnNlIiwiZ2V0VXNlckJ5SWQiLCJ1aWQiLCJ1cGRhdGVVc2VyQnlJZCIsImRlbGV0ZVVzZXIiLCJpZCIsInNob3VsZFNvZnREZWxldGUiLCJzaG91bGRfc29mdF9kZWxldGUiLCJ1c2VySWQiLCJmYWN0b3JzIiwiY2xpZW50cyIsImNsaWVudCIsImNsaWVudElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/polyfills */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/web3/ethereum */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\");\n/* harmony import */ var _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/webauthn */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_7__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false,\n    throwOnError: false,\n    lockAcquireTimeout: 10000\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\n/**\n * Caches JWKS values for all clients created in the same environment. This is\n * especially useful for shared-memory execution environments such as Vercel's\n * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how\n * many clients are created, if they share the same storage key they will use\n * the same JWKS cache, significantly speeding up getClaims() with asymmetric\n * JWTs.\n */ const GLOBAL_JWKS = {};\nclass GoTrueClient {\n    /**\n     * The JWKS used for verifying asymmetric JWTs\n     */ get jwks() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {\n            keys: []\n        };\n    }\n    set jwks(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            jwks: value\n        });\n    }\n    get jwks_cached_at() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n    }\n    set jwks_cached_at(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            cachedAt: value\n        });\n    }\n    /**\n     * Create a new client for use in the browser.\n     *\n     * @example\n     * ```ts\n     * import { GoTrueClient } from '@supabase/auth-js'\n     *\n     * const auth = new GoTrueClient({\n     *   url: 'https://xyzcompany.supabase.co/auth/v1',\n     *   headers: { apikey: 'public-anon-key' },\n     *   storageKey: 'supabase-auth',\n     * })\n     * ```\n     */ constructor(options){\n        var _a, _b, _c;\n        /**\n         * @experimental\n         */ this.userStorage = null;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.autoRefreshTickTimeout = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the auth state is known and it's safe to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.storageKey = settings.storageKey;\n        this.instanceID = (_a = GoTrueClient.nextInstanceID[this.storageKey]) !== null && _a !== void 0 ? _a : 0;\n        GoTrueClient.nextInstanceID[this.storageKey] = this.instanceID + 1;\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            const message = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;\n            console.warn(message);\n            if (this.logDebugMessages) {\n                console.trace(message);\n            }\n        }\n        this.persistSession = settings.persistSession;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        this.throwOnError = settings.throwOnError;\n        this.lockAcquireTimeout = settings.lockAcquireTimeout;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if (this.persistSession && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        if (!this.jwks) {\n            this.jwks = {\n                keys: []\n            };\n            this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n            webauthn: new _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.WebAuthnApi(this)\n        };\n        this.oauth = {\n            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),\n            approveAuthorization: this._approveAuthorization.bind(this),\n            denyAuthorization: this._denyAuthorization.bind(this),\n            listGrants: this._listOAuthGrants.bind(this),\n            revokeGrant: this._revokeOAuthGrant.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = globalThis.localStorage;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n            if (settings.userStorage) {\n                this.userStorage = settings.userStorage;\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_c = this.broadcastChannel) === null || _c === void 0 ? void 0 : _c.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    /**\n     * Returns whether error throwing mode is enabled for this client.\n     */ isThrowOnErrorEnabled() {\n        return this.throwOnError;\n    }\n    /**\n     * Centralizes return handling with optional error throwing. When `throwOnError` is enabled\n     * and the provided result contains a non-nullish error, the error is thrown instead of\n     * being returned. This ensures consistent behavior across all public API methods.\n     */ _returnResult(result) {\n        if (this.throwOnError && result && result.error) {\n            throw result.error;\n        }\n        return result;\n    }\n    _logPrefix() {\n        return \"GoTrueClient@\" + `${this.storageKey}:${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_8__.version}) ${new Date().toISOString()}`;\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(this._logPrefix(), ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            let params = {};\n            let callbackUrlType = \"none\";\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n                if (this._isImplicitGrantCallback(params)) {\n                    callbackUrlType = \"implicit\";\n                } else if (await this._isPKCECallback(params)) {\n                    callbackUrlType = \"pkce\";\n                }\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // Don't remove existing session on URL login failure.\n                    // A failed attempt (e.g. reused magic link) shouldn't invalidate a valid session.\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    error\n                });\n            }\n            return this._returnResult({\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(\"Unexpected error during initialization\", error)\n            });\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                });\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    /**\n     * Signs in a user by verifying a message signed by the user's private key.\n     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,\n     * both of which derive from the EIP-4361 standard\n     * With slight variation on Solana's side.\n     * @reference https://eips.ethereum.org/EIPS/eip-4361\n     */ async signInWithWeb3(credentials) {\n        const { chain } = credentials;\n        switch(chain){\n            case \"ethereum\":\n                return await this.signInWithEthereum(credentials);\n            case \"solana\":\n                return await this.signInWithSolana(credentials);\n            default:\n                throw new Error(`@supabase/auth-js: Unsupported chain \"${chain}\"`);\n        }\n    }\n    async signInWithEthereum(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // TODO: flatten type\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"ethereum\" in windowAny && typeof windowAny.ethereum === \"object\" && \"request\" in windowAny.ethereum && typeof windowAny.ethereum.request === \"function\") {\n                    resolvedWallet = windowAny.ethereum;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            const accounts = await resolvedWallet.request({\n                method: \"eth_requestAccounts\"\n            }).then((accs)=>accs).catch(()=>{\n                throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);\n            }\n            const address = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.getAddress)(accounts[0]);\n            let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;\n            if (!chainId) {\n                const chainIdHex = await resolvedWallet.request({\n                    method: \"eth_chainId\"\n                });\n                chainId = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.fromHex)(chainIdHex);\n            }\n            const siweMessage = {\n                domain: url.host,\n                address: address,\n                statement: statement,\n                uri: url.href,\n                version: \"1\",\n                chainId: chainId,\n                nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,\n                issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),\n                expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,\n                notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,\n                requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,\n                resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources\n            };\n            message = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.createSiweMessage)(siweMessage);\n            // Sign message\n            signature = await resolvedWallet.request({\n                method: \"personal_sign\",\n                params: [\n                    (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.toHex)(message),\n                    address\n                ]\n            });\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"ethereum\",\n                    message,\n                    signature\n                }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async signInWithSolana(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"solana\" in windowAny && typeof windowAny.solana === \"object\" && (\"signIn\" in windowAny.solana && typeof windowAny.solana.signIn === \"function\" || \"signMessage\" in windowAny.solana && typeof windowAny.solana.signMessage === \"function\")) {\n                    resolvedWallet = windowAny.solana;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            if (\"signIn\" in resolvedWallet && resolvedWallet.signIn) {\n                const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({\n                    issuedAt: new Date().toISOString()\n                }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {\n                    // non-overridable properties\n                    version: \"1\",\n                    domain: url.host,\n                    uri: url.href\n                }), statement ? {\n                    statement\n                } : null));\n                let outputToProcess;\n                if (Array.isArray(output) && output[0] && typeof output[0] === \"object\") {\n                    outputToProcess = output[0];\n                } else if (output && typeof output === \"object\" && \"signedMessage\" in output && \"signature\" in output) {\n                    outputToProcess = output;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() returned unrecognized value\");\n                }\n                if (\"signedMessage\" in outputToProcess && \"signature\" in outputToProcess && (typeof outputToProcess.signedMessage === \"string\" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {\n                    message = typeof outputToProcess.signedMessage === \"string\" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);\n                    signature = outputToProcess.signature;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields\");\n                }\n            } else {\n                if (!(\"signMessage\" in resolvedWallet) || typeof resolvedWallet.signMessage !== \"function\" || !(\"publicKey\" in resolvedWallet) || typeof resolvedWallet !== \"object\" || !resolvedWallet.publicKey || !(\"toBase58\" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== \"function\") {\n                    throw new Error(\"@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API\");\n                }\n                message = [\n                    `${url.host} wants you to sign in with your Solana account:`,\n                    resolvedWallet.publicKey.toBase58(),\n                    ...statement ? [\n                        \"\",\n                        statement,\n                        \"\"\n                    ] : [\n                        \"\"\n                    ],\n                    \"Version: 1\",\n                    `URI: ${url.href}`,\n                    `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString()}`,\n                    ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [\n                        `Not Before: ${options.signInWithSolana.notBefore}`\n                    ] : [],\n                    ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [\n                        `Expiration Time: ${options.signInWithSolana.expirationTime}`\n                    ] : [],\n                    ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [\n                        `Chain ID: ${options.signInWithSolana.chainId}`\n                    ] : [],\n                    ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [\n                        `Nonce: ${options.signInWithSolana.nonce}`\n                    ] : [],\n                    ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [\n                        `Request ID: ${options.signInWithSolana.requestId}`\n                    ] : [],\n                    ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [\n                        \"Resources\",\n                        ...options.signInWithSolana.resources.map((resource)=>`- ${resource}`)\n                    ] : []\n                ].join(\"\\n\");\n                const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), \"utf8\");\n                if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n                    throw new Error(\"@supabase/auth-js: Wallet signMessage() API returned an recognized value\");\n                }\n                signature = maybeSignature;\n            }\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"solana\",\n                    message,\n                    signature: (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.bytesToBase64URL)(signature)\n                }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign({}, data),\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            if (!codeVerifier && this.flowType === \"pkce\") {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCECodeVerifierMissingError();\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (!data || !data.session || !data.user) {\n                const invalidTokenError = new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError();\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: invalidTokenError\n                });\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return this._returnResult({\n                data,\n                error\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                const tokenVerificationError = new Error(\"An error occurred on token verification.\");\n                throw tokenVerificationError;\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c, _d, _e;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            const result = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse\n            });\n            // Automatically redirect in browser unless skipBrowserRedirect is true\n            if (((_d = result.data) === null || _d === void 0 ? void 0 : _d.url) && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_e = params.options) === null || _e === void 0 ? void 0 : _e.skipBrowserRedirect)) {\n                window.location.assign(result.data.url);\n            }\n            return this._returnResult(result);\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                });\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", `session has${hasExpired ? \"\" : \" not\"} expired`, \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.userStorage) {\n                    const maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                    if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {\n                        currentSession.user = maybeUser.user;\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n                // Wrap the user object with a warning proxy on the server\n                // This warns when properties of the user are accessed, not when session.user itself is accessed\n                if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {\n                    const suppressWarningRef = {\n                        value: this.suppressGetSessionWarning\n                    };\n                    currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);\n                    // Update the client-level suppression flag when the proxy suppresses the warning\n                    if (suppressWarningRef.value) {\n                        this.suppressGetSessionWarning = true;\n                    }\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return this._returnResult({\n                    data: {\n                        session: null\n                    },\n                    error\n                });\n            }\n            return this._returnResult({\n                data: {\n                    session\n                },\n                error: null\n            });\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._getUser();\n        });\n        if (result.data.user) {\n            this.suppressGetSessionWarning = true;\n        }\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"PUT\", `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n                if (userError) {\n                    throw userError;\n                }\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return this._returnResult({\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return this._returnResult({\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    });\n                }\n                return this._returnResult({\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type: token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return this._returnResult({\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     *\n     * If `detectSessionInUrl` is a function, it will be called with the URL and params to determine\n     * if the URL should be processed as a Supabase auth callback. This allows users to exclude\n     * URLs from other OAuth providers (e.g., Facebook Login) that also return access_token in the fragment.\n     */ _isImplicitGrantCallback(params) {\n        if (typeof this.detectSessionInUrl === \"function\") {\n            return this.detectSessionInUrl(new URL(window.location.href), params);\n        }\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut(options = {\n        scope: \"global\"\n    }) {\n        await this.initializePromise;\n        return await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = {\n        scope: \"global\"\n    }) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return this._returnResult({\n                    error: sessionError\n                });\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return this._returnResult({\n                            error\n                        });\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return this._returnResult({\n                error: null\n            });\n        });\n    }\n    onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.generateCallbackId)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return this._returnResult({\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentity(credentials) {\n        if (\"token\" in credentials) {\n            return this.linkIdentityIdToken(credentials);\n        }\n        return this.linkIdentityOAuth(credentials);\n    }\n    async linkIdentityOAuth(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return this._returnResult({\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async linkIdentityIdToken(credentials) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            try {\n                const { error: sessionError, data: { session } } = result;\n                if (sessionError) throw sessionError;\n                const { options, provider, token, access_token, nonce } = credentials;\n                const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                    headers: this.headers,\n                    jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,\n                    body: {\n                        provider,\n                        id_token: token,\n                        access_token,\n                        nonce,\n                        link_identity: true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n                const { data, error } = res;\n                if (error) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                } else if (!data || !data.session || !data.user) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                    });\n                }\n                if (data.session) {\n                    await this._saveSession(data.session);\n                    await this._notifyAllSubscribers(\"USER_UPDATED\", data.session);\n                }\n                return this._returnResult({\n                    data,\n                    error\n                });\n            } catch (error) {\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                });\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a, _b;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            if (currentSession && this.userStorage) {\n                let maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {\n                    // storage and userStorage are the same storage medium, for example\n                    // window.localStorage if userStorage does not have the user from\n                    // storage stored, store it first thereby migrating the user object\n                    // from storage -> userStorage\n                    maybeUser = {\n                        user: currentSession.user\n                    };\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", maybeUser);\n                }\n                currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n            } else if (currentSession && !currentSession.user) {\n                // user storage is not set, let's check if it was previously enabled so\n                // we bring back the storage as it should be\n                if (!currentSession.user) {\n                    // test if userStorage was previously enabled and the storage medium was the same, to move the user back under the same key\n                    const separateUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey + \"-user\");\n                    if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {\n                        currentSession.user = separateUser.user;\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, currentSession);\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n            }\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? \"\" : \" not\"} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {\n                // If we have a proxy user, try to get the real user data\n                try {\n                    const { data, error: userError } = await this._getUser(currentSession.access_token);\n                    if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {\n                        currentSession.user = data.user;\n                        await this._saveSession(currentSession);\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n                    } else {\n                        this._debug(debugName, \"could not get user data, skipping SIGNED_IN notification\");\n                    }\n                } catch (getUserError) {\n                    console.error(\"Error getting user data:\", getUserError);\n                    this._debug(debugName, \"error getting user data, skipping SIGNED_IN notification\", getUserError);\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                data: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = {\n                    data: null,\n                    error\n                };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, \"begin\", session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere\n        const sessionToProcess = Object.assign({}, session);\n        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;\n        if (this.userStorage) {\n            if (!userIsProxy && sessionToProcess.user) {\n                // If it's a real user object, save it to userStorage.\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", {\n                    user: sessionToProcess.user\n                });\n            } else if (userIsProxy) {\n            // If it's the proxy, it means user was not found in userStorage.\n            // We should ensure no stale user data for this key exists in userStorage if we were to save null,\n            // or simply not save the proxy. For now, we don't save the proxy here.\n            // If there's a need to clear userStorage if user becomes proxy, that logic would go here.\n            }\n            // Prepare the main session data for primary storage: remove the user property before cloning\n            // This is important because the original session.user might be the proxy\n            const mainSessionData = Object.assign({}, sessionToProcess);\n            delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage\n            const clonedMainSessionData = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(mainSessionData);\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);\n        } else {\n            // No userStorage is configured.\n            // In this case, session.user should ideally not be a proxy.\n            // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here\n            const clonedSession = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(sessionToProcess); // sessionToProcess still has its original user property\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedSession);\n        }\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        this.suppressGetSessionWarning = false;\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-code-verifier\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n        if (this.userStorage) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.userStorage, this.storageKey + \"-user\");\n        }\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        const timeout = setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n        this.autoRefreshTickTimeout = timeout;\n        if (timeout && typeof timeout === \"object\" && typeof timeout.unref === \"function\") {\n            timeout.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(timeout);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n        const timeout = this.autoRefreshTickTimeout;\n        this.autoRefreshTickTimeout = null;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_6__.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(this.lockAcquireTimeout, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join(\"&\")}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : params.factorType === \"totp\" ? {\n                    issuer: params.issuer\n                } : {});\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                if (params.factorType === \"totp\" && data.type === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return this._returnResult({\n                    data,\n                    error: null\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async _verify(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const body = Object.assign({\n                        challenge_id: params.challengeId\n                    }, \"webauthn\" in params ? {\n                        webauthn: Object.assign(Object.assign({}, params.webauthn), {\n                            credential_response: params.webauthn.type === \"create\" ? (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialRequestResponse)(params.webauthn.credential_response)\n                        })\n                    } : {\n                        code: params.code\n                    });\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n                        body,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return this._returnResult({\n                            data: null,\n                            error\n                        });\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return this._returnResult({\n                        data,\n                        error\n                    });\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    async _challenge(params) {\n        return this._acquireLock(this.lockAcquireTimeout, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return this._returnResult({\n                            data: null,\n                            error: sessionError\n                        });\n                    }\n                    const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: params,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (response.error) {\n                        return response;\n                    }\n                    const { data } = response;\n                    if (data.type !== \"webauthn\") {\n                        return {\n                            data,\n                            error: null\n                        };\n                    }\n                    switch(data.webauthn.type){\n                        case \"create\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                        case \"request\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                    }\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return this._returnResult({\n                data: null,\n                error: challengeError\n            });\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        var _a;\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const data = {\n            all: [],\n            phone: [],\n            totp: [],\n            webauthn: []\n        };\n        // loop over the factors ONCE\n        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []){\n            data.all.push(factor);\n            if (factor.status === \"verified\") {\n                ;\n                data[factor.factor_type].push(factor);\n            }\n        }\n        return {\n            data,\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel() {\n        var _a, _b;\n        const { data: { session }, error: sessionError } = await this.getSession();\n        if (sessionError) {\n            return this._returnResult({\n                data: null,\n                error: sessionError\n            });\n        }\n        if (!session) {\n            return {\n                data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                },\n                error: null\n            };\n        }\n        const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);\n        let currentLevel = null;\n        if (payload.aal) {\n            currentLevel = payload.aal;\n        }\n        let nextLevel = currentLevel;\n        const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n        if (verifiedFactors.length > 0) {\n            nextLevel = \"aal2\";\n        }\n        const currentAuthenticationMethods = payload.amr || [];\n        return {\n            data: {\n                currentLevel,\n                nextLevel,\n                currentAuthenticationMethods\n            },\n            error: null\n        };\n    }\n    /**\n     * Retrieves details about an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * Returns authorization details including client info, scopes, and user information.\n     * If the API returns a redirect_uri, it means consent was already given - the caller\n     * should handle the redirect manually if needed.\n     */ async _getAuthorizationDetails(authorizationId) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/oauth/authorizations/${authorizationId}`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Approves an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _approveAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"approve\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Denies an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _denyAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"deny\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth grants that the authenticated user has authorized.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _listOAuthGrants() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user/oauth/grants`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Revokes a user's OAuth grant for a specific client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _revokeOAuthGrant(options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return this._returnResult({\n                        data: null,\n                        error: sessionError\n                    });\n                }\n                if (!session) {\n                    return this._returnResult({\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    });\n                }\n                await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/oauth/grants`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    query: {\n                        client_id: options.clientId\n                    },\n                    noResolveJson: true\n                });\n                return {\n                    data: {},\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchJwk(kid, jwks = {\n        keys: []\n    }) {\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key)=>key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        const now = Date.now();\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key)=>key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > now) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/.well-known/jwks.json`, {\n            headers: this.headers\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            return null;\n        }\n        this.jwks = data;\n        this.jwks_cached_at = now;\n        // Find the signing key\n        jwk = data.keys.find((key)=>key.kid === kid);\n        if (!jwk) {\n            return null;\n        }\n        return jwk;\n    }\n    /**\n     * Extracts the JWT claims present in the access token by first verifying the\n     * JWT against the server's JSON Web Key Set endpoint\n     * `/.well-known/jwks.json` which is often cached, resulting in significantly\n     * faster responses. Prefer this method over {@link #getUser} which always\n     * sends a request to the Auth server for each JWT.\n     *\n     * If the project is not using an asymmetric JWT signing key (like ECC or\n     * RSA) it always sends a request to the Auth server (similar to {@link\n     * #getUser}) to verify the JWT.\n     *\n     * @param jwt An optional specific JWT you wish to verify, not the one you\n     *            can obtain from {@link #getSession}.\n     * @param options Various additional options that allow you to customize the\n     *                behavior of this method.\n     */ async getClaims(jwt, options = {}) {\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return this._returnResult({\n                        data: null,\n                        error\n                    });\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);\n            if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {\n                // Reject expired JWTs should only happen if jwt argument was passed\n                (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);\n            }\n            const signingKey = !header.alg || header.alg.startsWith(\"HS\") || !header.kid || !(\"crypto\" in globalThis && \"subtle\" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? {\n                keys: options.keys\n            } : options === null || options === void 0 ? void 0 : options.jwks);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!signingKey) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature\n                    },\n                    error: null\n                };\n            }\n            const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey(\"jwk\", signingKey, algorithm, true, [\n                \"verify\"\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(`${rawHeader}.${rawPayload}`));\n            if (!isValid) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"Invalid JWT signature\");\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return this._returnResult({\n                    data: null,\n                    error\n                });\n            }\n            throw error;\n        }\n    }\n}\nGoTrueClient.nextInstanceID = {};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoTrueClient); //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDc0g7QUFDOE07QUFDalE7QUFDZ047QUFDalE7QUFDSztBQUNoQjtBQUNiO0FBQytCO0FBQ2M7QUFDNkc7QUFDbE0rQyxrRUFBa0JBLElBQUksOEJBQThCO0FBQ3BELE1BQU1hLGtCQUFrQjtJQUNwQkMsS0FBS3hELHNEQUFVQTtJQUNmeUQsWUFBWXZELHVEQUFXQTtJQUN2QndELGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFNBQVMvRCwyREFBZUE7SUFDeEJnRSxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsOEJBQThCO0lBQzlCQyxjQUFjO0lBQ2RDLG9CQUFvQjtBQUN4QjtBQUNBLGVBQWVDLFNBQVNDLElBQUksRUFBRUMsY0FBYyxFQUFFQyxFQUFFO0lBQzVDLE9BQU8sTUFBTUE7QUFDakI7QUFDQTs7Ozs7OztDQU9DLEdBQ0QsTUFBTUMsY0FBYyxDQUFDO0FBQ3JCLE1BQU1DO0lBQ0Y7O0tBRUMsR0FDRCxJQUFJQyxPQUFPO1FBQ1AsSUFBSUMsSUFBSUM7UUFDUixPQUFPLENBQUNBLEtBQUssQ0FBQ0QsS0FBS0gsV0FBVyxDQUFDLElBQUksQ0FBQ2QsVUFBVSxDQUFDLE1BQU0sUUFBUWlCLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0QsSUFBSSxNQUFNLFFBQVFFLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQUVDLE1BQU0sRUFBRTtRQUFDO0lBQy9JO0lBQ0EsSUFBSUgsS0FBS0ksS0FBSyxFQUFFO1FBQ1pOLFdBQVcsQ0FBQyxJQUFJLENBQUNkLFVBQVUsQ0FBQyxHQUFHcUIsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHUixXQUFXLENBQUMsSUFBSSxDQUFDZCxVQUFVLENBQUMsR0FBRztZQUFFZ0IsTUFB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QVUsTUFBTUwsT0FBT0csTUFBTSxDQUFDdFgsTUFBTSxDQUFDcVgsV0FBV2pPLFdBQVd2QyxXQUFXdEwsa0VBQWtCQSxDQUFDLENBQUMsRUFBRXNiLFVBQVUsQ0FBQyxFQUFFQyxXQUFXLENBQUM7WUFDM0gsSUFBSSxDQUFDVSxTQUFTO2dCQUNWLE1BQU0sSUFBSXplLDREQUFtQkEsQ0FBQztZQUNsQztZQUNBLHFEQUFxRDtZQUNyRCxPQUFPO2dCQUNIcUosTUFBTTtvQkFDRmdWLFFBQVF4SjtvQkFDUitJO29CQUNBOVA7Z0JBQ0o7Z0JBQ0E5RSxPQUFPO1lBQ1g7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJekksd0RBQVdBLENBQUN5SSxRQUFRO2dCQUNwQixPQUFPLElBQUksQ0FBQ1MsYUFBYSxDQUFDO29CQUFFSixNQUFNO29CQUFNTDtnQkFBTTtZQUNsRDtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKO0FBQ0E3RSxhQUFhaUMsY0FBYyxHQUFHLENBQUM7QUFDL0IsaUVBQWVqQyxZQUFZQSxFQUFDLENBQzVCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL0dvVHJ1ZUNsaWVudC5qcz9mNjcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVBZG1pbkFwaSBmcm9tICcuL0dvVHJ1ZUFkbWluQXBpJztcbmltcG9ydCB7IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TLCBBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTEQsIERFRkFVTFRfSEVBREVSUywgRVhQSVJZX01BUkdJTl9NUywgR09UUlVFX1VSTCwgSldLU19UVEwsIFNUT1JBR0VfS0VZLCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IsIEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciwgQXV0aEludmFsaWRKd3RFcnJvciwgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IsIEF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yLCBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBBdXRoVW5rbm93bkVycm9yLCBpc0F1dGhBcGlFcnJvciwgaXNBdXRoRXJyb3IsIGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLCBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yLCBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBfcmVxdWVzdCwgX3Nlc3Npb25SZXNwb25zZSwgX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLCBfc3NvUmVzcG9uc2UsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgZGVjb2RlSldULCBkZWVwQ2xvbmUsIERlZmVycmVkLCBnZW5lcmF0ZUNhbGxiYWNrSWQsIGdldEFsZ29yaXRobSwgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCwgZ2V0SXRlbUFzeW5jLCBpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHksIGlzQnJvd3NlciwgcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCwgcmVtb3ZlSXRlbUFzeW5jLCByZXNvbHZlRmV0Y2gsIHJldHJ5YWJsZSwgc2V0SXRlbUFzeW5jLCBzbGVlcCwgc3VwcG9ydHNMb2NhbFN0b3JhZ2UsIHVzZXJOb3RBdmFpbGFibGVQcm94eSwgdmFsaWRhdGVFeHAsIH0gZnJvbSAnLi9saWIvaGVscGVycyc7XG5pbXBvcnQgeyBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9saWIvbG9jYWwtc3RvcmFnZSc7XG5pbXBvcnQgeyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgbmF2aWdhdG9yTG9jayB9IGZyb20gJy4vbGliL2xvY2tzJztcbmltcG9ydCB7IHBvbHlmaWxsR2xvYmFsVGhpcyB9IGZyb20gJy4vbGliL3BvbHlmaWxscyc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi9saWIvdmVyc2lvbic7XG5pbXBvcnQgeyBieXRlc1RvQmFzZTY0VVJMLCBzdHJpbmdUb1VpbnQ4QXJyYXkgfSBmcm9tICcuL2xpYi9iYXNlNjR1cmwnO1xuaW1wb3J0IHsgY3JlYXRlU2l3ZU1lc3NhZ2UsIGZyb21IZXgsIGdldEFkZHJlc3MsIHRvSGV4LCB9IGZyb20gJy4vbGliL3dlYjMvZXRoZXJldW0nO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zLCBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucywgc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uUmVzcG9uc2UsIHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UsIFdlYkF1dGhuQXBpLCB9IGZyb20gJy4vbGliL3dlYmF1dGhuJztcbnBvbHlmaWxsR2xvYmFsVGhpcygpOyAvLyBNYWtlIFwiZ2xvYmFsVGhpc1wiIGF2YWlsYWJsZVxuY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIHVybDogR09UUlVFX1VSTCxcbiAgICBzdG9yYWdlS2V5OiBTVE9SQUdFX0tFWSxcbiAgICBhdXRvUmVmcmVzaFRva2VuOiB0cnVlLFxuICAgIHBlcnNpc3RTZXNzaW9uOiB0cnVlLFxuICAgIGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcbiAgICBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMsXG4gICAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IGZhbHNlLFxuICAgIHRocm93T25FcnJvcjogZmFsc2UsXG4gICAgbG9ja0FjcXVpcmVUaW1lb3V0OiAxMDAwMCwgLy8gMTAgc2Vjb25kc1xufTtcbmFzeW5jIGZ1bmN0aW9uIGxvY2tOb09wKG5hbWUsIGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgIHJldHVybiBhd2FpdCBmbigpO1xufVxuLyoqXG4gKiBDYWNoZXMgSldLUyB2YWx1ZXMgZm9yIGFsbCBjbGllbnRzIGNyZWF0ZWQgaW4gdGhlIHNhbWUgZW52aXJvbm1lbnQuIFRoaXMgaXNcbiAqIGVzcGVjaWFsbHkgdXNlZnVsIGZvciBzaGFyZWQtbWVtb3J5IGV4ZWN1dGlvbiBlbnZpcm9ubWVudHMgc3VjaCBhcyBWZXJjZWwnc1xuICogRmx1aWQgQ29tcHV0ZSwgQVdTIExhbWJkYSBvciBTdXBhYmFzZSdzIEVkZ2UgRnVuY3Rpb25zLiBSZWdhcmRsZXNzIG9mIGhvd1xuICogbWFueSBjbGllbnRzIGFyZSBjcmVhdGVkLCBpZiB0aGV5IHNoYXJlIHRoZSBzYW1lIHN0b3JhZ2Uga2V5IHRoZXkgd2lsbCB1c2VcbiAqIHRoZSBzYW1lIEpXS1MgY2FjaGUsIHNpZ25pZmljYW50bHkgc3BlZWRpbmcgdXAgZ2V0Q2xhaW1zKCkgd2l0aCBhc3ltbWV0cmljXG4gKiBKV1RzLlxuICovXG5jb25zdCBHTE9CQUxfSldLUyA9IHt9O1xuY2xhc3MgR29UcnVlQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSldLUyB1c2VkIGZvciB2ZXJpZnlpbmcgYXN5bW1ldHJpYyBKV1RzXG4gICAgICovXG4gICAgZ2V0IGp3a3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuandrcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogeyBrZXlzOiBbXSB9O1xuICAgIH1cbiAgICBzZXQgandrcyh2YWx1ZSkge1xuICAgICAgICBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSwgeyBqd2tzOiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgZ2V0IGp3a3NfY2FjaGVkX2F0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhY2hlZEF0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gICAgc2V0IGp3a3NfY2FjaGVkX2F0KHZhbHVlKSB7XG4gICAgICAgIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pLCB7IGNhY2hlZEF0OiB2YWx1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEdvVHJ1ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QgYXV0aCA9IG5ldyBHb1RydWVDbGllbnQoe1xuICAgICAqICAgdXJsOiAnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL2F1dGgvdjEnLFxuICAgICAqICAgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0sXG4gICAgICogICBzdG9yYWdlS2V5OiAnc3VwYWJhc2UtYXV0aCcsXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyU3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMubWVtb3J5U3RvcmFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBhc3luYyBjbGllbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAqIFdoZW4gbnVsbCBvciBub3QgeWV0IHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGB1bmtub3duYFxuICAgICAgICAgKiBPbmNlIHJlc29sdmVkIHRoZSBhdXRoIHN0YXRlIGlzIGtub3duIGFuZCBpdCdzIHNhZmUgdG8gY2FsbCBhbnkgZnVydGhlciBjbGllbnQgbWV0aG9kcy5cbiAgICAgICAgICogS2VlcCBleHRyYSBjYXJlIHRvIG5ldmVyIHJlamVjdCBvciB0aHJvdyB1bmNhdWdodCBlcnJvcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGJyb2FkY2FzdCBzdGF0ZSBjaGFuZ2UgZXZlbnRzIHRvIG90aGVyIHRhYnMgbGlzdGVuaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBjb25zb2xlLmxvZztcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5zdG9yYWdlS2V5O1xuICAgICAgICB0aGlzLmluc3RhbmNlSUQgPSAoX2EgPSBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSURbdGhpcy5zdG9yYWdlS2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEW3RoaXMuc3RvcmFnZUtleV0gPSB0aGlzLmluc3RhbmNlSUQgKyAxO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnTWVzc2FnZXMgPSAhIXNldHRpbmdzLmRlYnVnO1xuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLmRlYnVnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlciA9IHNldHRpbmdzLmRlYnVnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlSUQgPiAwICYmIGlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7dGhpcy5fbG9nUHJlZml4KCl9IE11bHRpcGxlIEdvVHJ1ZUNsaWVudCBpbnN0YW5jZXMgZGV0ZWN0ZWQgaW4gdGhlIHNhbWUgYnJvd3NlciBjb250ZXh0LiBJdCBpcyBub3QgYW4gZXJyb3IsIGJ1dCB0aGlzIHNob3VsZCBiZSBhdm9pZGVkIGFzIGl0IG1heSBwcm9kdWNlIHVuZGVmaW5lZCBiZWhhdmlvciB3aGVuIHVzZWQgY29uY3VycmVudGx5IHVuZGVyIHRoZSBzYW1lIHN0b3JhZ2Uga2V5LmA7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2dEZWJ1Z01lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlcnNpc3RTZXNzaW9uID0gc2V0dGluZ3MucGVyc2lzdFNlc3Npb247XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUb2tlbiA9IHNldHRpbmdzLmF1dG9SZWZyZXNoVG9rZW47XG4gICAgICAgIHRoaXMuYWRtaW4gPSBuZXcgR29UcnVlQWRtaW5BcGkoe1xuICAgICAgICAgICAgdXJsOiBzZXR0aW5ncy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiBzZXR0aW5ncy5oZWFkZXJzLFxuICAgICAgICAgICAgZmV0Y2g6IHNldHRpbmdzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cmwgPSBzZXR0aW5ncy51cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IHNldHRpbmdzLmhlYWRlcnM7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goc2V0dGluZ3MuZmV0Y2gpO1xuICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrIHx8IGxvY2tOb09wO1xuICAgICAgICB0aGlzLmRldGVjdFNlc3Npb25JblVybCA9IHNldHRpbmdzLmRldGVjdFNlc3Npb25JblVybDtcbiAgICAgICAgdGhpcy5mbG93VHlwZSA9IHNldHRpbmdzLmZsb3dUeXBlO1xuICAgICAgICB0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIgPSBzZXR0aW5ncy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyO1xuICAgICAgICB0aGlzLnRocm93T25FcnJvciA9IHNldHRpbmdzLnRocm93T25FcnJvcjtcbiAgICAgICAgdGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQgPSBzZXR0aW5ncy5sb2NrQWNxdWlyZVRpbWVvdXQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5sb2NrKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBzZXR0aW5ncy5sb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVyc2lzdFNlc3Npb24gJiYgaXNCcm93c2VyKCkgJiYgKChfYiA9IGdsb2JhbFRoaXMgPT09IG51bGwgfHwgZ2xvYmFsVGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sb2NrcykpIHtcbiAgICAgICAgICAgIHRoaXMubG9jayA9IG5hdmlnYXRvckxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBsb2NrTm9PcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuandrcykge1xuICAgICAgICAgICAgdGhpcy5qd2tzID0geyBrZXlzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgd2ViYXV0aG46IG5ldyBXZWJBdXRobkFwaSh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYXV0aCA9IHtcbiAgICAgICAgICAgIGdldEF1dGhvcml6YXRpb25EZXRhaWxzOiB0aGlzLl9nZXRBdXRob3JpemF0aW9uRGV0YWlscy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYXBwcm92ZUF1dGhvcml6YXRpb246IHRoaXMuX2FwcHJvdmVBdXRob3JpemF0aW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZW55QXV0aG9yaXphdGlvbjogdGhpcy5fZGVueUF1dGhvcml6YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxpc3RHcmFudHM6IHRoaXMuX2xpc3RPQXV0aEdyYW50cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcmV2b2tlR3JhbnQ6IHRoaXMuX3Jldm9rZU9BdXRoR3JhbnQuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdFNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gc2V0dGluZ3Muc3RvcmFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJTdG9yYWdlID0gc2V0dGluZ3MudXNlclN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwodGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBhIG5ldyBCcm9hZGNhc3RDaGFubmVsLCBtdWx0aS10YWIgc3RhdGUgY2hhbmdlcyB3aWxsIG5vdCBiZSBhdmFpbGFibGUnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYyA9IHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5zZXNzaW9uLCBmYWxzZSk7IC8vIGJyb2FkY2FzdCA9IGZhbHNlIHNvIHdlIGRvbid0IGdldCBhbiBlbmRsZXNzIGxvb3Agb2YgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgZXJyb3IgdGhyb3dpbmcgbW9kZSBpcyBlbmFibGVkIGZvciB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBpc1Rocm93T25FcnJvckVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocm93T25FcnJvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2VudHJhbGl6ZXMgcmV0dXJuIGhhbmRsaW5nIHdpdGggb3B0aW9uYWwgZXJyb3IgdGhyb3dpbmcuIFdoZW4gYHRocm93T25FcnJvcmAgaXMgZW5hYmxlZFxuICAgICAqIGFuZCB0aGUgcHJvdmlkZWQgcmVzdWx0IGNvbnRhaW5zIGEgbm9uLW51bGxpc2ggZXJyb3IsIHRoZSBlcnJvciBpcyB0aHJvd24gaW5zdGVhZCBvZlxuICAgICAqIGJlaW5nIHJldHVybmVkLiBUaGlzIGVuc3VyZXMgY29uc2lzdGVudCBiZWhhdmlvciBhY3Jvc3MgYWxsIHB1YmxpYyBBUEkgbWV0aG9kcy5cbiAgICAgKi9cbiAgICBfcmV0dXJuUmVzdWx0KHJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgcmVzdWx0ICYmIHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9sb2dQcmVmaXgoKSB7XG4gICAgICAgIHJldHVybiAoJ0dvVHJ1ZUNsaWVudEAnICtcbiAgICAgICAgICAgIGAke3RoaXMuc3RvcmFnZUtleX06JHt0aGlzLmluc3RhbmNlSUR9ICgke3ZlcnNpb259KSAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgX2RlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9nRGVidWdNZXNzYWdlcykge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIodGhpcy5fbG9nUHJlZml4KCksIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY2xpZW50IHNlc3Npb24gZWl0aGVyIGZyb20gdGhlIHVybCBvciBmcm9tIHN0b3JhZ2UuXG4gICAgICogVGhpcyBtZXRob2QgaXMgYXV0b21hdGljYWxseSBjYWxsZWQgd2hlbiBpbnN0YW50aWF0aW5nIHRoZSBjbGllbnQsIGJ1dCBzaG91bGQgYWxzbyBiZSBjYWxsZWRcbiAgICAgKiBtYW51YWxseSB3aGVuIGNoZWNraW5nIGZvciBhbiBlcnJvciBmcm9tIGFuIGF1dGggcmVkaXJlY3QgKG9hdXRoLCBtYWdpY2xpbmssIHBhc3N3b3JkIHJlY292ZXJ5LCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemVQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElNUE9SVEFOVDpcbiAgICAgKiAxLiBOZXZlciB0aHJvdyBpbiB0aGlzIG1ldGhvZCwgYXMgaXQgaXMgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICogMi4gTmV2ZXIgcmV0dXJuIGEgc2Vzc2lvbiBmcm9tIHRoaXMgbWV0aG9kIGFzIGl0IHdvdWxkIGJlIGNhY2hlZCBvdmVyXG4gICAgICogICAgdGhlIHdob2xlIGxpZmV0aW1lIG9mIHRoZSBjbGllbnRcbiAgICAgKi9cbiAgICBhc3luYyBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHBhcmFtcyA9IHt9O1xuICAgICAgICAgICAgbGV0IGNhbGxiYWNrVXJsVHlwZSA9ICdub25lJztcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF3YWl0IHRoaXMuX2lzUEtDRUNhbGxiYWNrKHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0ZW1wdCB0byBnZXQgdGhlIHNlc3Npb24gZnJvbSB0aGUgVVJMIG9ubHkgaWYgdGhlc2UgY29uZGl0aW9ucyBhcmUgZnVsZmlsbGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZTogSWYgdGhlIFVSTCBpc24ndCBvbmUgb2YgdGhlIGNhbGxiYWNrIHVybCB0eXBlcyAoaW1wbGljaXQgb3IgcGtjZSksXG4gICAgICAgICAgICAgKiB0aGVuIHRoZXJlIGNvdWxkIGJlIGFuIGV4aXN0aW5nIHNlc3Npb24gc28gd2UgZG9uJ3Qgd2FudCB0byBwcmVtYXR1cmVseSByZW1vdmUgaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsICYmIGNhbGxiYWNrVXJsVHlwZSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0U2Vzc2lvbkZyb21VUkwocGFyYW1zLCBjYWxsYmFja1VybFR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZXJyb3IgZGV0ZWN0aW5nIHNlc3Npb24gZnJvbSBVUkwnLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IChfYSA9IGVycm9yLmRldGFpbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X2FscmVhZHlfZXhpc3RzJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ2lkZW50aXR5X25vdF9mb3VuZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGUgPT09ICdzaW5nbGVfaWRlbnRpdHlfbm90X2RlbGV0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHJlbW92ZSBleGlzdGluZyBzZXNzaW9uIG9uIFVSTCBsb2dpbiBmYWlsdXJlLlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGZhaWxlZCBhdHRlbXB0IChlLmcuIHJldXNlZCBtYWdpYyBsaW5rKSBzaG91bGRuJ3QgaW52YWxpZGF0ZSBhIHZhbGlkIHNlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsIHNlc3Npb24sICdyZWRpcmVjdCB0eXBlJywgcmVkaXJlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19pbml0aWFsaXplKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc2Vzc2lvbiB3aGVyZSB0aGUgaXNfYW5vbnltb3VzIGNsYWltIGluIHRoZSBhY2Nlc3MgdG9rZW4gSldUIHNldCB0byB0cnVlXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluQW5vbnltb3VzbHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gKF9hID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9jID0gY3JlZGVudGlhbHMgPT09IG51bGwgfHwgY3JlZGVudGlhbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB1c2VyLlxuICAgICAqXG4gICAgICogQmUgYXdhcmUgdGhhdCBpZiBhIHVzZXIgYWNjb3VudCBleGlzdHMgaW4gdGhlIHN5c3RlbSB5b3UgbWF5IGdldCBiYWNrIGFuXG4gICAgICogZXJyb3IgbWVzc2FnZSB0aGF0IGF0dGVtcHRzIHRvIGhpZGUgdGhpcyBpbmZvcm1hdGlvbiBmcm9tIHRoZSB1c2VyLlxuICAgICAqIFRoaXMgbWV0aG9kIGhhcyBzdXBwb3J0IGZvciBQS0NFIHZpYSBlbWFpbCBzaWdudXBzLiBUaGUgUEtDRSBmbG93IGNhbm5vdCBiZSB1c2VkIHdoZW4gYXV0b2NvbmZpcm0gaXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbG9nZ2VkLWluIHNlc3Npb24gaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9OXG4gICAgICogQHJldHVybnMgQSB1c2VyIGlmIHRoZSBzZXJ2ZXIgaGFzIFwiYXV0b2NvbmZpcm1cIiBPRkZcbiAgICAgKi9cbiAgICBhc3luYyBzaWduVXAoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVzO1xuICAgICAgICAgICAgaWYgKCdlbWFpbCcgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtYWlsLCBwYXNzd29yZCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ3Bob25lJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGhvbmUsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zaWdudXBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWw6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnc21zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgcGFzc3dvcmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyB1c2VyOiBkYXRhLnVzZXIsIHNlc3Npb246IGRhdGEuc2Vzc2lvbiB9LCAoZGF0YS53ZWFrX3Bhc3N3b3JkID8geyB3ZWFrUGFzc3dvcmQ6IGRhdGEud2Vha19wYXNzd29yZCB9IDogbnVsbCkpLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHZpYSBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aE9BdXRoKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2hhbmRsZVByb3ZpZGVyU2lnbkluKGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICByZWRpcmVjdFRvOiAoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBza2lwQnJvd3NlclJlZGlyZWN0OiAoX2QgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2tpcEJyb3dzZXJSZWRpcmVjdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIGJ5IGV4Y2hhbmdpbmcgYW4gQXV0aCBDb2RlIGlzc3VlZCBkdXJpbmcgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBleGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gYSB1c2VyIGJ5IHZlcmlmeWluZyBhIG1lc3NhZ2Ugc2lnbmVkIGJ5IHRoZSB1c2VyJ3MgcHJpdmF0ZSBrZXkuXG4gICAgICogU3VwcG9ydHMgRXRoZXJldW0gKHZpYSBTaWduLUluLVdpdGgtRXRoZXJldW0pICYgU29sYW5hIChTaWduLUluLVdpdGgtU29sYW5hKSBzdGFuZGFyZHMsXG4gICAgICogYm90aCBvZiB3aGljaCBkZXJpdmUgZnJvbSB0aGUgRUlQLTQzNjEgc3RhbmRhcmRcbiAgICAgKiBXaXRoIHNsaWdodCB2YXJpYXRpb24gb24gU29sYW5hJ3Mgc2lkZS5cbiAgICAgKiBAcmVmZXJlbmNlIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhXZWIzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW4gfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICBjYXNlICdldGhlcmV1bSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aEV0aGVyZXVtKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGNhc2UgJ3NvbGFuYSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuc2lnbkluV2l0aFNvbGFuYShjcmVkZW50aWFscyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IFVuc3VwcG9ydGVkIGNoYWluIFwiJHtjaGFpbn1cImApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhFdGhlcmV1bShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgICAgICAvLyBUT0RPOiBmbGF0dGVuIHR5cGVcbiAgICAgICAgbGV0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBzaWduYXR1cmU7XG4gICAgICAgIGlmICgnbWVzc2FnZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVkZW50aWFscy5tZXNzYWdlO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gY3JlZGVudGlhbHMuc2lnbmF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbiwgd2FsbGV0LCBzdGF0ZW1lbnQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkV2FsbGV0O1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAnb2JqZWN0JyB8fCAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IEJvdGggd2FsbGV0IGFuZCB1cmwgbXVzdCBiZSBzcGVjaWZpZWQgaW4gbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3YWxsZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3dBbnkgPSB3aW5kb3c7XG4gICAgICAgICAgICAgICAgaWYgKCdldGhlcmV1bScgaW4gd2luZG93QW55ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB3aW5kb3dBbnkuZXRoZXJldW0gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdyZXF1ZXN0JyBpbiB3aW5kb3dBbnkuZXRoZXJldW0gJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5ldGhlcmV1bS5yZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2luZG93QW55LmV0aGVyZXVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gY29tcGF0aWJsZSBFdGhlcmV1bSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuZXRoZXJldW0pIGRldGVjdGVkLiBNYWtlIHN1cmUgdGhlIHVzZXIgYWxyZWFkeSBoYXMgYSB3YWxsZXQgaW5zdGFsbGVkIGFuZCBjb25uZWN0ZWQgZm9yIHRoaXMgYXBwLiBQcmVmZXIgcGFzc2luZyB0aGUgd2FsbGV0IGludGVyZmFjZSBvYmplY3QgZGlyZWN0bHkgdG8gc2lnbkluV2l0aFdlYjMoeyBjaGFpbjogJ2V0aGVyZXVtJywgd2FsbGV0OiByZXNvbHZlZFVzZXJXYWxsZXQgfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51cmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChhY2NzKSA9PiBhY2NzKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBldGhfcmVxdWVzdEFjY291bnRzIGlzIG1pc3Npbmcgb3IgaW52YWxpZGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IE5vIGFjY291bnRzIGF2YWlsYWJsZS4gUGxlYXNlIGVuc3VyZSB0aGUgd2FsbGV0IGlzIGNvbm5lY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBnZXRBZGRyZXNzKGFjY291bnRzWzBdKTtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoYWluSWQ7XG4gICAgICAgICAgICBpZiAoIWNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkSGV4ID0gYXdhaXQgcmVzb2x2ZWRXYWxsZXQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9jaGFpbklkJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gZnJvbUhleChjaGFpbklkSGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNpd2VNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGRvbWFpbjogdXJsLmhvc3QsXG4gICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnQ6IHN0YXRlbWVudCxcbiAgICAgICAgICAgICAgICB1cmk6IHVybC5ocmVmLFxuICAgICAgICAgICAgICAgIHZlcnNpb246ICcxJyxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Mubm9uY2UsXG4gICAgICAgICAgICAgICAgaXNzdWVkQXQ6IChfZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5pc3N1ZWRBdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBleHBpcmF0aW9uVGltZTogKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmV4cGlyYXRpb25UaW1lLFxuICAgICAgICAgICAgICAgIG5vdEJlZm9yZTogKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLm5vdEJlZm9yZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmVzb3VyY2VzOiAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2oucmVzb3VyY2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBjcmVhdGVTaXdlTWVzc2FnZShzaXdlTWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBTaWduIG1lc3NhZ2VcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IChhd2FpdCByZXNvbHZlZFdhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFt0b0hleChtZXNzYWdlKSwgYWRkcmVzc10sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnZXRoZXJldW0nLCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgfSwgKCgoX2sgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfayA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2suY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9sID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhTb2xhbmEoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gY3JlZGVudGlhbHMubWVzc2FnZTtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGNyZWRlbnRpYWxzLnNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW4sIHdhbGxldCwgc3RhdGVtZW50LCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFdhbGxldDtcbiAgICAgICAgICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCAhPT0gJ29iamVjdCcgfHwgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93QW55ID0gd2luZG93O1xuICAgICAgICAgICAgICAgIGlmICgnc29sYW5hJyBpbiB3aW5kb3dBbnkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICgoJ3NpZ25JbicgaW4gd2luZG93QW55LnNvbGFuYSAmJiB0eXBlb2Ygd2luZG93QW55LnNvbGFuYS5zaWduSW4gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoJ3NpZ25NZXNzYWdlJyBpbiB3aW5kb3dBbnkuc29sYW5hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbk1lc3NhZ2UgPT09ICdmdW5jdGlvbicpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdpbmRvd0FueS5zb2xhbmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBObyBjb21wYXRpYmxlIFNvbGFuYSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuc29sYW5hKSBkZXRlY3RlZC4gTWFrZSBzdXJlIHRoZSB1c2VyIGFscmVhZHkgaGFzIGEgd2FsbGV0IGluc3RhbGxlZCBhbmQgY29ubmVjdGVkIGZvciB0aGlzIGFwcC4gUHJlZmVyIHBhc3NpbmcgdGhlIHdhbGxldCBpbnRlcmZhY2Ugb2JqZWN0IGRpcmVjdGx5IHRvIHNpZ25JbldpdGhXZWIzKHsgY2hhaW46ICdzb2xhbmEnLCB3YWxsZXQ6IHJlc29sdmVkVXNlcldhbGxldCB9KSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgaWYgKCdzaWduSW4nIGluIHJlc29sdmVkV2FsbGV0ICYmIHJlc29sdmVkV2FsbGV0LnNpZ25Jbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc29sdmVkV2FsbGV0LnNpZ25JbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGlzc3VlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpLCB7IFxuICAgICAgICAgICAgICAgICAgICAvLyBub24tb3ZlcnJpZGFibGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMScsIGRvbWFpbjogdXJsLmhvc3QsIHVyaTogdXJsLmhyZWYgfSksIChzdGF0ZW1lbnQgPyB7IHN0YXRlbWVudCB9IDogbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0VG9Qcm9jZXNzO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkgJiYgb3V0cHV0WzBdICYmIHR5cGVvZiBvdXRwdXRbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduZWRNZXNzYWdlJyBpbiBvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZScgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2Qgc2lnbkluKCkgcmV0dXJuZWQgdW5yZWNvZ25pemVkIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnc2lnbmVkTWVzc2FnZScgaW4gb3V0cHV0VG9Qcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUob3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBzaWduSW4oKSBBUEkgcmV0dXJuZWQgb2JqZWN0IHdpdGhvdXQgc2lnbmVkTWVzc2FnZSBhbmQgc2lnbmF0dXJlIGZpZWxkcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKCdzaWduTWVzc2FnZScgaW4gcmVzb2x2ZWRXYWxsZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAhKCdwdWJsaWNLZXknIGluIHJlc29sdmVkV2FsbGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICFyZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgISgndG9CYXNlNTgnIGluIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgZG9lcyBub3QgaGF2ZSBhIGNvbXBhdGlibGUgc2lnbk1lc3NhZ2UoKSBhbmQgcHVibGljS2V5LnRvQmFzZTU4KCkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGAke3VybC5ob3N0fSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6YCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLihzdGF0ZW1lbnQgPyBbJycsIHN0YXRlbWVudCwgJyddIDogWycnXSksXG4gICAgICAgICAgICAgICAgICAgICdWZXJzaW9uOiAxJyxcbiAgICAgICAgICAgICAgICAgICAgYFVSSTogJHt1cmwuaHJlZn1gLFxuICAgICAgICAgICAgICAgICAgICBgSXNzdWVkIEF0OiAkeyhfYyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNzdWVkQXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qubm90QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYE5vdCBCZWZvcmU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vdEJlZm9yZX1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5leHBpcmF0aW9uVGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW2BFeHBpcmF0aW9uIFRpbWU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmV4cGlyYXRpb25UaW1lfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgQ2hhaW4gSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmNoYWluSWR9YF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubm9uY2UpID8gW2BOb25jZTogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEubm9uY2V9YF0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgUmVxdWVzdCBJRDogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVxdWVzdElkfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2sgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnJlc291cmNlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5yZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4gYC0gJHtyZXNvdXJjZX1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTaWduYXR1cmUgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSksICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXliZVNpZ25hdHVyZSB8fCAhKG1heWJlU2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IHNpZ25NZXNzYWdlKCkgQVBJIHJldHVybmVkIGFuIHJlY29nbml6ZWQgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gbWF5YmVTaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnc29sYW5hJywgbWVzc2FnZSwgc2lnbmF0dXJlOiBieXRlc1RvQmFzZTY0VVJMKHNpZ25hdHVyZSkgfSwgKCgoX2wgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9tID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludmFsaWRUb2tlbkVycm9yID0gbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9leGNoYW5nZUNvZGVGb3JTZXNzaW9uKGF1dGhDb2RlKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VJdGVtID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgIGNvbnN0IFtjb2RlVmVyaWZpZXIsIHJlZGlyZWN0VHlwZV0gPSAoc3RvcmFnZUl0ZW0gIT09IG51bGwgJiYgc3RvcmFnZUl0ZW0gIT09IHZvaWQgMCA/IHN0b3JhZ2VJdGVtIDogJycpLnNwbGl0KCcvJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWNvZGVWZXJpZmllciAmJiB0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGtjZWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhdXRoX2NvZGU6IGF1dGhDb2RlLFxuICAgICAgICAgICAgICAgICAgICBjb2RlX3ZlcmlmaWVyOiBjb2RlVmVyaWZpZXIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogaW52YWxpZFRva2VuRXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gdm9pZCAwID8gcmVkaXJlY3RUeXBlIDogbnVsbCB9KSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsLCByZWRpcmVjdFR5cGU6IG51bGwgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3Mgc2lnbmluZyBpbiB3aXRoIGFuIE9JREMgSUQgdG9rZW4uIFRoZSBhdXRoZW50aWNhdGlvbiBwcm92aWRlciB1c2VkXG4gICAgICogc2hvdWxkIGJlIGVuYWJsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aElkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcHJvdmlkZXIsIHRva2VuLCBhY2Nlc3NfdG9rZW4sIG5vbmNlIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9aWRfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgIGlkX3Rva2VuOiB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnZhbGlkVG9rZW5FcnJvciA9IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGludmFsaWRUb2tlbkVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgcGhvbmUgc2lnbi1pbnMsIG9ubHkgYW4gT1RQIHdpbGwgYmUgc2VudC4gWW91IHdvbid0IGJlIGFibGUgdG8gc2VuZCBhIG1hZ2ljbGluayBmb3IgcGhvbmUgc2lnbi1pbnMuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IsIHRoYXQgdGhlIGFjY291bnRcbiAgICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgICAqXG4gICAgICogRG8gbm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY29uZmlndXJlIGEgV2hhdHNhcHAgc2VuZGVyIG9uIFR3aWxpb1xuICAgICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgKiBhdCB0aGlzIHRpbWUuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT3RwKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsOiAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJ3NtcycsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgaW4gYSB1c2VyIGdpdmVuIGEgVXNlciBzdXBwbGllZCBPVFAgb3IgVG9rZW5IYXNoIHJlY2VpdmVkIHRocm91Z2ggbW9iaWxlIG9yIGVtYWlsLlxuICAgICAqL1xuICAgIGFzeW5jIHZlcmlmeU90cChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZWRpcmVjdFRvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IGNhcHRjaGFUb2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICgnb3B0aW9ucycgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbyA9IChfYSA9IHBhcmFtcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVkaXJlY3RUbztcbiAgICAgICAgICAgICAgICBjYXB0Y2hhVG9rZW4gPSAoX2IgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhcHRjaGFUb2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IGNhcHRjaGFUb2tlbiB9IH0pLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5WZXJpZmljYXRpb25FcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpO1xuICAgICAgICAgICAgICAgIHRocm93IHRva2VuVmVyaWZpY2F0aW9uRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gZGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgY29uc3QgdXNlciA9IGRhdGEudXNlcjtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMocGFyYW1zLnR5cGUgPT0gJ3JlY292ZXJ5JyA/ICdQQVNTV09SRF9SRUNPVkVSWScgOiAnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc3NvYCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKCdwcm92aWRlcklkJyBpbiBwYXJhbXMgPyB7IHByb3ZpZGVyX2lkOiBwYXJhbXMucHJvdmlkZXJJZCB9IDogbnVsbCkpLCAoJ2RvbWFpbicgaW4gcGFyYW1zID8geyBkb21haW46IHBhcmFtcy5kb21haW4gfSA6IG51bGwpKSwgeyByZWRpcmVjdF90bzogKF9iID0gKF9hID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQgfSksICgoKF9jID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBwYXJhbXMub3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHNraXBfaHR0cF9yZWRpcmVjdDogdHJ1ZSwgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCB9KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zc29SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWRpcmVjdCBpbiBicm93c2VyIHVubGVzcyBza2lwQnJvd3NlclJlZGlyZWN0IGlzIHRydWVcbiAgICAgICAgICAgIGlmICgoKF9kID0gcmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC51cmwpICYmIGlzQnJvd3NlcigpICYmICEoKF9lID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzdWx0LmRhdGEudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlYXV0aGVudGljYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZW5kcyBhbiBleGlzdGluZyBzaWdudXAgY29uZmlybWF0aW9uIGVtYWlsLCBlbWFpbCBjaGFuZ2UgZW1haWwsIFNNUyBPVFAgb3IgcGhvbmUgY2hhbmdlIE9UUC5cbiAgICAgKi9cbiAgICBhc3luYyByZXNlbmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gYCR7dGhpcy51cmx9L3Jlc2VuZGA7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHR5cGUsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgZW5kcG9pbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIG1lc3NhZ2VJZDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2VfaWQgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yKCdZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBlbWFpbCBvciBwaG9uZSBudW1iZXIgYW5kIGEgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uLCByZWZyZXNoaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXNzaW9uIHJldHVybmVkIGNhbiBiZSBudWxsIGlmIHRoZSBzZXNzaW9uIGlzIG5vdCBkZXRlY3RlZCB3aGljaCBjYW4gaGFwcGVuIGluIHRoZSBldmVudCBhIHVzZXIgaXMgbm90IHNpZ25lZC1pbiBvciBoYXMgbG9nZ2VkIG91dC5cbiAgICAgKlxuICAgICAqICoqSU1QT1JUQU5UOioqIFRoaXMgbWV0aG9kIGxvYWRzIHZhbHVlcyBkaXJlY3RseSBmcm9tIHRoZSBzdG9yYWdlIGF0dGFjaGVkXG4gICAgICogdG8gdGhlIGNsaWVudC4gSWYgdGhhdCBzdG9yYWdlIGlzIGJhc2VkIG9uIHJlcXVlc3QgY29va2llcyBmb3IgZXhhbXBsZSxcbiAgICAgKiB0aGUgdmFsdWVzIGluIGl0IG1heSBub3QgYmUgYXV0aGVudGljIGFuZCB0aGVyZWZvcmUgaXQncyBzdHJvbmdseSBhZHZpc2VkXG4gICAgICogYWdhaW5zdCB1c2luZyB0aGlzIG1ldGhvZCBhbmQgaXRzIHJlc3VsdHMgaW4gc3VjaCBjaXJjdW1zdGFuY2VzLiBBIHdhcm5pbmdcbiAgICAgKiB3aWxsIGJlIGVtaXR0ZWQgaWYgdGhpcyBpcyBkZXRlY3RlZC4gVXNlIHtAbGluayAjZ2V0VXNlcigpfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFNlc3Npb24oKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNxdWlyZXMgYSBnbG9iYWwgbG9jayBiYXNlZCBvbiB0aGUgc3RvcmFnZSBrZXkuXG4gICAgICovXG4gICAgYXN5bmMgX2FjcXVpcmVMb2NrKGFjcXVpcmVUaW1lb3V0LCBmbikge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdiZWdpbicsIGFjcXVpcmVUaW1lb3V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5wZW5kaW5nSW5Mb2NrW3RoaXMucGVuZGluZ0luTG9jay5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgICA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGxhc3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMubG9jayhgbG9jazoke3RoaXMuc3RvcmFnZUtleX1gLCBhY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgYWNxdWlyZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5wdXNoKChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UganVzdCBjYXJlIGlmIGl0IGZpbmlzaGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgZHJhaW5pbmcgdGhlIHF1ZXVlIHVudGlsIHRoZXJlJ3Mgbm90aGluZyB0byB3YWl0IG9uXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLnBlbmRpbmdJbkxvY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0T24gPSBbLi4udGhpcy5wZW5kaW5nSW5Mb2NrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHdhaXRPbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2suc3BsaWNlKDAsIHdhaXRPbi5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdsb2NrIHJlbGVhc2VkIGZvciBzdG9yYWdlIGtleScsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hY3F1aXJlTG9jaycsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW5zdGVhZCBvZiB7QGxpbmsgI2dldFNlc3Npb259IGluc2lkZSB0aGUgbGlicmFyeS4gSXQgaXNcbiAgICAgKiBzZW1hbnRpY2FsbHkgdXN1YWxseSB3aGF0IHlvdSB3YW50LCBhcyBnZXR0aW5nIGEgc2Vzc2lvbiBpbnZvbHZlcyBzb21lXG4gICAgICogcHJvY2Vzc2luZyBhZnRlcndhcmRzIHRoYXQgcmVxdWlyZXMgb25seSBvbmUgY2xpZW50IG9wZXJhdGluZyBvbiB0aGVcbiAgICAgKiBzZXNzaW9uIGF0IG9uY2UgYWNyb3NzIG11bHRpcGxlIHRhYnMgb3IgcHJvY2Vzc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIF91c2VTZXNzaW9uKGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnYmVnaW4nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSB1c2Ugb2YgX19sb2FkU2Vzc2lvbiBoZXJlIGlzIHRoZSBvbmx5IGNvcnJlY3QgdXNlIG9mIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX19sb2FkU2Vzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI191c2VTZXNzaW9uJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5FVkVSIFVTRSBESVJFQ1RMWSFcbiAgICAgKlxuICAgICAqIEFsd2F5cyB1c2Uge0BsaW5rICNfdXNlU2Vzc2lvbn0uXG4gICAgICovXG4gICAgYXN5bmMgX19sb2FkU2Vzc2lvbigpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnYmVnaW4nKTtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2tBY3F1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAndXNlZCBvdXRzaWRlIG9mIGFuIGFjcXVpcmVkIGxvY2shJywgbmV3IEVycm9yKCkuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbWF5YmVTZXNzaW9uID0gYXdhaXQgZ2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgbWF5YmVTZXNzaW9uKTtcbiAgICAgICAgICAgIGlmIChtYXliZVNlc3Npb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IG1heWJlU2Vzc2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjZ2V0U2Vzc2lvbigpJywgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzZXNzaW9uIGlzIGNvbnNpZGVyZWQgZXhwaXJlZCBiZWZvcmUgdGhlIGFjY2VzcyB0b2tlbiBfYWN0dWFsbHlfXG4gICAgICAgICAgICAvLyBleHBpcmVzLiBXaGVuIHRoZSBhdXRvUmVmcmVzaFRva2VuIG9wdGlvbiBpcyBvZmYgKG9yIHdoZW4gdGhlIHRhYiBpc1xuICAgICAgICAgICAgLy8gaW4gdGhlIGJhY2tncm91bmQpLCB2ZXJ5IGVhZ2VyIHVzZXJzIG9mIGdldFNlc3Npb24oKSAtLSBsaWtlXG4gICAgICAgICAgICAvLyByZWFsdGltZS1qcyAtLSBtaWdodCBzZW5kIGEgdmFsaWQgSldUIHdoaWNoIHdpbGwgZXhwaXJlIGJ5IHRoZSB0aW1lIGl0XG4gICAgICAgICAgICAvLyByZWFjaGVzIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICBjb25zdCBoYXNFeHBpcmVkID0gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdFxuICAgICAgICAgICAgICAgID8gY3VycmVudFNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NU1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsIGBzZXNzaW9uIGhhcyR7aGFzRXhwaXJlZCA/ICcnIDogJyBub3QnfSBleHBpcmVkYCwgJ2V4cGlyZXNfYXQnLCBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0KTtcbiAgICAgICAgICAgIGlmICghaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF5YmVVc2VyID09PSBudWxsIHx8IG1heWJlVXNlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVVc2VyLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBtYXliZVVzZXIudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXcmFwIHRoZSB1c2VyIG9iamVjdCB3aXRoIGEgd2FybmluZyBwcm94eSBvbiB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXJucyB3aGVuIHByb3BlcnRpZXMgb2YgdGhlIHVzZXIgYXJlIGFjY2Vzc2VkLCBub3Qgd2hlbiBzZXNzaW9uLnVzZXIgaXRzZWxmIGlzIGFjY2Vzc2VkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc1NlcnZlciAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyICYmXG4gICAgICAgICAgICAgICAgICAgICFjdXJyZW50U2Vzc2lvbi51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VwcHJlc3NXYXJuaW5nUmVmID0geyB2YWx1ZTogdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSBpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkoY3VycmVudFNlc3Npb24udXNlciwgc3VwcHJlc3NXYXJuaW5nUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjbGllbnQtbGV2ZWwgc3VwcHJlc3Npb24gZmxhZyB3aGVuIHRoZSBwcm94eSBzdXBwcmVzc2VzIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXBwcmVzc1dhcm5pbmdSZWYudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBjdXJyZW50U2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfX2xvYWRTZXNzaW9uKCknLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB1c2VyIGRldGFpbHMgaWYgdGhlcmUgaXMgYW4gZXhpc3Rpbmcgc2Vzc2lvbi4gVGhpcyBtZXRob2RcbiAgICAgKiBwZXJmb3JtcyBhIG5ldHdvcmsgcmVxdWVzdCB0byB0aGUgU3VwYWJhc2UgQXV0aCBzZXJ2ZXIsIHNvIHRoZSByZXR1cm5lZFxuICAgICAqIHZhbHVlIGlzIGF1dGhlbnRpYyBhbmQgY2FuIGJlIHVzZWQgdG8gYmFzZSBhdXRob3JpemF0aW9uIHJ1bGVzIG9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGp3dCBUYWtlcyBpbiBhbiBvcHRpb25hbCBhY2Nlc3MgdG9rZW4gSldULiBJZiBubyBKV1QgaXMgcHJvdmlkZWQsIHRoZSBKV1QgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uIGlzIHVzZWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoand0KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2dldFVzZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQuZGF0YS51c2VyKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRVc2VyKGp3dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBqd3QsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybnMgYW4gZXJyb3IgaWYgdGhlcmUgaXMgbm8gYWNjZXNzX3Rva2VuIG9yIGN1c3RvbSBhdXRob3JpemF0aW9uIGhlYWRlclxuICAgICAgICAgICAgICAgIGlmICghKChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgJiYgIXRoaXMuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2MgPSAoX2IgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSldUIGNvbnRhaW5zIGEgYHNlc3Npb25faWRgIHdoaWNoIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYW4gYWN0aXZlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gaW4gdGhlIGRhdGFiYXNlLCBpbmRpY2F0aW5nIHRoZSB1c2VyIGlzIHNpZ25lZCBvdXQuXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHVzZXIgZGF0YSBmb3IgYSBsb2dnZWQgaW4gdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyB1cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91cGRhdGVVc2VyKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb25EYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBzZXNzaW9uRGF0YS5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJyAmJiBhdHRyaWJ1dGVzLmVtYWlsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogdXNlckVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUFVUJywgYCR7dGhpcy51cmx9L3VzZXJgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgeyBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIgfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzZXNzaW9uIGRhdGEgZnJvbSB0aGUgY3VycmVudCBzZXNzaW9uLiBJZiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGV4cGlyZWQsIHNldFNlc3Npb24gd2lsbCB0YWtlIGNhcmUgb2YgcmVmcmVzaGluZyBpdCB0byBvYnRhaW4gYSBuZXcgc2Vzc2lvbi5cbiAgICAgKiBJZiB0aGUgcmVmcmVzaCB0b2tlbiBvciBhY2Nlc3MgdG9rZW4gaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbiB0aGF0IG1pbmltYWxseSBjb250YWlucyBhbiBhY2Nlc3MgdG9rZW4gYW5kIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgc2V0U2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2sodGhpcy5sb2NrQWNxdWlyZVRpbWVvdXQsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbiB8fCAhY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZU5vdyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3c7XG4gICAgICAgICAgICBsZXQgaGFzRXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGRlY29kZUpXVChjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZXhwKSB7XG4gICAgICAgICAgICAgICAgZXhwaXJlc0F0ID0gcGF5bG9hZC5leHA7XG4gICAgICAgICAgICAgICAgaGFzRXhwaXJlZCA9IGV4cGlyZXNBdCA8PSB0aW1lTm93O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0V4cGlyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlZnJlc2hlZFNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyB1c2VyOiBzZXNzaW9uLnVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgc2Vzc2lvbiwgcmVnYXJkbGVzcyBvZiBleHBpcnkgc3RhdHVzLlxuICAgICAqIFRha2VzIGluIGFuIG9wdGlvbmFsIGN1cnJlbnQgc2Vzc2lvbi4gSWYgbm90IHBhc3NlZCBpbiwgdGhlbiByZWZyZXNoU2Vzc2lvbigpIHdpbGwgYXR0ZW1wdCB0byByZXRyaWV2ZSBpdCBmcm9tIGdldFNlc3Npb24oKS5cbiAgICAgKiBJZiB0aGUgY3VycmVudCBzZXNzaW9uJ3MgcmVmcmVzaCB0b2tlbiBpcyBpbnZhbGlkLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAgICAgKiBAcGFyYW0gY3VycmVudFNlc3Npb24gVGhlIGN1cnJlbnQgc2Vzc2lvbi4gSWYgcGFzc2VkIGluLCBpdCBtdXN0IGNvbnRhaW4gYSByZWZyZXNoIHRva2VuLlxuICAgICAqL1xuICAgIGFzeW5jIHJlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9yZWZyZXNoU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjdXJyZW50U2Vzc2lvbiA9PT0gbnVsbCB8fCBjdXJyZW50U2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIF9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBpbiB0aGUgVVJMLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IGZsb3cgaXQgaXMsIHdlIGp1c3QgcmV0dXJuIHRoZSBlcnJvci5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZXJyb3IgfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHBhcmFtcy5lcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGNsYXNzIHJldHVybmVkIGltcGxpZXMgdGhhdCB0aGUgcmVkaXJlY3QgaXMgZnJvbSBhbiBpbXBsaWNpdCBncmFudCBmbG93XG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IGNvdWxkIGFsc28gYmUgZnJvbSBhIHJlZGlyZWN0IGVycm9yIGZyb20gYSBQS0NFIGZsb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgJ0Vycm9yIGluIFVSTCB3aXRoIHVuc3BlY2lmaWVkIGVycm9yX2Rlc2NyaXB0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yIHx8ICd1bnNwZWNpZmllZF9lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgbWlzbWF0Y2hlcyBiZXR3ZWVuIHRoZSBmbG93VHlwZSBpbml0aWFsaXNlZCBpbiB0aGUgY2xpZW50IGFuZCB0aGUgVVJMIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHN3aXRjaCAoY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdOb3QgYSB2YWxpZCBQS0NFIGZsb3cgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BrY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG1pc21hdGNoIHNvIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcmVkaXJlY3QgZm9yIFBLQ0UsIHdlIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGNvZGUgZnJvbSB0aGUgVVJMIGZvciB0aGUgY29kZSBleGNoYW5nZVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrVXJsVHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2JlZ2luJywgJ2lzIFBLQ0UgZmxvdycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vIGNvZGUgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihwYXJhbXMuY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnY29kZScpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyX3Rva2VuLCBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIGV4cGlyZXNfaW4sIGV4cGlyZXNfYXQsIHRva2VuX3R5cGUsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc190b2tlbiB8fCAhZXhwaXJlc19pbiB8fCAhcmVmcmVzaF90b2tlbiB8fCAhdG9rZW5fdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHNlc3Npb24gZGVmaW5lZCBpbiBVUkwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHBhcnNlSW50KGV4cGlyZXNfaW4pO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3cgKyBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAoZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBhcnNlSW50KGV4cGlyZXNfYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWN0dWFsbHlFeHBpcmVzSW4gPSBleHBpcmVzQXQgLSB0aW1lTm93O1xuICAgICAgICAgICAgaWYgKGFjdHVhbGx5RXhwaXJlc0luICogMTAwMCA8PSBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgZXhwaXJlcyBpbiAke2FjdHVhbGx5RXhwaXJlc0lufXMsIHNob3VsZCBoYXZlIGJlZW4gY2xvc2VyIHRvICR7ZXhwaXJlc0lufXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzc3VlZEF0ID0gZXhwaXJlc0F0IC0gZXhwaXJlc0luO1xuICAgICAgICAgICAgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA+PSAxMjApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgb3ZlciAxMjBzIGFnbywgVVJMIGNvdWxkIGJlIHN0YWxlJywgaXNzdWVkQXQsIGV4cGlyZXNBdCwgdGltZU5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIGluIHRoZSBmdXR1cmU/IENoZWNrIHRoZSBkZXZpY2UgY2xvY2sgZm9yIHNrZXcnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0luLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6IHRva2VuX3R5cGUsXG4gICAgICAgICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0b2tlbnMgZnJvbSBVUkxcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uLCByZWRpcmVjdFR5cGU6IHBhcmFtcy50eXBlIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgY29udGFpbnMgcGFyYW1ldGVycyBnaXZlbiBieSBhbiBpbXBsaWNpdCBvYXV0aCBncmFudCBmbG93IChodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNjc0OS5odG1sI3NlY3Rpb24tNC4yKVxuICAgICAqXG4gICAgICogSWYgYGRldGVjdFNlc3Npb25JblVybGAgaXMgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgVVJMIGFuZCBwYXJhbXMgdG8gZGV0ZXJtaW5lXG4gICAgICogaWYgdGhlIFVSTCBzaG91bGQgYmUgcHJvY2Vzc2VkIGFzIGEgU3VwYWJhc2UgYXV0aCBjYWxsYmFjay4gVGhpcyBhbGxvd3MgdXNlcnMgdG8gZXhjbHVkZVxuICAgICAqIFVSTHMgZnJvbSBvdGhlciBPQXV0aCBwcm92aWRlcnMgKGUuZy4sIEZhY2Vib29rIExvZ2luKSB0aGF0IGFsc28gcmV0dXJuIGFjY2Vzc190b2tlbiBpbiB0aGUgZnJhZ21lbnQuXG4gICAgICovXG4gICAgX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwobmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZiksIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ocGFyYW1zLmFjY2Vzc190b2tlbiB8fCBwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgVVJMIGFuZCBiYWNraW5nIHN0b3JhZ2UgY29udGFpbiBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGEgUEtDRSBmbG93XG4gICAgICovXG4gICAgYXN5bmMgX2lzUEtDRUNhbGxiYWNrKHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdXJyZW50U3RvcmFnZUNvbnRlbnQgPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgcmV0dXJuICEhKHBhcmFtcy5jb2RlICYmIGN1cnJlbnRTdG9yYWdlQ29udGVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2lkZSBhIGJyb3dzZXIgY29udGV4dCwgYHNpZ25PdXQoKWAgd2lsbCByZW1vdmUgdGhlIGxvZ2dlZCBpbiB1c2VyIGZyb20gdGhlIGJyb3dzZXIgc2Vzc2lvbiBhbmQgbG9nIHRoZW0gb3V0IC0gcmVtb3ZpbmcgYWxsIGl0ZW1zIGZyb20gbG9jYWxzdG9yYWdlIGFuZCB0aGVuIHRyaWdnZXIgYSBgXCJTSUdORURfT1VUXCJgIGV2ZW50LlxuICAgICAqXG4gICAgICogRm9yIHNlcnZlci1zaWRlIG1hbmFnZW1lbnQsIHlvdSBjYW4gcmV2b2tlIGFsbCByZWZyZXNoIHRva2VucyBmb3IgYSB1c2VyIGJ5IHBhc3NpbmcgYSB1c2VyJ3MgSldUIHRocm91Z2ggdG8gYGF1dGguYXBpLnNpZ25PdXQoSldUOiBzdHJpbmcpYC5cbiAgICAgKiBUaGVyZSBpcyBubyB3YXkgdG8gcmV2b2tlIGEgdXNlcidzIGFjY2VzcyB0b2tlbiBqd3QgdW50aWwgaXQgZXhwaXJlcy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gc2V0IGEgc2hvcnRlciBleHBpcnkgb24gdGhlIGp3dCBmb3IgdGhpcyByZWFzb24uXG4gICAgICpcbiAgICAgKiBJZiB1c2luZyBgb3RoZXJzYCBzY29wZSwgbm8gYFNJR05FRF9PVVRgIGV2ZW50IGlzIGZpcmVkIVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25PdXQob3B0aW9ucyA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fc2lnbk91dChvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9zaWduT3V0KHsgc2NvcGUgfSA9IHsgc2NvcGU6ICdnbG9iYWwnIH0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuYWRtaW4uc2lnbk91dChhY2Nlc3NUb2tlbiwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSA0MDFzIHNpbmNlIGFuIGludmFsaWQgb3IgZXhwaXJlZCBKV1Qgc2hvdWxkIHNpZ24gb3V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNBdXRoQXBpRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjb3BlICE9PSAnb3RoZXJzJykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBlcnJvcjogbnVsbCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uQXV0aFN0YXRlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGlkID0gZ2VuZXJhdGVDYWxsYmFja0lkKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9O1xuICAgIH1cbiAgICBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHRoZSBpZGVudGl0aWVzIGxpbmtlZCB0byBhIHVzZXIuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VXNlcklkZW50aXRpZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgaWRlbnRpdGllczogKF9hID0gZGF0YS51c2VyLmlkZW50aXRpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdIH0sIGVycm9yOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpbmtJZGVudGl0eShjcmVkZW50aWFscykge1xuICAgICAgICBpZiAoJ3Rva2VuJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlua0lkZW50aXR5SWRUb2tlbihjcmVkZW50aWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGlua0lkZW50aXR5T0F1dGgoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHlPQXV0aChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuX2dldFVybEZvclByb3ZpZGVyKGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvYXV0aG9yaXplYCwgY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogKF9hID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgIHNjb3BlczogKF9iID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNjb3BlcyxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEJyb3dzZXJSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIHVybCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9lID0gKF9kID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhKChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7IHByb3ZpZGVyOiBjcmVkZW50aWFscy5wcm92aWRlciwgdXJsOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudXJsIH0sXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yOiBzZXNzaW9uRXJyb3IsIGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaWRlbnRpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdVU0VSX1VQREFURUQnLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YSwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5saW5rcyBhbiBpZGVudGl0eSBmcm9tIGEgdXNlciBieSBkZWxldGluZyBpdC4gVGhlIHVzZXIgd2lsbCBubyBsb25nZXIgYmUgYWJsZSB0byBzaWduIGluIHdpdGggdGhhdCBpZGVudGl0eSBvbmNlIGl0J3MgdW5saW5rZWQuXG4gICAgICovXG4gICAgYXN5bmMgdW5saW5rSWRlbnRpdHkoaWRlbnRpdHkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L3VzZXIvaWRlbnRpdGllcy8ke2lkZW50aXR5LmlkZW50aXR5X2lkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGEgbmV3IEpXVC5cbiAgICAgKiBAcGFyYW0gcmVmcmVzaFRva2VuIEEgdmFsaWQgcmVmcmVzaCB0b2tlbiB0aGF0IHdhcyByZXR1cm5lZCBvbiBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBfcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19yZWZyZXNoQWNjZXNzVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIC8vIHdpbGwgYXR0ZW1wdCB0byByZWZyZXNoIHRoZSB0b2tlbiB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXRyeWFibGUoYXN5bmMgKGF0dGVtcHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpKTsgLy8gMjAwLCA0MDAsIDgwMCwgLi4uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3JlZnJlc2hpbmcgYXR0ZW1wdCcsIGF0dGVtcHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXJlZnJlc2hfdG9rZW5gLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCAoYXR0ZW1wdCwgZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0QmFja09mZkludGVydmFsID0gMjAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyByZXRyeWFibGUgb25seSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgc2VudCBiZWZvcmUgdGhlIGJhY2tvZmYgb3ZlcmZsb3dzIHRoZSB0aWNrIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIERhdGUubm93KCkgKyBuZXh0QmFja09mZkludGVydmFsIC0gc3RhcnRlZEF0IDwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogeyBzZXNzaW9uOiBudWxsLCB1c2VyOiBudWxsIH0sIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRTZXNzaW9uID0gdHlwZW9mIG1heWJlU2Vzc2lvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG1heWJlU2Vzc2lvbiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgJ2FjY2Vzc190b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAgICAgICAnZXhwaXJlc19hdCcgaW4gbWF5YmVTZXNzaW9uO1xuICAgICAgICByZXR1cm4gaXNWYWxpZFNlc3Npb247XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVQcm92aWRlclNpZ25Jbihwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vYXV0aG9yaXplYCwgcHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVByb3ZpZGVyU2lnbkluKCknLCAncHJvdmlkZXInLCBwcm92aWRlciwgJ29wdGlvbnMnLCBvcHRpb25zLCAndXJsJywgdXJsKTtcbiAgICAgICAgLy8gdHJ5IHRvIG9wZW4gb24gdGhlIGJyb3dzZXJcbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyLCB1cmwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3ZlcnMgdGhlIHNlc3Npb24gZnJvbSBMb2NhbFN0b3JhZ2UgYW5kIHJlZnJlc2hlcyB0aGUgdG9rZW5cbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBhc3luYyB0byBhY2NvbW1vZGF0ZSBmb3IgQXN5bmNTdG9yYWdlIGUuZy4gaW4gUmVhY3QgbmF0aXZlLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWNvdmVyQW5kUmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSc7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAmJiB0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdG9yYWdlLmlzU2VydmVyICYmIE9iamVjdC5pcyh0aGlzLnN0b3JhZ2UsIHRoaXMudXNlclN0b3JhZ2UpICYmICFtYXliZVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmFnZSBhbmQgdXNlclN0b3JhZ2UgYXJlIHRoZSBzYW1lIHN0b3JhZ2UgbWVkaXVtLCBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cubG9jYWxTdG9yYWdlIGlmIHVzZXJTdG9yYWdlIGRvZXMgbm90IGhhdmUgdGhlIHVzZXIgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHN0b3JlZCwgc3RvcmUgaXQgZmlyc3QgdGhlcmVieSBtaWdyYXRpbmcgdGhlIHVzZXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZyb20gc3RvcmFnZSAtPiB1c2VyU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICBtYXliZVVzZXIgPSB7IHVzZXI6IGN1cnJlbnRTZXNzaW9uLnVzZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIG1heWJlVXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSAoX2EgPSBtYXliZVVzZXIgPT09IG51bGwgfHwgbWF5YmVVc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZVVzZXIudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdXNlck5vdEF2YWlsYWJsZVByb3h5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50U2Vzc2lvbiAmJiAhY3VycmVudFNlc3Npb24udXNlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZXIgc3RvcmFnZSBpcyBub3Qgc2V0LCBsZXQncyBjaGVjayBpZiBpdCB3YXMgcHJldmlvdXNseSBlbmFibGVkIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgYnJpbmcgYmFjayB0aGUgc3RvcmFnZSBhcyBpdCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB1c2VyU3RvcmFnZSB3YXMgcHJldmlvdXNseSBlbmFibGVkIGFuZCB0aGUgc3RvcmFnZSBtZWRpdW0gd2FzIHRoZSBzYW1lLCB0byBtb3ZlIHRoZSB1c2VyIGJhY2sgdW5kZXIgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0ZVVzZXIgJiYgKHNlcGFyYXRlVXNlciA9PT0gbnVsbCB8fCBzZXBhcmF0ZVVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcGFyYXRlVXNlci51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IHNlcGFyYXRlVXNlci51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNXaXRoTWFyZ2luID0gKChfYiA9IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEluZmluaXR5KSAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NUztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTl9NU31zYCk7XG4gICAgICAgICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFNlc3Npb24udXNlciAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcm94eSB1c2VyLCB0cnkgdG8gZ2V0IHRoZSByZWFsIHVzZXIgZGF0YVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJFcnJvciAmJiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVzZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2NvdWxkIG5vdCBnZXQgdXNlciBkYXRhLCBza2lwcGluZyBTSUdORURfSU4gbm90aWZpY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGdldFVzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgZGF0YTonLCBnZXRVc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvciBnZXR0aW5nIHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicsIGdldFVzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwZXJzaXN0IGN1cnJlbnRTZXNzaW9uIGFnYWluLCBhcyB3ZSBqdXN0IGxvYWRlZCBpdCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZnJlc2hpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IGRhdGEuc2Vzc2lvbiwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbiwgYnJvYWRjYXN0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAvLyBDcmVhdGUgYSBzaGFsbG93IGNvcHkgdG8gd29yayB3aXRoLCB0byBhdm9pZCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgc2Vzc2lvbiBvYmplY3QgaWYgaXQncyB1c2VkIGVsc2V3aGVyZVxuICAgICAgICBjb25zdCBzZXNzaW9uVG9Qcm9jZXNzID0gT2JqZWN0LmFzc2lnbih7fSwgc2Vzc2lvbik7XG4gICAgICAgIGNvbnN0IHVzZXJJc1Byb3h5ID0gc2Vzc2lvblRvUHJvY2Vzcy51c2VyICYmIHNlc3Npb25Ub1Byb2Nlc3MudXNlci5fX2lzVXNlck5vdEF2YWlsYWJsZVByb3h5ID09PSB0cnVlO1xuICAgICAgICBpZiAodGhpcy51c2VyU3RvcmFnZSkge1xuICAgICAgICAgICAgaWYgKCF1c2VySXNQcm94eSAmJiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgcmVhbCB1c2VyIG9iamVjdCwgc2F2ZSBpdCB0byB1c2VyU3RvcmFnZS5cbiAgICAgICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJywge1xuICAgICAgICAgICAgICAgICAgICB1c2VyOiBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1c2VySXNQcm94eSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdGhlIHByb3h5LCBpdCBtZWFucyB1c2VyIHdhcyBub3QgZm91bmQgaW4gdXNlclN0b3JhZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGVuc3VyZSBubyBzdGFsZSB1c2VyIGRhdGEgZm9yIHRoaXMga2V5IGV4aXN0cyBpbiB1c2VyU3RvcmFnZSBpZiB3ZSB3ZXJlIHRvIHNhdmUgbnVsbCxcbiAgICAgICAgICAgICAgICAvLyBvciBzaW1wbHkgbm90IHNhdmUgdGhlIHByb3h5LiBGb3Igbm93LCB3ZSBkb24ndCBzYXZlIHRoZSBwcm94eSBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYSBuZWVkIHRvIGNsZWFyIHVzZXJTdG9yYWdlIGlmIHVzZXIgYmVjb21lcyBwcm94eSwgdGhhdCBsb2dpYyB3b3VsZCBnbyBoZXJlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJlcGFyZSB0aGUgbWFpbiBzZXNzaW9uIGRhdGEgZm9yIHByaW1hcnkgc3RvcmFnZTogcmVtb3ZlIHRoZSB1c2VyIHByb3BlcnR5IGJlZm9yZSBjbG9uaW5nXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBvcmlnaW5hbCBzZXNzaW9uLnVzZXIgbWlnaHQgYmUgdGhlIHByb3h5XG4gICAgICAgICAgICBjb25zdCBtYWluU2Vzc2lvbkRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBzZXNzaW9uVG9Qcm9jZXNzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBtYWluU2Vzc2lvbkRhdGEudXNlcjsgLy8gUmVtb3ZlIHVzZXIgKHJlYWwgb3IgcHJveHkpIGJlZm9yZSBjbG9uaW5nIGZvciBtYWluIHN0b3JhZ2VcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZE1haW5TZXNzaW9uRGF0YSA9IGRlZXBDbG9uZShtYWluU2Vzc2lvbkRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCBjbG9uZWRNYWluU2Vzc2lvbkRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gdXNlclN0b3JhZ2UgaXMgY29uZmlndXJlZC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgc2Vzc2lvbi51c2VyIHNob3VsZCBpZGVhbGx5IG5vdCBiZSBhIHByb3h5LlxuICAgICAgICAgICAgLy8gSWYgaXQgd2VyZSwgc3RydWN0dXJlZENsb25lIHdvdWxkIGZhaWwuIFRoaXMgaW1wbGllcyBhbiBpc3N1ZSBlbHNld2hlcmUgaWYgdXNlciBpcyBhIHByb3h5IGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFNlc3Npb24gPSBkZWVwQ2xvbmUoc2Vzc2lvblRvUHJvY2Vzcyk7IC8vIHNlc3Npb25Ub1Byb2Nlc3Mgc3RpbGwgaGFzIGl0cyBvcmlnaW5hbCB1c2VyIHByb3BlcnR5XG4gICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGNsb25lZFNlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9yZW1vdmVTZXNzaW9uKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVTZXNzaW9uKCknKTtcbiAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctY29kZS12ZXJpZmllcicpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKTtcbiAgICAgICAgaWYgKHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX09VVCcsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFueSByZWdpc3RlcmVkIHZpc2liaWxpdHljaGFuZ2UgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RhcnRBdXRvUmVmcmVzaH1cbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIF9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrKCknKTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2s7XG4gICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgaXNCcm93c2VyKCkgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZW1vdmluZyB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrIGZhaWxlZCcsIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIHByaXZhdGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofS4gVXNlIHRoaXNcbiAgICAgKiB3aXRoaW4gdGhlIGxpYnJhcnkuXG4gICAgICovXG4gICAgYXN5bmMgX3N0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19zdGFydEF1dG9SZWZyZXNoKCknKTtcbiAgICAgICAgY29uc3QgdGlja2VyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5fYXV0b1JlZnJlc2hUb2tlblRpY2soKSwgQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gdGlja2VyO1xuICAgICAgICBpZiAodGlja2VyICYmIHR5cGVvZiB0aWNrZXIgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aWNrZXIudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHRpY2tlciBpcyBhIE5vZGVKUyBUaW1lb3V0IG9iamVjdCB0aGF0IGhhcyBhbiBgdW5yZWZgIG1ldGhvZFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgIC8vIFdoZW4gYXV0byByZWZyZXNoIGlzIHVzZWQgaW4gTm9kZUpTIChsaWtlIGZvciB0ZXN0aW5nKSB0aGVcbiAgICAgICAgICAgIC8vIGBzZXRJbnRlcnZhbGAgaXMgcHJldmVudGluZyB0aGUgcHJvY2VzcyBmcm9tIGJlaW5nIG1hcmtlZCBhc1xuICAgICAgICAgICAgLy8gZmluaXNoZWQgYW5kIHRlc3RzIHJ1biBlbmRsZXNzbHkuIFRoaXMgY2FuIGJlIHByZXZlbnRlZCBieSBjYWxsaW5nXG4gICAgICAgICAgICAvLyBgdW5yZWYoKWAgb24gdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICAgICAgICAgIHRpY2tlci51bnJlZigpO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEZW5vLnVucmVmVGltZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIHNpbWlsYXIgbGlrZSBmb3IgTm9kZUpTLCBidXQgd2l0aCB0aGUgRGVubyBBUElcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGVuby5sYW5kL2FwaUBsYXRlc3Q/dW5zdGFibGUmcz1EZW5vLnVucmVmVGltZXJcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICAgICAgRGVuby51bnJlZlRpbWVyKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcnVuIHRoZSB0aWNrIGltbWVkaWF0ZWx5LCBidXQgaW4gdGhlIG5leHQgcGFzcyBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0XG4gICAgICAgIC8vICNfaW5pdGlhbGl6ZSBjYW4gYmUgYWxsb3dlZCB0byBjb21wbGV0ZSB3aXRob3V0IHJlY3Vyc2l2ZWx5IHdhaXRpbmcgb25cbiAgICAgICAgLy8gaXRzZWxmXG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tUaW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aW1lb3V0LnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgRGVubyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERlbm8udW5yZWZUaW1lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyBoYXMgbm8gY29udGV4dCBvZiBEZW5vXG4gICAgICAgICAgICBEZW5vLnVucmVmVGltZXIodGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0b3BBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXI7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrVGltZW91dDtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYW4gYXV0by1yZWZyZXNoIHByb2Nlc3MgaW4gdGhlIGJhY2tncm91bmQuIFRoZSBzZXNzaW9uIGlzIGNoZWNrZWRcbiAgICAgKiBldmVyeSBmZXcgc2Vjb25kcy4gQ2xvc2UgdG8gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBhIHByb2Nlc3MgaXMgc3RhcnRlZCB0b1xuICAgICAqIHJlZnJlc2ggdGhlIHNlc3Npb24uIElmIHJlZnJlc2hpbmcgZmFpbHMgaXQgd2lsbCBiZSByZXRyaWVkIGZvciBhcyBsb25nIGFzXG4gICAgICogbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogSWYgeW91IHNldCB0aGUge0BsaW5rIEdvVHJ1ZUNsaWVudE9wdGlvbnMjYXV0b1JlZnJlc2hUb2tlbn0geW91IGRvbid0IG5lZWRcbiAgICAgKiB0byBjYWxsIHRoaXMgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIGZvciB5b3UuXG4gICAgICpcbiAgICAgKiBPbiBicm93c2VycyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzIG9ubHkgd2hlbiB0aGUgdGFiL3dpbmRvdyBpcyBpbiB0aGVcbiAgICAgKiBmb3JlZ3JvdW5kIHRvIGNvbnNlcnZlIHJlc291cmNlcyBhcyB3ZWxsIGFzIHByZXZlbnQgcmFjZSBjb25kaXRpb25zIGFuZFxuICAgICAqIGZsb29kaW5nIGF1dGggd2l0aCByZXF1ZXN0cy4gSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWRcbiAgICAgKiB2aXNpYmlsaXR5IGNoYW5nZSBjYWxsYmFjayB3aWxsIGJlIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5XG4gICAgICogY2hhbmdlcyBvbiB5b3VyIG93bi5cbiAgICAgKlxuICAgICAqIE9uIG5vbi1icm93c2VyIHBsYXRmb3JtcyB0aGUgcmVmcmVzaCBwcm9jZXNzIHdvcmtzICpjb250aW51b3VzbHkqIGluIHRoZVxuICAgICAqIGJhY2tncm91bmQsIHdoaWNoIG1heSBub3QgYmUgZGVzaXJhYmxlLiBZb3Ugc2hvdWxkIGhvb2sgaW50byB5b3VyXG4gICAgICogcGxhdGZvcm0ncyBmb3JlZ3JvdW5kIGluZGljYXRpb24gbWVjaGFuaXNtIGFuZCBjYWxsIHRoZXNlIG1ldGhvZHNcbiAgICAgKiBhcHByb3ByaWF0ZWx5IHRvIGNvbnNlcnZlIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIHtAc2VlICNzdG9wQXV0b1JlZnJlc2h9XG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuIGFjdGl2ZSBhdXRvIHJlZnJlc2ggcHJvY2VzcyBydW5uaW5nIGluIHRoZSBiYWNrZ3JvdW5kIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogSWYgeW91IGNhbGwgdGhpcyBtZXRob2QgYW55IG1hbmFnZWQgdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYW5kIHlvdSBtdXN0IG1hbmFnZSB2aXNpYmlsaXR5IGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBTZWUge0BsaW5rICNzdGFydEF1dG9SZWZyZXNofSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0b3BBdXRvUmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyB0aGUgYXV0byByZWZyZXNoIHRva2VuIHRpY2suXG4gICAgICovXG4gICAgYXN5bmMgX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbiB8fCAhc2Vzc2lvbi5yZWZyZXNoX3Rva2VuIHx8ICFzZXNzaW9uLmV4cGlyZXNfYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdubyBzZXNzaW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2Vzc2lvbiB3aWxsIGV4cGlyZSBpbiB0aGlzIG1hbnkgdGlja3MgKG9yIGhhcyBhbHJlYWR5IGV4cGlyZWQgaWYgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHBpcmVzSW5UaWNrcyA9IE1hdGguZmxvb3IoKHNlc3Npb24uZXhwaXJlc19hdCAqIDEwMDAgLSBub3cpIC8gQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCBgYWNjZXNzIHRva2VuIGV4cGlyZXMgaW4gJHtleHBpcmVzSW5UaWNrc30gdGlja3MsIGEgdGljayBsYXN0cyAke0FVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TfW1zLCByZWZyZXNoIHRocmVzaG9sZCBpcyAke0FVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRH0gdGlja3NgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwaXJlc0luVGlja3MgPD0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oc2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQXV0byByZWZyZXNoIHRpY2sgZmFpbGVkIHdpdGggZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgdHJhbnNpZW50IGVycm9yLicsIGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgJ2VuZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5pc0FjcXVpcmVUaW1lb3V0IHx8IGUgaW5zdGFuY2VvZiBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCdhdXRvIHJlZnJlc2ggdG9rZW4gdGljayBsb2NrIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGNhbGxiYWNrcyBvbiB0aGUgYnJvd3NlciAvIHBsYXRmb3JtLCB3aGljaCBpbi10dXJuIHJ1blxuICAgICAqIGFsZ29yaXRobXMgd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cvdGFiIGFyZSBpbiBmb3JlZ3JvdW5kLiBPbiBub24tYnJvd3NlclxuICAgICAqIHBsYXRmb3JtcyBpdCBhc3N1bWVzIGFsd2F5cyBmb3JlZ3JvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIF9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlKCknKTtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSB8fCAhKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBhbHdheXNcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gYXN5bmMgKCkgPT4gYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZChmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBub3cgaW1tZWRpYXRlbHkgY2FsbCB0aGUgdmlzYmlsaXR5IGNoYW5nZWQgY2FsbGJhY2sgdG8gc2V0dXAgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgdmlzYmlsaXR5IHN0YXRlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9vblZpc2liaWxpdHlDaGFuZ2VkKHRydWUpOyAvLyBpbml0aWFsIGNhbGxcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ19oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHJlZ2lzdGVyZWQgd2l0aCBgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnKWAuXG4gICAgICovXG4gICAgYXN5bmMgX29uVmlzaWJpbGl0eUNoYW5nZWQoY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kTmFtZSA9IGAjX29uVmlzaWJpbGl0eUNoYW5nZWQoJHtjYWxsZWRGcm9tSW5pdGlhbGl6ZX0pYDtcbiAgICAgICAgdGhpcy5fZGVidWcobWV0aG9kTmFtZSwgJ3Zpc2liaWxpdHlTdGF0ZScsIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSk7XG4gICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzIHRoZSByZWZyZXNoIHRva2VuIHRpY2tlciBydW5zIG9ubHkgb24gZm9jdXNlZCB0YWJzXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggcHJldmVudHMgcmFjZSBjb25kaXRpb25zXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYWxsZWRGcm9tSW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCBpLmUuIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNpdGlvbmVkIGZyb20gaGlkZGVuIC0+IHZpc2libGUgc28gd2UgbmVlZCB0byBzZWUgaWYgdGhlIHNlc3Npb25cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmVjb3ZlcmVkIGltbWVkaWF0ZWx5Li4uIGJ1dCB0byBkbyB0aGF0IHdlIG5lZWQgdG8gYWNxdWlyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBsb2NrIGZpcnN0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlICE9PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICdhY3F1aXJlZCB0aGUgbG9jayB0byByZWNvdmVyIHRoZSBzZXNzaW9uLCBidXQgdGhlIGJyb3dzZXIgdmlzaWJpbGl0eVN0YXRlIGlzIG5vIGxvbmdlciB2aXNpYmxlLCBhYm9ydGluZycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCB3aGlsZSB3YWl0aW5nIGZvciB0aGUgbG9jaywgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZWNvdmVyIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlY292ZXJBbmRSZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1JlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0b3BBdXRvUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB0aGUgcmVsZXZhbnQgbG9naW4gVVJMIGZvciBhIHRoaXJkLXBhcnR5IHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gQSBVUkwgb3IgbW9iaWxlIGFkZHJlc3MgdG8gc2VuZCB0aGUgdXNlciB0byBhZnRlciB0aGV5IGFyZSBjb25maXJtZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2NvcGVzIEEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2Ygc2NvcGVzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnF1ZXJ5UGFyYW1zIEFuIG9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgY29udGFpbmluZyBxdWVyeSBwYXJhbWV0ZXJzIGdyYW50ZWQgdG8gdGhlIE9BdXRoIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRVcmxGb3JQcm92aWRlcih1cmwsIHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcmFtcyA9IFtgcHJvdmlkZXI9JHtlbmNvZGVVUklDb21wb25lbnQocHJvdmlkZXIpfWBdO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8pIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGByZWRpcmVjdF90bz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnJlZGlyZWN0VG8pfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2NvcGVzPSR7ZW5jb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMuc2NvcGVzKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICBjb25zdCBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGZsb3dQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2UpfWAsXG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBgJHtlbmNvZGVVUklDb21wb25lbnQoY29kZUNoYWxsZW5nZU1ldGhvZCl9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goZmxvd1BhcmFtcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMob3B0aW9ucy5xdWVyeVBhcmFtcyk7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChxdWVyeS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGBza2lwX2h0dHBfcmVkaXJlY3Q9JHtvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3VybH0/JHt1cmxQYXJhbXMuam9pbignJicpfWA7XG4gICAgfVxuICAgIGFzeW5jIF91bmVucm9sbChwYXJhbXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnREVMRVRFJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW5yb2xsKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKHsgZnJpZW5kbHlfbmFtZTogcGFyYW1zLmZyaWVuZGx5TmFtZSwgZmFjdG9yX3R5cGU6IHBhcmFtcy5mYWN0b3JUeXBlIH0sIChwYXJhbXMuZmFjdG9yVHlwZSA9PT0gJ3Bob25lJ1xuICAgICAgICAgICAgICAgICAgICA/IHsgcGhvbmU6IHBhcmFtcy5waG9uZSB9XG4gICAgICAgICAgICAgICAgICAgIDogcGFyYW1zLmZhY3RvclR5cGUgPT09ICd0b3RwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGlzc3VlcjogcGFyYW1zLmlzc3VlciB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gKGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCcgJiYgZGF0YS50eXBlID09PSAndG90cCcgJiYgKChfYiA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS50b3RwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucXJfY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50b3RwLnFyX2NvZGUgPSBgZGF0YTppbWFnZS9zdmcreG1sO3V0Zi04LCR7ZGF0YS50b3RwLnFyX2NvZGV9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGEsIGVycm9yOiBudWxsIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3ZlcmlmeShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKHRoaXMubG9ja0FjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKHsgY2hhbGxlbmdlX2lkOiBwYXJhbXMuY2hhbGxlbmdlSWQgfSwgKCd3ZWJhdXRobicgaW4gcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJhdXRobjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMud2ViYXV0aG4pLCB7IGNyZWRlbnRpYWxfcmVzcG9uc2U6IHBhcmFtcy53ZWJhdXRobi50eXBlID09PSAnY3JlYXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZShwYXJhbXMud2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZShwYXJhbXMud2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSkgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgY29kZTogcGFyYW1zLmNvZGUgfSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS92ZXJpZnlgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKE9iamVjdC5hc3NpZ24oeyBleHBpcmVzX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIGRhdGEuZXhwaXJlc19pbiB9LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9jaGFsbGVuZ2UocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jayh0aGlzLmxvY2tBY3F1aXJlVGltZW91dCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgIT09ICd3ZWJhdXRobicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLndlYmF1dGhuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB3ZWJhdXRobjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX29wdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSkgfSkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4pLCB7IGNyZWRlbnRpYWxfb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXkpIH0pIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjY2hhbGxlbmdlQW5kVmVyaWZ5fVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2VBbmRWZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIC8vIGJvdGggX2NoYWxsZW5nZSBhbmQgX3ZlcmlmeSBpbmRlcGVuZGVudGx5IGFjcXVpcmUgdGhlIGxvY2ssIHNvIG5vIG5lZWRcbiAgICAgICAgLy8gdG8gYWNxdWlyZSBpdCBoZXJlXG4gICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlRGF0YSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjaGFsbGVuZ2VFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlRGF0YS5pZCxcbiAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5jb2RlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2xpc3RGYWN0b3JzfVxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0RmFjdG9ycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyB1c2UgI2dldFVzZXIgaW5zdGVhZCBvZiAjX2dldFVzZXIgYXMgdGhlIGZvcm1lciBhY3F1aXJlcyBhIGxvY2tcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IHVzZXJFcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcigpO1xuICAgICAgICBpZiAodXNlckVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogdXNlckVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIGFsbDogW10sXG4gICAgICAgICAgICBwaG9uZTogW10sXG4gICAgICAgICAgICB0b3RwOiBbXSxcbiAgICAgICAgICAgIHdlYmF1dGhuOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gbG9vcCBvdmVyIHRoZSBmYWN0b3JzIE9OQ0VcbiAgICAgICAgZm9yIChjb25zdCBmYWN0b3Igb2YgKF9hID0gdXNlciA9PT0gbnVsbCB8fCB1c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyLmZhY3RvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKSB7XG4gICAgICAgICAgICBkYXRhLmFsbC5wdXNoKGZhY3Rvcik7XG4gICAgICAgICAgICBpZiAoZmFjdG9yLnN0YXR1cyA9PT0gJ3ZlcmlmaWVkJykge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBkYXRhW2ZhY3Rvci5mYWN0b3JfdHlwZV0ucHVzaChmYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAc2VlIEdvVHJ1ZU1GQUFwaSNnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWx9XG4gICAgICovXG4gICAgYXN5bmMgX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IGF3YWl0IHRoaXMuZ2V0U2Vzc2lvbigpO1xuICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBkZWNvZGVKV1Qoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPSAoX2IgPSAoX2EgPSBzZXNzaW9uLnVzZXIuZmFjdG9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbywgc2NvcGVzLCBhbmQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBJZiB0aGUgQVBJIHJldHVybnMgYSByZWRpcmVjdF91cmksIGl0IG1lYW5zIGNvbnNlbnQgd2FzIGFscmVhZHkgZ2l2ZW4gLSB0aGUgY2FsbGVyXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgcmVkaXJlY3QgbWFudWFsbHkgaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRob3JpemF0aW9uRGV0YWlscyhhdXRob3JpemF0aW9uSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9vYXV0aC9hdXRob3JpemF0aW9ucy8ke2F1dGhvcml6YXRpb25JZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IChkYXRhKSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcHJvdmVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9hcHByb3ZlQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfS9jb25zZW50YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgYWN0aW9uOiAnYXBwcm92ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IChkYXRhKSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGluIGJyb3dzZXIgdW5sZXNzIHNraXBCcm93c2VyUmVkaXJlY3QgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbmllcyBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGVueUF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vYXV0aC9hdXRob3JpemF0aW9ucy8ke2F1dGhvcml6YXRpb25JZH0vY29uc2VudGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7IGFjdGlvbjogJ2RlbnknIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiAoZGF0YSkgPT4gKHsgZGF0YSwgZXJyb3I6IG51bGwgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXV0b21hdGljYWxseSByZWRpcmVjdCBpbiBicm93c2VyIHVubGVzcyBza2lwQnJvd3NlclJlZGlyZWN0IGlzIHRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBhbGwgT0F1dGggZ3JhbnRzIHRoYXQgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlciBoYXMgYXV0aG9yaXplZC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9saXN0T0F1dGhHcmFudHMoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JldHVyblJlc3VsdCh7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCBgJHt0aGlzLnVybH0vdXNlci9vYXV0aC9ncmFudHNgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IChkYXRhKSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgYSB1c2VyJ3MgT0F1dGggZ3JhbnQgZm9yIGEgc3BlY2lmaWMgY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICovXG4gICAgYXN5bmMgX3Jldm9rZU9BdXRoR3JhbnQob3B0aW9ucykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXR1cm5SZXN1bHQoeyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCkgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vdXNlci9vYXV0aC9ncmFudHNgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHsgY2xpZW50X2lkOiBvcHRpb25zLmNsaWVudElkIH0sXG4gICAgICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YToge30sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaEp3ayhraWQsIGp3a3MgPSB7IGtleXM6IFtdIH0pIHtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gdGhlIHN1cHBsaWVkIGp3a3NcbiAgICAgICAgbGV0IGp3ayA9IGp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIGlmIChqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gY2FjaGVcbiAgICAgICAgandrID0gdGhpcy5qd2tzLmtleXMuZmluZCgoa2V5KSA9PiBrZXkua2lkID09PSBraWQpO1xuICAgICAgICAvLyBqd2sgZXhpc3RzIGFuZCBqd2tzIGlzbid0IHN0YWxlXG4gICAgICAgIGlmIChqd2sgJiYgdGhpcy5qd2tzX2NhY2hlZF9hdCArIEpXS1NfVFRMID4gbm93KSB7XG4gICAgICAgICAgICByZXR1cm4gandrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGp3ayBpc24ndCBjYWNoZWQgaW4gbWVtb3J5IHNvIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgd2VsbC1rbm93biBlbmRwb2ludFxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9Ly53ZWxsLWtub3duL2p3a3MuanNvbmAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmtleXMgfHwgZGF0YS5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5qd2tzID0gZGF0YTtcbiAgICAgICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IG5vdztcbiAgICAgICAgLy8gRmluZCB0aGUgc2lnbmluZyBrZXlcbiAgICAgICAgandrID0gZGF0YS5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBKV1QgY2xhaW1zIHByZXNlbnQgaW4gdGhlIGFjY2VzcyB0b2tlbiBieSBmaXJzdCB2ZXJpZnlpbmcgdGhlXG4gICAgICogSldUIGFnYWluc3QgdGhlIHNlcnZlcidzIEpTT04gV2ViIEtleSBTZXQgZW5kcG9pbnRcbiAgICAgKiBgLy53ZWxsLWtub3duL2p3a3MuanNvbmAgd2hpY2ggaXMgb2Z0ZW4gY2FjaGVkLCByZXN1bHRpbmcgaW4gc2lnbmlmaWNhbnRseVxuICAgICAqIGZhc3RlciByZXNwb25zZXMuIFByZWZlciB0aGlzIG1ldGhvZCBvdmVyIHtAbGluayAjZ2V0VXNlcn0gd2hpY2ggYWx3YXlzXG4gICAgICogc2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBBdXRoIHNlcnZlciBmb3IgZWFjaCBKV1QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcHJvamVjdCBpcyBub3QgdXNpbmcgYW4gYXN5bW1ldHJpYyBKV1Qgc2lnbmluZyBrZXkgKGxpa2UgRUNDIG9yXG4gICAgICogUlNBKSBpdCBhbHdheXMgc2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBBdXRoIHNlcnZlciAoc2ltaWxhciB0byB7QGxpbmtcbiAgICAgKiAjZ2V0VXNlcn0pIHRvIHZlcmlmeSB0aGUgSldULlxuICAgICAqXG4gICAgICogQHBhcmFtIGp3dCBBbiBvcHRpb25hbCBzcGVjaWZpYyBKV1QgeW91IHdpc2ggdG8gdmVyaWZ5LCBub3QgdGhlIG9uZSB5b3VcbiAgICAgKiAgICAgICAgICAgIGNhbiBvYnRhaW4gZnJvbSB7QGxpbmsgI2dldFNlc3Npb259LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgYWRkaXRpb25hbCBvcHRpb25zIHRoYXQgYWxsb3cgeW91IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGFpbXMoand0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IGp3dDtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2VuID0gZGF0YS5zZXNzaW9uLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVyLCBwYXlsb2FkLCBzaWduYXR1cmUsIHJhdzogeyBoZWFkZXI6IHJhd0hlYWRlciwgcGF5bG9hZDogcmF3UGF5bG9hZCB9LCB9ID0gZGVjb2RlSldUKHRva2VuKTtcbiAgICAgICAgICAgIGlmICghKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbGxvd0V4cGlyZWQpKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IGV4cGlyZWQgSldUcyBzaG91bGQgb25seSBoYXBwZW4gaWYgand0IGFyZ3VtZW50IHdhcyBwYXNzZWRcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUV4cChwYXlsb2FkLmV4cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gIWhlYWRlci5hbGcgfHxcbiAgICAgICAgICAgICAgICBoZWFkZXIuYWxnLnN0YXJ0c1dpdGgoJ0hTJykgfHxcbiAgICAgICAgICAgICAgICAhaGVhZGVyLmtpZCB8fFxuICAgICAgICAgICAgICAgICEoJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyAmJiAnc3VidGxlJyBpbiBnbG9iYWxUaGlzLmNyeXB0bylcbiAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICA6IGF3YWl0IHRoaXMuZmV0Y2hKd2soaGVhZGVyLmtpZCwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5rZXlzKSA/IHsga2V5czogb3B0aW9ucy5rZXlzIH0gOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuandrcyk7XG4gICAgICAgICAgICAvLyBJZiBzeW1tZXRyaWMgYWxnb3JpdGhtIG9yIFdlYkNyeXB0byBBUEkgaXMgdW5hdmFpbGFibGUsIGZhbGxiYWNrIHRvIGdldFVzZXIoKVxuICAgICAgICAgICAgaWYgKCFzaWduaW5nS2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdldFVzZXIgc3VjY2VlZHMgc28gdGhlIGNsYWltcyBpbiB0aGUgSldUIGNhbiBiZSB0cnVzdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhaW1zOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxnb3JpdGhtID0gZ2V0QWxnb3JpdGhtKGhlYWRlci5hbGcpO1xuICAgICAgICAgICAgLy8gQ29udmVydCBKV0sgdG8gQ3J5cHRvS2V5XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgnandrJywgc2lnbmluZ0tleSwgYWxnb3JpdGhtLCB0cnVlLCBbXG4gICAgICAgICAgICAgICAgJ3ZlcmlmeScsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGUgc2lnbmF0dXJlXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBwdWJsaWNLZXksIHNpZ25hdHVyZSwgc3RyaW5nVG9VaW50OEFycmF5KGAke3Jhd0hlYWRlcn0uJHtyYXdQYXlsb2FkfWApKTtcbiAgICAgICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzaWduYXR1cmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHZlcmlmaWNhdGlvbiBzdWNjZWVkcywgZGVjb2RlIGFuZCByZXR1cm4gY2xhaW1zXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhaW1zOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmV0dXJuUmVzdWx0KHsgZGF0YTogbnVsbCwgZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbkdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRCA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgR29UcnVlQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVBZG1pbkFwaSIsIkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TIiwiQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEIiwiREVGQVVMVF9IRUFERVJTIiwiRVhQSVJZX01BUkdJTl9NUyIsIkdPVFJVRV9VUkwiLCJKV0tTX1RUTCIsIlNUT1JBR0VfS0VZIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aEludmFsaWRKd3RFcnJvciIsIkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIiwiQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IiLCJBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJpc0F1dGhBcGlFcnJvciIsImlzQXV0aEVycm9yIiwiaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IiLCJpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIl9yZXF1ZXN0IiwiX3Nlc3Npb25SZXNwb25zZSIsIl9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCIsIl9zc29SZXNwb25zZSIsIl91c2VyUmVzcG9uc2UiLCJkZWNvZGVKV1QiLCJkZWVwQ2xvbmUiLCJEZWZlcnJlZCIsImdlbmVyYXRlQ2FsbGJhY2tJZCIsImdldEFsZ29yaXRobSIsImdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QiLCJnZXRJdGVtQXN5bmMiLCJpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkiLCJpc0Jyb3dzZXIiLCJwYXJzZVBhcmFtZXRlcnNGcm9tVVJMIiwicmVtb3ZlSXRlbUFzeW5jIiwicmVzb2x2ZUZldGNoIiwicmV0cnlhYmxlIiwic2V0SXRlbUFzeW5jIiwic2xlZXAiLCJzdXBwb3J0c0xvY2FsU3RvcmFnZSIsInVzZXJOb3RBdmFpbGFibGVQcm94eSIsInZhbGlkYXRlRXhwIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsIkxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwibmF2aWdhdG9yTG9jayIsInBvbHlmaWxsR2xvYmFsVGhpcyIsInZlcnNpb24iLCJieXRlc1RvQmFzZTY0VVJMIiwic3RyaW5nVG9VaW50OEFycmF5IiwiY3JlYXRlU2l3ZU1lc3NhZ2UiLCJmcm9tSGV4IiwiZ2V0QWRkcmVzcyIsInRvSGV4IiwiZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIiwiZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMiLCJzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSIsInNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UiLCJXZWJBdXRobkFwaSIsIkRFRkFVTFRfT1BUSU9OUyIsInVybCIsInN0b3JhZ2VLZXkiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJoZWFkZXJzIiwiZmxvd1R5cGUiLCJkZWJ1ZyIsImhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIiLCJ0aHJvd09uRXJyb3IiLCJsb2NrQWNxdWlyZVRpbWVvdXQiLCJsb2NrTm9PcCIsIm5hbWUiLCJhY3F1aXJlVGltZW91dCIsImZuIiwiR0xPQkFMX0pXS1MiLCJHb1RydWVDbGllbnQiLCJqd2tzIiwiX2EiLCJfYiIsImtleXMiLCJ2YWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsImp3a3NfY2FjaGVkX2F0IiwiY2FjaGVkQXQiLCJOdW1iZXIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2MiLCJ1c2VyU3RvcmFnZSIsIm1lbW9yeVN0b3JhZ2UiLCJzdGF0ZUNoYW5nZUVtaXR0ZXJzIiwiTWFwIiwiYXV0b1JlZnJlc2hUaWNrZXIiLCJhdXRvUmVmcmVzaFRpY2tUaW1lb3V0IiwidmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlZnJlc2hpbmdEZWZlcnJlZCIsImluaXRpYWxpemVQcm9taXNlIiwic3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyIsImxvY2tBY3F1aXJlZCIsInBlbmRpbmdJbkxvY2siLCJicm9hZGNhc3RDaGFubmVsIiwibG9nZ2VyIiwiY29uc29sZSIsImxvZyIsInNldHRpbmdzIiwiaW5zdGFuY2VJRCIsIm5leHRJbnN0YW5jZUlEIiwibG9nRGVidWdNZXNzYWdlcyIsIm1lc3NhZ2UiLCJfbG9nUHJlZml4Iiwid2FybiIsInRyYWNlIiwiYWRtaW4iLCJmZXRjaCIsImxvY2siLCJnbG9iYWxUaGlzIiwibmF2aWdhdG9yIiwibG9ja3MiLCJtZmEiLCJ2ZXJpZnkiLCJfdmVyaWZ5IiwiYmluZCIsImVucm9sbCIsIl9lbnJvbGwiLCJ1bmVucm9sbCIsIl91bmVucm9sbCIsImNoYWxsZW5nZSIsIl9jaGFsbGVuZ2UiLCJsaXN0RmFjdG9ycyIsIl9saXN0RmFjdG9ycyIsImNoYWxsZW5nZUFuZFZlcmlmeSIsIl9jaGFsbGVuZ2VBbmRWZXJpZnkiLCJnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwiLCJfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsIiwid2ViYXV0aG4iLCJvYXV0aCIsImdldEF1dGhvcml6YXRpb25EZXRhaWxzIiwiX2dldEF1dGhvcml6YXRpb25EZXRhaWxzIiwiYXBwcm92ZUF1dGhvcml6YXRpb24iLCJfYXBwcm92ZUF1dGhvcml6YXRpb24iLCJkZW55QXV0aG9yaXphdGlvbiIsIl9kZW55QXV0aG9yaXphdGlvbiIsImxpc3RHcmFudHMiLCJfbGlzdE9BdXRoR3JhbnRzIiwicmV2b2tlR3JhbnQiLCJfcmV2b2tlT0F1dGhHcmFudCIsInN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJCcm9hZGNhc3RDaGFubmVsIiwiZSIsImVycm9yIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiX2RlYnVnIiwiX25vdGlmeUFsbFN1YnNjcmliZXJzIiwiZGF0YSIsInNlc3Npb24iLCJpbml0aWFsaXplIiwiaXNUaHJvd09uRXJyb3JFbmFibGVkIiwiX3JldHVyblJlc3VsdCIsInJlc3VsdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImFyZ3MiLCJfYWNxdWlyZUxvY2siLCJfaW5pdGlhbGl6ZSIsInBhcmFtcyIsImNhbGxiYWNrVXJsVHlwZSIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsIl9pc0ltcGxpY2l0R3JhbnRDYWxsYmFjayIsIl9pc1BLQ0VDYWxsYmFjayIsIl9nZXRTZXNzaW9uRnJvbVVSTCIsImVycm9yQ29kZSIsImRldGFpbHMiLCJjb2RlIiwicmVkaXJlY3RUeXBlIiwiX3NhdmVTZXNzaW9uIiwic2V0VGltZW91dCIsIl9yZWNvdmVyQW5kUmVmcmVzaCIsIl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwic2lnbkluQW5vbnltb3VzbHkiLCJjcmVkZW50aWFscyIsInJlcyIsImJvZHkiLCJnb3RydWVfbWV0YV9zZWN1cml0eSIsImNhcHRjaGFfdG9rZW4iLCJjYXB0Y2hhVG9rZW4iLCJ4Zm9ybSIsInVzZXIiLCJzaWduVXAiLCJlbWFpbCIsInBhc3N3b3JkIiwiY29kZUNoYWxsZW5nZSIsImNvZGVDaGFsbGVuZ2VNZXRob2QiLCJyZWRpcmVjdFRvIiwiZW1haWxSZWRpcmVjdFRvIiwiY29kZV9jaGFsbGVuZ2UiLCJjb2RlX2NoYWxsZW5nZV9tZXRob2QiLCJwaG9uZSIsImNoYW5uZWwiLCJzaWduSW5XaXRoUGFzc3dvcmQiLCJpbnZhbGlkVG9rZW5FcnJvciIsIndlYWtfcGFzc3dvcmQiLCJ3ZWFrUGFzc3dvcmQiLCJzaWduSW5XaXRoT0F1dGgiLCJfZCIsIl9oYW5kbGVQcm92aWRlclNpZ25JbiIsInByb3ZpZGVyIiwic2NvcGVzIiwicXVlcnlQYXJhbXMiLCJza2lwQnJvd3NlclJlZGlyZWN0IiwiZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbiIsImF1dGhDb2RlIiwiX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24iLCJzaWduSW5XaXRoV2ViMyIsImNoYWluIiwic2lnbkluV2l0aEV0aGVyZXVtIiwic2lnbkluV2l0aFNvbGFuYSIsIkVycm9yIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJzaWduYXR1cmUiLCJ3YWxsZXQiLCJzdGF0ZW1lbnQiLCJyZXNvbHZlZFdhbGxldCIsIndpbmRvd0FueSIsImV0aGVyZXVtIiwicmVxdWVzdCIsIlVSTCIsImFjY291bnRzIiwibWV0aG9kIiwidGhlbiIsImFjY3MiLCJjYXRjaCIsImxlbmd0aCIsImFkZHJlc3MiLCJjaGFpbklkIiwiY2hhaW5JZEhleCIsInNpd2VNZXNzYWdlIiwiZG9tYWluIiwiaG9zdCIsInVyaSIsIm5vbmNlIiwiaXNzdWVkQXQiLCJleHBpcmF0aW9uVGltZSIsIm5vdEJlZm9yZSIsInJlcXVlc3RJZCIsInJlc291cmNlcyIsIl9tIiwic29sYW5hIiwic2lnbkluIiwic2lnbk1lc3NhZ2UiLCJvdXRwdXQiLCJvdXRwdXRUb1Byb2Nlc3MiLCJBcnJheSIsImlzQXJyYXkiLCJzaWduZWRNZXNzYWdlIiwiVWludDhBcnJheSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicHVibGljS2V5IiwidG9CYXNlNTgiLCJtYXAiLCJyZXNvdXJjZSIsImpvaW4iLCJtYXliZVNpZ25hdHVyZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwic3RvcmFnZUl0ZW0iLCJjb2RlVmVyaWZpZXIiLCJzcGxpdCIsImF1dGhfY29kZSIsImNvZGVfdmVyaWZpZXIiLCJzaWduSW5XaXRoSWRUb2tlbiIsInRva2VuIiwiYWNjZXNzX3Rva2VuIiwiaWRfdG9rZW4iLCJzaWduSW5XaXRoT3RwIiwiY3JlYXRlX3VzZXIiLCJzaG91bGRDcmVhdGVVc2VyIiwibWVzc2FnZUlkIiwibWVzc2FnZV9pZCIsInZlcmlmeU90cCIsInVuZGVmaW5lZCIsInRva2VuVmVyaWZpY2F0aW9uRXJyb3IiLCJ0eXBlIiwic2lnbkluV2l0aFNTTyIsInByb3ZpZGVyX2lkIiwicHJvdmlkZXJJZCIsInJlZGlyZWN0X3RvIiwic2tpcF9odHRwX3JlZGlyZWN0IiwicmVhdXRoZW50aWNhdGUiLCJfcmVhdXRoZW50aWNhdGUiLCJfdXNlU2Vzc2lvbiIsInNlc3Npb25FcnJvciIsImp3dCIsInJlc2VuZCIsImVuZHBvaW50IiwiZ2V0U2Vzc2lvbiIsImxhc3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInB1c2giLCJ3YWl0T24iLCJhbGwiLCJzcGxpY2UiLCJfX2xvYWRTZXNzaW9uIiwic3RhY2siLCJjdXJyZW50U2Vzc2lvbiIsIm1heWJlU2Vzc2lvbiIsIl9pc1ZhbGlkU2Vzc2lvbiIsIl9yZW1vdmVTZXNzaW9uIiwiaGFzRXhwaXJlZCIsImV4cGlyZXNfYXQiLCJub3ciLCJtYXliZVVzZXIiLCJpc1NlcnZlciIsIl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkiLCJzdXBwcmVzc1dhcm5pbmdSZWYiLCJfY2FsbFJlZnJlc2hUb2tlbiIsInJlZnJlc2hfdG9rZW4iLCJnZXRVc2VyIiwiX2dldFVzZXIiLCJ1cGRhdGVVc2VyIiwiYXR0cmlidXRlcyIsIl91cGRhdGVVc2VyIiwic2Vzc2lvbkRhdGEiLCJ1c2VyRXJyb3IiLCJzZXRTZXNzaW9uIiwiX3NldFNlc3Npb24iLCJ0aW1lTm93IiwiZXhwaXJlc0F0IiwicGF5bG9hZCIsImV4cCIsInJlZnJlc2hlZFNlc3Npb24iLCJ0b2tlbl90eXBlIiwiZXhwaXJlc19pbiIsInJlZnJlc2hTZXNzaW9uIiwiX3JlZnJlc2hTZXNzaW9uIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvcl9jb2RlIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiaGlzdG9yeSIsInJlcGxhY2VTdGF0ZSIsInN0YXRlIiwidG9TdHJpbmciLCJwcm92aWRlcl90b2tlbiIsInByb3ZpZGVyX3JlZnJlc2hfdG9rZW4iLCJNYXRoIiwicm91bmQiLCJleHBpcmVzSW4iLCJwYXJzZUludCIsImFjdHVhbGx5RXhwaXJlc0luIiwiaGFzaCIsIkJvb2xlYW4iLCJjdXJyZW50U3RvcmFnZUNvbnRlbnQiLCJzaWduT3V0Iiwic2NvcGUiLCJfc2lnbk91dCIsImFjY2Vzc1Rva2VuIiwic3RhdHVzIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJjYWxsYmFjayIsImlkIiwic3Vic2NyaXB0aW9uIiwidW5zdWJzY3JpYmUiLCJzZXQiLCJfZW1pdEluaXRpYWxTZXNzaW9uIiwiZ2V0IiwiZXJyIiwicmVzZXRQYXNzd29yZEZvckVtYWlsIiwiZ2V0VXNlcklkZW50aXRpZXMiLCJpZGVudGl0aWVzIiwibGlua0lkZW50aXR5IiwibGlua0lkZW50aXR5SWRUb2tlbiIsImxpbmtJZGVudGl0eU9BdXRoIiwiX2dldFVybEZvclByb3ZpZGVyIiwibGlua19pZGVudGl0eSIsInVubGlua0lkZW50aXR5IiwiaWRlbnRpdHkiLCJpZGVudGl0eV9pZCIsIl9yZWZyZXNoQWNjZXNzVG9rZW4iLCJyZWZyZXNoVG9rZW4iLCJkZWJ1Z05hbWUiLCJzdWJzdHJpbmciLCJzdGFydGVkQXQiLCJhdHRlbXB0IiwicG93IiwibmV4dEJhY2tPZmZJbnRlcnZhbCIsImlzVmFsaWRTZXNzaW9uIiwiaXMiLCJzZXBhcmF0ZVVzZXIiLCJleHBpcmVzV2l0aE1hcmdpbiIsIkluZmluaXR5IiwiZ2V0VXNlckVycm9yIiwicHJvbWlzZSIsInJlamVjdCIsImJyb2FkY2FzdCIsInBvc3RNZXNzYWdlIiwiZXJyb3JzIiwicHJvbWlzZXMiLCJmcm9tIiwidmFsdWVzIiwieCIsImkiLCJzZXNzaW9uVG9Qcm9jZXNzIiwidXNlcklzUHJveHkiLCJtYWluU2Vzc2lvbkRhdGEiLCJjbG9uZWRNYWluU2Vzc2lvbkRhdGEiLCJjbG9uZWRTZXNzaW9uIiwiX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2siLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiX3N0YXJ0QXV0b1JlZnJlc2giLCJfc3RvcEF1dG9SZWZyZXNoIiwidGlja2VyIiwic2V0SW50ZXJ2YWwiLCJfYXV0b1JlZnJlc2hUb2tlblRpY2siLCJ1bnJlZiIsIkRlbm8iLCJ1bnJlZlRpbWVyIiwidGltZW91dCIsImNsZWFySW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJzdGFydEF1dG9SZWZyZXNoIiwic3RvcEF1dG9SZWZyZXNoIiwiZXhwaXJlc0luVGlja3MiLCJmbG9vciIsImlzQWNxdWlyZVRpbWVvdXQiLCJfb25WaXNpYmlsaXR5Q2hhbmdlZCIsImNhbGxlZEZyb21Jbml0aWFsaXplIiwibWV0aG9kTmFtZSIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwidXJsUGFyYW1zIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZmxvd1BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZmFjdG9ySWQiLCJmcmllbmRseV9uYW1lIiwiZnJpZW5kbHlOYW1lIiwiZmFjdG9yX3R5cGUiLCJmYWN0b3JUeXBlIiwiaXNzdWVyIiwidG90cCIsInFyX2NvZGUiLCJjaGFsbGVuZ2VfaWQiLCJjaGFsbGVuZ2VJZCIsImNyZWRlbnRpYWxfcmVzcG9uc2UiLCJyZXNwb25zZSIsImNyZWRlbnRpYWxfb3B0aW9ucyIsImNoYWxsZW5nZURhdGEiLCJjaGFsbGVuZ2VFcnJvciIsImZhY3RvciIsImZhY3RvcnMiLCJjdXJyZW50TGV2ZWwiLCJuZXh0TGV2ZWwiLCJjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIiwiYWFsIiwidmVyaWZpZWRGYWN0b3JzIiwiZmlsdGVyIiwiYW1yIiwiYXV0aG9yaXphdGlvbklkIiwiYWN0aW9uIiwicmVkaXJlY3RfdXJsIiwiY2xpZW50X2lkIiwiY2xpZW50SWQiLCJub1Jlc29sdmVKc29uIiwiZmV0Y2hKd2siLCJraWQiLCJqd2siLCJmaW5kIiwia2V5IiwiZ2V0Q2xhaW1zIiwiaGVhZGVyIiwicmF3IiwicmF3SGVhZGVyIiwicmF3UGF5bG9hZCIsImFsbG93RXhwaXJlZCIsInNpZ25pbmdLZXkiLCJhbGciLCJzdGFydHNXaXRoIiwiY3J5cHRvIiwiY2xhaW1zIiwiYWxnb3JpdGhtIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiaXNWYWxpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCECodeVerifierMissingError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _lib_types__WEBPACK_IMPORTED_MODULE_4__.SIGN_OUT_SCOPES),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthPKCECodeVerifierMissingError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.processLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ0o7QUFDQTtBQUNKO0FBQzRCO0FBQ3RDO0FBQ0M7QUFDMkYsQ0FDeEgsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanM/NTUwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgR29UcnVlQ2xpZW50IGZyb20gJy4vR29UcnVlQ2xpZW50JztcbmltcG9ydCBBdXRoQWRtaW5BcGkgZnJvbSAnLi9BdXRoQWRtaW5BcGknO1xuaW1wb3J0IEF1dGhDbGllbnQgZnJvbSAnLi9BdXRoQ2xpZW50JztcbmV4cG9ydCB7IEdvVHJ1ZUFkbWluQXBpLCBHb1RydWVDbGllbnQsIEF1dGhBZG1pbkFwaSwgQXV0aENsaWVudCB9O1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZXJyb3JzJztcbmV4cG9ydCB7IG5hdmlnYXRvckxvY2ssIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yLCBpbnRlcm5hbHMgYXMgbG9ja0ludGVybmFscywgcHJvY2Vzc0xvY2ssIH0gZnJvbSAnLi9saWIvbG9ja3MnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIkdvVHJ1ZUFkbWluQXBpIiwiR29UcnVlQ2xpZW50IiwiQXV0aEFkbWluQXBpIiwiQXV0aENsaWVudCIsIm5hdmlnYXRvckxvY2siLCJOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciIsImludGVybmFscyIsImxvY2tJbnRlcm5hbHMiLCJwcm9jZXNzTG9jayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64UrlToUint8Array: () => (/* binding */ base64UrlToUint8Array),\n/* harmony export */   byteFromBase64URL: () => (/* binding */ byteFromBase64URL),\n/* harmony export */   byteToBase64URL: () => (/* binding */ byteToBase64URL),\n/* harmony export */   bytesToBase64URL: () => (/* binding */ bytesToBase64URL),\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */ function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = state.queue << 8 | byte;\n        state.queuedBits += 8;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    } else if (state.queuedBits > 0) {\n        state.queue = state.queue << 6 - state.queuedBits;\n        state.queuedBits = 6;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */ function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = state.queue << 6 | bits;\n        state.queuedBits += 6;\n        while(state.queuedBits >= 8){\n            emit(state.queue >> state.queuedBits - 8 & 0xff);\n            state.queuedBits -= 8;\n        }\n    } else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    } else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char)=>{\n        base64.push(char);\n    };\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    stringToUTF8(str, (byte)=>{\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    const b64State = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const byteEmit = (byte)=>{\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */ function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onByte = (byte)=>{\n        result.push(byte);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte)=>result.push(byte));\n    return new Uint8Array(result);\n}\nfunction bytesToBase64URL(bytes) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onChar = (char)=>{\n        result.push(char);\n    };\n    bytes.forEach((byte)=>byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join(\"\");\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1BLGVBQWUsbUVBQW1FQyxLQUFLLENBQUM7QUFDOUY7OztDQUdDLEdBQ0QsTUFBTUMsbUJBQW1CLFVBQVdELEtBQUssQ0FBQztBQUMxQzs7O0NBR0MsR0FDRCxNQUFNRSxpQkFBaUIsQ0FBQztJQUNwQixNQUFNQyxVQUFVLElBQUlDLE1BQU07SUFDMUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFHLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3hDRixPQUFPLENBQUNFLEVBQUUsR0FBRyxDQUFDO0lBQ2xCO0lBQ0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUlKLGlCQUFpQkssTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDakRGLE9BQU8sQ0FBQ0YsZ0JBQWdCLENBQUNJLEVBQUUsQ0FBQ0UsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2xEO0lBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlOLGFBQWFPLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQzdDRixPQUFPLENBQUNKLFlBQVksQ0FBQ00sRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHRjtJQUM3QztJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSyxnQkFBZ0JDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQzdDLElBQUlGLFNBQVMsTUFBTTtRQUNmQyxNQUFNRSxLQUFLLEdBQUcsTUFBT0EsS0FBSyxJQUFJLElBQUtIO1FBQ25DQyxNQUFNRyxVQUFVLElBQUk7UUFDcEIsTUFBT0gsTUFBTUcsVUFBVSxJQUFJLEVBQUc7WUFDMUIsTUFBTUMsTUFBTSxNQUFPRixLQUFLLElBQUtGLE1BQU1HLFVBQVUsR0FBRyxJQUFN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O0FBQzFCO0FBQ08sU0FBU0ksaUJBQWlCQyxLQUFLO0lBQ2xDLE1BQU1MLFNBQVMsRUFBRTtJQUNqQixNQUFNbkMsUUFBUTtRQUFFRSxPQUFPO1FBQUdDLFlBQVk7SUFBRTtJQUN4QyxNQUFNc0MsU0FBUyxDQUFDMUI7UUFDWm9CLE9BQU9uQixJQUFJLENBQUNEO0lBQ2hCO0lBQ0F5QixNQUFNRSxPQUFPLENBQUMsQ0FBQzNDLE9BQVNELGdCQUFnQkMsTUFBTUMsT0FBT3lDO0lBQ3JELHFEQUFxRDtJQUNyRDNDLGdCQUFnQixNQUFNRSxPQUFPeUM7SUFDN0IsT0FBT04sT0FBT2pCLElBQUksQ0FBQztBQUN2QixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9iYXNlNjR1cmwuanM/MTVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGVuY29kZSA2IGJpdHMgaW50byBhIEJhc2U2NC1VUkwgYWxwaGFiZXRcbiAqIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgVE9fQkFTRTY0VVJMID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSAnIFxcdFxcblxccj0nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgMTI4IG51bWJlcnMgdGhhdCBtYXAgYSBCYXNlNjQtVVJMIGNoYXJhY3RlciB0byA2IGJpdHMsIG9yIGlmIC0yXG4gKiB1c2VkIHRvIHNraXAgdGhlIGNoYXJhY3Rlciwgb3IgaWYgLTEgdXNlZCB0byBlcnJvciBvdXQuXG4gKi9cbmNvbnN0IEZST01fQkFTRTY0VVJMID0gKCgpID0+IHtcbiAgICBjb25zdCBjaGFyTWFwID0gbmV3IEFycmF5KDEyOCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbaV0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJR05PUkVfQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW1RPX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyTWFwO1xufSkoKTtcbi8qKlxuICogQ29udmVydHMgYSBieXRlIHRvIGEgQmFzZTY0LVVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGUgVGhlIGJ5dGUgdG8gY29udmVydCwgb3IgbnVsbCB0byBmbHVzaCBhdCB0aGUgZW5kIG9mIHRoZSBieXRlIHNlcXVlbmNlLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgY29udmVyc2lvbiBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBCYXNlNjQgY2hhcmFjdGVyIHdoZW4gcmVhZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoYnl0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA4KSB8IGJ5dGU7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gODtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gNikpICYgNjM7XG4gICAgICAgICAgICBlbWl0KFRPX0JBU0U2NFVSTFtwb3NdKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5xdWV1ZWRCaXRzID4gMCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IHN0YXRlLnF1ZXVlIDw8ICg2IC0gc3RhdGUucXVldWVkQml0cyk7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgPSA2O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFN0cmluZyBjaGFyIGNvZGUgKGV4dHJhY3RlZCB1c2luZyBgc3RyaW5nLmNoYXJDb2RlQXQocG9zaXRpb24pYCkgdG8gYSBzZXF1ZW5jZSBvZiBCYXNlNjQtVVJMIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGNoYXJDb2RlIFRoZSBjaGFyIGNvZGUgb2YgdGhlIEphdmFTY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgc3RhdGUuIFBhc3MgYW4gaW5pdGlhbCB2YWx1ZSBvZiBgeyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9YC5cbiAqIEBwYXJhbSBlbWl0IEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVGcm9tQmFzZTY0VVJMKGNoYXJDb2RlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjaGFyQ29kZV07XG4gICAgaWYgKGJpdHMgPiAtMSkge1xuICAgICAgICAvLyB2YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlclxuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA2KSB8IGJpdHM7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gNjtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gOCkge1xuICAgICAgICAgICAgZW1pdCgoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA4KSkgJiAweGZmKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiaXRzID09PSAtMikge1xuICAgICAgICAvLyBpZ25vcmUgc3BhY2VzLCB0YWJzLCBuZXdsaW5lcywgPVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgXCIke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfVwiYCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nICh3aGljaCBtYXkgaW5jbHVkZSBhbnkgdmFsaWQgY2hhcmFjdGVyKSBpbnRvIGFcbiAqIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuIFRoZSBzdHJpbmcgaXMgZmlyc3QgZW5jb2RlZCBpbiBVVEYtOCB3aGljaCBpc1xuICogdGhlbiBlbmNvZGVkIGFzIEJhc2U2NC1VUkwuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBbXTtcbiAgICBjb25zdCBlbWl0dGVyID0gKGNoYXIpID0+IHtcbiAgICAgICAgYmFzZTY0LnB1c2goY2hhcik7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4ge1xuICAgICAgICBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXR0ZXIpO1xuICAgIH0pO1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbUJhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBjb252ID0gW107XG4gICAgY29uc3QgdXRmOEVtaXQgPSAoY29kZXBvaW50KSA9PiB7XG4gICAgICAgIGNvbnYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlcG9pbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IHV0ZjhTdGF0ZSA9IHtcbiAgICAgICAgdXRmOHNlcTogMCxcbiAgICAgICAgY29kZXBvaW50OiAwLFxuICAgIH07XG4gICAgY29uc3QgYjY0U3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3QgYnl0ZUVtaXQgPSAoYnl0ZSkgPT4ge1xuICAgICAgICBzdHJpbmdGcm9tVVRGOChieXRlLCB1dGY4U3RhdGUsIHV0ZjhFbWl0KTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVGcm9tQmFzZTY0VVJMKHN0ci5jaGFyQ29kZUF0KGkpLCBiNjRTdGF0ZSwgYnl0ZUVtaXQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udi5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGNvZGVwb2ludCB0byBhIG11bHRpLWJ5dGUgVVRGLTggc2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIGNvZGVwb2ludCBUaGUgVW5pY29kZSBjb2RlcG9pbnQuXG4gKiBAcGFyYW0gZW1pdCAgICAgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgdGhhdCByZXByZXNlbnRzIHRoZSBjb2RlcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KSB7XG4gICAgaWYgKGNvZGVwb2ludCA8PSAweDdmKSB7XG4gICAgICAgIGVtaXQoY29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgZW1pdCgweGMwIHwgKGNvZGVwb2ludCA+PiA2KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBlbWl0KDB4ZTAgfCAoY29kZXBvaW50ID4+IDEyKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDEwZmZmZikge1xuICAgICAgICBlbWl0KDB4ZjAgfCAoY29kZXBvaW50ID4+IDE4KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDEyKSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgVW5pY29kZSBjb2RlcG9pbnQ6ICR7Y29kZXBvaW50LnRvU3RyaW5nKDE2KX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBhIHNlcXVlbmNlIG9mIFVURi04IGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBVVEYtOC5cbiAqIEBwYXJhbSBlbWl0IEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgb2YgdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgZW1pdChieXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIDEgbGVhZGluZyBiaXRzIHVudGlsIHlvdSByZWFjaCAwXG4gICAgICAgIGZvciAobGV0IGxlYWRpbmdCaXQgPSAxOyBsZWFkaW5nQml0IDwgNjsgbGVhZGluZ0JpdCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKChieXRlID4+ICg3IC0gbGVhZGluZ0JpdCkpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGY4c2VxID0gbGVhZGluZ0JpdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMikge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDMxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiAxNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID09PSA0KSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVVEYtOCBzZXF1ZW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA+IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpO1xuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAwKSB7XG4gICAgICAgICAgICBlbWl0KHN0YXRlLmNvZGVwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdG8gY29udmVydCBkaWZmZXJlbnQgdHlwZXMgb2Ygc3RyaW5ncyB0byBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoc3RyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3Qgb25CeXRlID0gKGJ5dGUpID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBieXRlRnJvbUJhc2U2NFVSTChzdHIuY2hhckNvZGVBdChpKSwgc3RhdGUsIG9uQnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4gcmVzdWx0LnB1c2goYnl0ZSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjRVUkwoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBvbkNoYXIgPSAoY2hhcikgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICB9O1xuICAgIGJ5dGVzLmZvckVhY2goKGJ5dGUpID0+IGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgb25DaGFyKSk7XG4gICAgLy8gYWx3YXlzIGNhbGwgd2l0aCBgbnVsbGAgYWZ0ZXIgcHJvY2Vzc2luZyBhbGwgYnl0ZXNcbiAgICBieXRlVG9CYXNlNjRVUkwobnVsbCwgc3RhdGUsIG9uQ2hhcik7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NHVybC5qcy5tYXAiXSwibmFtZXMiOlsiVE9fQkFTRTY0VVJMIiwic3BsaXQiLCJJR05PUkVfQkFTRTY0VVJMIiwiRlJPTV9CQVNFNjRVUkwiLCJjaGFyTWFwIiwiQXJyYXkiLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImJ5dGVUb0Jhc2U2NFVSTCIsImJ5dGUiLCJzdGF0ZSIsImVtaXQiLCJxdWV1ZSIsInF1ZXVlZEJpdHMiLCJwb3MiLCJieXRlRnJvbUJhc2U2NFVSTCIsImNoYXJDb2RlIiwiYml0cyIsIkVycm9yIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RyaW5nVG9CYXNlNjRVUkwiLCJzdHIiLCJiYXNlNjQiLCJlbWl0dGVyIiwiY2hhciIsInB1c2giLCJzdHJpbmdUb1VURjgiLCJqb2luIiwic3RyaW5nRnJvbUJhc2U2NFVSTCIsImNvbnYiLCJ1dGY4RW1pdCIsImNvZGVwb2ludCIsImZyb21Db2RlUG9pbnQiLCJ1dGY4U3RhdGUiLCJ1dGY4c2VxIiwiYjY0U3RhdGUiLCJieXRlRW1pdCIsInN0cmluZ0Zyb21VVEY4IiwiY29kZXBvaW50VG9VVEY4IiwidG9TdHJpbmciLCJoaWdoU3Vycm9nYXRlIiwibG93U3Vycm9nYXRlIiwibGVhZGluZ0JpdCIsImJhc2U2NFVybFRvVWludDhBcnJheSIsInJlc3VsdCIsIm9uQnl0ZSIsIlVpbnQ4QXJyYXkiLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJieXRlc1RvQmFzZTY0VVJMIiwiYnl0ZXMiLCJvbkNoYXIiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),\n/* harmony export */   BASE64URL_REGEX: () => (/* binding */ BASE64URL_REGEX),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   JWKS_TTL: () => (/* binding */ JWKS_TTL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = \"http://localhost:9999\";\nconst STORAGE_KEY = \"supabase.auth.token\";\nconst AUDIENCE = \"\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nconst API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n};\nconst BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nconst JWKS_TTL = 10 * 60 * 1000; // 10 minutes\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ3BDLGtFQUFrRSxHQUMzRCxNQUFNQyxnQ0FBZ0MsS0FBSyxLQUFLO0FBQ3ZEO3lGQUN5RixHQUNsRixNQUFNQyw4QkFBOEIsRUFBRTtBQUM3Qzs7Q0FFQyxHQUNNLE1BQU1DLG1CQUFtQkQsOEJBQThCRCw4QkFBOEI7QUFDckYsTUFBTUcsYUFBYSx3QkFBd0I7QUFDM0MsTUFBTUMsY0FBYyxzQkFBc0I7QUFDMUMsTUFBTUMsV0FBVyxHQUFHO0FBQ3BCLE1BQU1DLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFVBQVUsRUFBRVAsNkNBQU9BLENBQUMsQ0FBQztBQUFDLEVBQUU7QUFDcEUsTUFBTVEsa0JBQWtCO0lBQzNCQyxhQUFhO0lBQ2JDLGdCQUFnQjtBQUNwQixFQUFFO0FBQ0ssTUFBTUMsMEJBQTBCLHlCQUF5QjtBQUN6RCxNQUFNQyxlQUFlO0lBQ3hCLGNBQWM7UUFDVkMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDO1FBQ3RCQyxNQUFNO0lBQ1Y7QUFDSixFQUFFO0FBQ0ssTUFBTUMsa0JBQWtCLHVEQUF1RDtBQUMvRSxNQUFNQyxXQUFXLEtBQUssS0FBSyxLQUFLLENBQUMsYUFBYTtDQUNyRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzP2YwNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TID0gMzAgKiAxMDAwO1xuLyoqXG4gKiBBIHRva2VuIHJlZnJlc2ggd2lsbCBiZSBhdHRlbXB0ZWQgdGhpcyBtYW55IHRpY2tzIGJlZm9yZSB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyZXMuICovXG5leHBvcnQgY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEID0gMztcbi8qXG4gKiBFYXJsaWVzdCB0aW1lIGJlZm9yZSBhbiBhY2Nlc3MgdG9rZW4gZXhwaXJlcyB0aGF0IHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOX01TID0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEICogQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVM7XG5leHBvcnQgY29uc3QgR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknO1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nO1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJyc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gICAgTUFYX1JFVFJJRVM6IDEwLFxuICAgIFJFVFJZX0lOVEVSVkFMOiAyLCAvLyBpbiBkZWNpc2Vjb25kc1xufTtcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJztcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTlMgPSB7XG4gICAgJzIwMjQtMDEtMDEnOiB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZSgnMjAyNC0wMS0wMVQwMDowMDowMC4wWicpLFxuICAgICAgICBuYW1lOiAnMjAyNC0wMS0wMScsXG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgQkFTRTY0VVJMX1JFR0VYID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfSR8W2EtejAtOV8tXXsyfSQpJC9pO1xuZXhwb3J0IGNvbnN0IEpXS1NfVFRMID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsIkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TIiwiQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEIiwiRVhQSVJZX01BUkdJTl9NUyIsIkdPVFJVRV9VUkwiLCJTVE9SQUdFX0tFWSIsIkFVRElFTkNFIiwiREVGQVVMVF9IRUFERVJTIiwiTkVUV09SS19GQUlMVVJFIiwiTUFYX1JFVFJJRVMiLCJSRVRSWV9JTlRFUlZBTCIsIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiQVBJX1ZFUlNJT05TIiwidGltZXN0YW1wIiwiRGF0ZSIsInBhcnNlIiwibmFtZSIsIkJBU0U2NFVSTF9SRUdFWCIsIkpXS1NfVFRMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* binding */ AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCECodeVerifierMissingError: () => (/* binding */ AuthPKCECodeVerifierMissingError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthPKCECodeVerifierMissingError: () => (/* binding */ isAuthPKCECodeVerifierMissingError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\n/**\n * Base error thrown by Supabase Auth helpers.\n *\n * @example\n * ```ts\n * import { AuthError } from '@supabase/auth-js'\n *\n * throw new AuthError('Unexpected auth error', 500, 'unexpected')\n * ```\n */ class AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\n/**\n * Error returned directly from the GoTrue REST API.\n *\n * @example\n * ```ts\n * import { AuthApiError } from '@supabase/auth-js'\n *\n * throw new AuthApiError('Invalid credentials', 400, 'invalid_credentials')\n * ```\n */ class AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\n/**\n * Wraps non-standard errors so callers can inspect the root cause.\n *\n * @example\n * ```ts\n * import { AuthUnknownError } from '@supabase/auth-js'\n *\n * try {\n *   await someAuthCall()\n * } catch (err) {\n *   throw new AuthUnknownError('Auth failed', err)\n * }\n * ```\n */ class AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Flexible error class used to create named auth errors at runtime.\n *\n * @example\n * ```ts\n * import { CustomAuthError } from '@supabase/auth-js'\n *\n * throw new CustomAuthError('My custom auth error', 'MyAuthError', 400, 'custom_code')\n * ```\n */ class CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\n/**\n * Error thrown when an operation requires a session but none is present.\n *\n * @example\n * ```ts\n * import { AuthSessionMissingError } from '@supabase/auth-js'\n *\n * throw new AuthSessionMissingError()\n * ```\n */ class AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\n/**\n * Error thrown when the token response is malformed.\n *\n * @example\n * ```ts\n * import { AuthInvalidTokenResponseError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidTokenResponseError()\n * ```\n */ class AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\n/**\n * Error thrown when email/password credentials are invalid.\n *\n * @example\n * ```ts\n * import { AuthInvalidCredentialsError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidCredentialsError('Email or password is incorrect')\n * ```\n */ class AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\n/**\n * Error thrown when implicit grant redirects contain an error.\n *\n * @example\n * ```ts\n * import { AuthImplicitGrantRedirectError } from '@supabase/auth-js'\n *\n * throw new AuthImplicitGrantRedirectError('OAuth redirect failed', {\n *   error: 'access_denied',\n *   code: 'oauth_error',\n * })\n * ```\n */ class AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\n/**\n * Error thrown during PKCE code exchanges.\n *\n * @example\n * ```ts\n * import { AuthPKCEGrantCodeExchangeError } from '@supabase/auth-js'\n *\n * throw new AuthPKCEGrantCodeExchangeError('PKCE exchange failed')\n * ```\n */ class AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\n/**\n * Error thrown when the PKCE code verifier is not found in storage.\n * This typically happens when the auth flow was initiated in a different\n * browser, device, or the storage was cleared.\n *\n * @example\n * ```ts\n * import { AuthPKCECodeVerifierMissingError } from '@supabase/auth-js'\n *\n * throw new AuthPKCECodeVerifierMissingError()\n * ```\n */ class AuthPKCECodeVerifierMissingError extends CustomAuthError {\n    constructor(){\n        super(\"PKCE code verifier not found in storage. \" + \"This can happen if the auth flow was initiated in a different browser or device, \" + \"or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), \" + \"use @supabase/ssr on both the server and client to store the code verifier in cookies.\", \"AuthPKCECodeVerifierMissingError\", 400, \"pkce_code_verifier_not_found\");\n    }\n}\nfunction isAuthPKCECodeVerifierMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthPKCECodeVerifierMissingError\";\n}\n/**\n * Error thrown when a transient fetch issue occurs.\n *\n * @example\n * ```ts\n * import { AuthRetryableFetchError } from '@supabase/auth-js'\n *\n * throw new AuthRetryableFetchError('Service temporarily unavailable', 503)\n * ```\n */ class AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ /**\n * Error thrown when a supplied password is considered weak.\n *\n * @example\n * ```ts\n * import { AuthWeakPasswordError } from '@supabase/auth-js'\n *\n * throw new AuthWeakPasswordError('Password too short', 400, ['min_length'])\n * ```\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n}\n/**\n * Error thrown when a JWT cannot be verified or parsed.\n *\n * @example\n * ```ts\n * import { AuthInvalidJwtError } from '@supabase/auth-js'\n *\n * throw new AuthInvalidJwtError('Token signature is invalid')\n * ```\n */ class AuthInvalidJwtError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidJwtError\", 400, \"invalid_jwt\");\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1BLGtCQUFrQkM7SUFDM0JDLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0csYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ2hCO0FBQ0o7QUFDTyxTQUFTRyxZQUFZQyxLQUFLO0lBQzdCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsbUJBQW1CQTtBQUM3RTtBQUNBOzs7Ozs7Ozs7Q0FTQyxHQUNNLE1BQU1DLHFCQUFxQlY7SUFDOUJFLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDL0IsS0FBSyxDQUFDRixTQUFTQyxRQUFRQztRQUN2QixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ08sU0FBU00sZUFBZUYsS0FBSztJQUNoQyxPQUFPRCxZQUFZQyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7Ozs7Ozs7Ozs7OztDQWFDLEdBQ00sTUFBTUsseUJBQXlCWjtJQUNsQ0UsWUFBWUMsT0FBTyxFQUFFVSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDVjtRQUNOLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTSxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNQyx3QkFBd0JkO0lBQ2pDRSxZQUFZQyxPQUFPLEVBQUVJ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QyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNeUIsNEJBQTRCbEI7SUFDckNaLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBLFNBQVMsdUJBQXVCLEtBQUs7SUFDL0M7QUFDSixFQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9lcnJvcnMuanM/ZGRlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgZXJyb3IgdGhyb3duIGJ5IFN1cGFiYXNlIEF1dGggaGVscGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoRXJyb3IoJ1VuZXhwZWN0ZWQgYXV0aCBlcnJvcicsIDUwMCwgJ3VuZXhwZWN0ZWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNBdXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNBdXRoRXJyb3InIGluIGVycm9yO1xufVxuLyoqXG4gKiBFcnJvciByZXR1cm5lZCBkaXJlY3RseSBmcm9tIHRoZSBHb1RydWUgUkVTVCBBUEkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoQXBpRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJywgNDAwLCAnaW52YWxpZF9jcmVkZW50aWFscycpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoQXBpRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InO1xufVxuLyoqXG4gKiBXcmFwcyBub24tc3RhbmRhcmQgZXJyb3JzIHNvIGNhbGxlcnMgY2FuIGluc3BlY3QgdGhlIHJvb3QgY2F1c2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoVW5rbm93bkVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdHJ5IHtcbiAqICAgYXdhaXQgc29tZUF1dGhDYWxsKClcbiAqIH0gY2F0Y2ggKGVycikge1xuICogICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcignQXV0aCBmYWlsZWQnLCBlcnIpXG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhVbmtub3duRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIEZsZXhpYmxlIGVycm9yIGNsYXNzIHVzZWQgdG8gY3JlYXRlIG5hbWVkIGF1dGggZXJyb3JzIGF0IHJ1bnRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDdXN0b21BdXRoRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQ3VzdG9tQXV0aEVycm9yKCdNeSBjdXN0b20gYXV0aCBlcnJvcicsICdNeUF1dGhFcnJvcicsIDQwMCwgJ2N1c3RvbV9jb2RlJylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gcmVxdWlyZXMgYSBzZXNzaW9uIGJ1dCBub25lIGlzIHByZXNlbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJztcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIHRva2VuIHJlc3BvbnNlIGlzIG1hbGZvcm1lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQXV0aCBzZXNzaW9uIG9yIHVzZXIgbWlzc2luZycsICdBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIGVtYWlsL3Bhc3N3b3JkIGNyZWRlbnRpYWxzIGFyZSBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtanMnXG4gKlxuICogdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignRW1haWwgb3IgcGFzc3dvcmQgaXMgaW5jb3JyZWN0JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3InLCA0MDAsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBpbXBsaWNpdCBncmFudCByZWRpcmVjdHMgY29udGFpbiBhbiBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ09BdXRoIHJlZGlyZWN0IGZhaWxlZCcsIHtcbiAqICAgZXJyb3I6ICdhY2Nlc3NfZGVuaWVkJyxcbiAqICAgY29kZTogJ29hdXRoX2Vycm9yJyxcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gZHVyaW5nIFBLQ0UgY29kZSBleGNoYW5nZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdQS0NFIGV4Y2hhbmdlIGZhaWxlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGV0YWlscyA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvcicsIDUwMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IHRoaXMuZGV0YWlscyxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBQS0NFIGNvZGUgdmVyaWZpZXIgaXMgbm90IGZvdW5kIGluIHN0b3JhZ2UuXG4gKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gdGhlIGF1dGggZmxvdyB3YXMgaW5pdGlhdGVkIGluIGEgZGlmZmVyZW50XG4gKiBicm93c2VyLCBkZXZpY2UsIG9yIHRoZSBzdG9yYWdlIHdhcyBjbGVhcmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3IoKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdQS0NFIGNvZGUgdmVyaWZpZXIgbm90IGZvdW5kIGluIHN0b3JhZ2UuICcgK1xuICAgICAgICAgICAgJ1RoaXMgY2FuIGhhcHBlbiBpZiB0aGUgYXV0aCBmbG93IHdhcyBpbml0aWF0ZWQgaW4gYSBkaWZmZXJlbnQgYnJvd3NlciBvciBkZXZpY2UsICcgK1xuICAgICAgICAgICAgJ29yIGlmIHRoZSBzdG9yYWdlIHdhcyBjbGVhcmVkLiBGb3IgU1NSIGZyYW1ld29ya3MgKE5leHQuanMsIFN2ZWx0ZUtpdCwgZXRjLiksICcgK1xuICAgICAgICAgICAgJ3VzZSBAc3VwYWJhc2Uvc3NyIG9uIGJvdGggdGhlIHNlcnZlciBhbmQgY2xpZW50IHRvIHN0b3JlIHRoZSBjb2RlIHZlcmlmaWVyIGluIGNvb2tpZXMuJywgJ0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yJywgNDAwLCAncGtjZV9jb2RlX3ZlcmlmaWVyX25vdF9mb3VuZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFBLQ0VDb2RlVmVyaWZpZXJNaXNzaW5nRXJyb3InO1xufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHRyYW5zaWVudCBmZXRjaCBpc3N1ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcignU2VydmljZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZScsIDUwMylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFJldHJ5YWJsZUZldGNoRXJyb3InLCBzdGF0dXMsIHVuZGVmaW5lZCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcic7XG59XG4vKipcbiAqIFRoaXMgZXJyb3IgaXMgdGhyb3duIG9uIGNlcnRhaW4gbWV0aG9kcyB3aGVuIHRoZSBwYXNzd29yZCB1c2VkIGlzIGRlZW1lZFxuICogd2Vhay4gSW5zcGVjdCB0aGUgcmVhc29ucyB0byBpZGVudGlmeSB3aGF0IHBhc3N3b3JkIHN0cmVuZ3RoIHJ1bGVzIGFyZVxuICogaW5hZGVxdWF0ZS5cbiAqL1xuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiBhIHN1cHBsaWVkIHBhc3N3b3JkIGlzIGNvbnNpZGVyZWQgd2Vhay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhXZWFrUGFzc3dvcmRFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoJ1Bhc3N3b3JkIHRvbyBzaG9ydCcsIDQwMCwgWydtaW5fbGVuZ3RoJ10pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhXZWFrUGFzc3dvcmRFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCByZWFzb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InLCBzdGF0dXMsICd3ZWFrX3Bhc3N3b3JkJyk7XG4gICAgICAgIHRoaXMucmVhc29ucyA9IHJlYXNvbnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aFdlYWtQYXNzd29yZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzQXV0aEVycm9yKGVycm9yKSAmJiBlcnJvci5uYW1lID09PSAnQXV0aFdlYWtQYXNzd29yZEVycm9yJztcbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gYSBKV1QgY2Fubm90IGJlIHZlcmlmaWVkIG9yIHBhcnNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEF1dGhJbnZhbGlkSnd0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignVG9rZW4gc2lnbmF0dXJlIGlzIGludmFsaWQnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZEp3dEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoSW52YWxpZEp3dEVycm9yJywgNDAwLCAnaW52YWxpZF9qd3QnKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbIkF1dGhFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwic3RhdHVzIiwiY29kZSIsIl9faXNBdXRoRXJyb3IiLCJuYW1lIiwiaXNBdXRoRXJyb3IiLCJlcnJvciIsIkF1dGhBcGlFcnJvciIsImlzQXV0aEFwaUVycm9yIiwiQXV0aFVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJDdXN0b21BdXRoRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsInVuZGVmaW5lZCIsImlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IiLCJBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciIsIkF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciIsIkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsImRldGFpbHMiLCJ0b0pTT04iLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsIkF1dGhQS0NFQ29kZVZlcmlmaWVyTWlzc2luZ0Vycm9yIiwiaXNBdXRoUEtDRUNvZGVWZXJpZmllck1pc3NpbmdFcnJvciIsIkF1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsIkF1dGhXZWFrUGFzc3dvcmRFcnJvciIsInJlYXNvbnMiLCJpc0F1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__rest)(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNxQztBQUNtQjtBQUM2QztBQUNwSSxNQUFNVyxtQkFBbUIsQ0FBQ0MsTUFBUUEsSUFBSUMsR0FBRyxJQUFJRCxJQUFJRSxPQUFPLElBQUlGLElBQUlHLGlCQUFpQixJQUFJSCxJQUFJSSxLQUFLLElBQUlDLEtBQUtDLFNBQVMsQ0FBQ047QUFDakgsTUFBTU8sc0JBQXNCO0lBQUM7SUFBSztJQUFLO0NBQUk7QUFDcEMsZUFBZUMsWUFBWUosS0FBSztJQUNuQyxJQUFJSztJQUNKLElBQUksQ0FBQ2pCLGdFQUFzQkEsQ0FBQ1ksUUFBUTtRQUNoQyxNQUFNLElBQUlULDREQUF1QkEsQ0FBQ0ksaUJBQWlCSyxRQUFRO0lBQy9EO0lBQ0EsSUFBSUcsb0JBQW9CRyxRQUFRLENBQUNOLE1BQU1PLE1BQU0sR0FBRztRQUM1Qyw2RUFBNkU7UUFDN0UsTUFBTSxJQUFJaEIsNERBQXVCQSxDQUFDSSxpQkFBaUJLLFFBQVFBLE1BQU1PLE1BQU07SUFDM0U7SUFDQSxJQUFJQztJQUNKLElBQUk7UUFDQUEsT0FBTyxNQUFNUixNQUFNUyxJQUFJO0lBQzNCLEVBQ0EsT0FBT0MsR0FBRztRQUNOLE1BQU0sSUFBSWpCLHFEQUFnQkEsQ0FBQ0UsaUJBQWlCZSxJQUFJQTtJQUNwRDtJQUNBLElBQUlDLFlBQVlDO0lBQ2hCLE1BQU1DLHFCQUFxQnhCLGlFQUF1QkEsQ0FBQ1c7SUFDbkQsSUFBSWEsc0JBQ0FBLG1CQUFtQkMsT0FBTyxNQUFNN0Isb0RBQVksQ0FBQyxhQUFhLENBQUM4QixTQUFTLElBQ3BFLE9BQU9QLFNBQVMsWUFDaEJBLFFBQ0EsT0FBT0EsS0FBS1EsSUFBSSxLQUFLLFVBQVU7UUFDL0JMLFlBQVlILEtBQUtRLElBQUk7SUFDekIsT0FDSyxJQUFJLE9BQU9SLFNBQVMsWUFBWUEsUUFBUSxPQUFP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QUNVLGFBQWEsR0FBR1YsS0FBS1UsYUFBYTtJQUNwRDtJQUNBLE9BQU8yQztBQUNYO0FBQ08sU0FBU0MsY0FBY3RELElBQUk7SUFDOUIsSUFBSUg7SUFDSixNQUFNc0QsT0FBTyxDQUFDdEQsS0FBS0csS0FBS21ELElBQUksTUFBTSxRQUFRdEQsT0FBTyxLQUFLLElBQUlBLEtBQUtHO0lBQy9ELE9BQU87UUFBRUEsTUFBTTtZQUFFbUQ7UUFBSztRQUFHM0QsT0FBTztJQUFLO0FBQ3pDO0FBQ08sU0FBUytELGFBQWF2RCxJQUFJO0lBQzdCLE9BQU87UUFBRUE7UUFBTVIsT0FBTztJQUFLO0FBQy9CO0FBQ08sU0FBU2dFLHNCQUFzQnhELElBQUk7SUFDdEMsTUFBTSxFQUFFeUQsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHN0QsTUFBTThELE9BQU90Riw2Q0FBTUEsQ0FBQ3dCLE1BQU07UUFBQztRQUFlO1FBQWE7UUFBZ0I7UUFBZTtLQUFvQjtJQUMzTCxNQUFNK0QsYUFBYTtRQUNmTjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsTUFBTVYsT0FBTzFCLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdvQztJQUMvQixPQUFPO1FBQ0g5RCxNQUFNO1lBQ0YrRDtZQUNBWjtRQUNKO1FBQ0EzRCxPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVN3RSx1QkFBdUJoRSxJQUFJO0lBQ3ZDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU2dELFdBQVdoRCxJQUFJO0lBQ3BCLE9BQU9BLEtBQUtpRSxZQUFZLElBQUlqRSxLQUFLa0UsYUFBYSxJQUFJbEUsS0FBS2tELFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanM/MDIzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OUywgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBleHBpcmVzQXQsIGxvb2tzTGlrZUZldGNoUmVzcG9uc2UsIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IEF1dGhBcGlFcnJvciwgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsIEF1dGhXZWFrUGFzc3dvcmRFcnJvciwgQXV0aFVua25vd25FcnJvciwgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsIH0gZnJvbSAnLi9lcnJvcnMnO1xuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnIpID0+IGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpO1xuY29uc3QgTkVUV09SS19FUlJPUl9DT0RFUyA9IFs1MDIsIDUwMywgNTA0XTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWxvb2tzTGlrZUZldGNoUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgMCk7XG4gICAgfVxuICAgIGlmIChORVRXT1JLX0VSUk9SX0NPREVTLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgLy8gc3RhdHVzIGluIDUwMC4uLjU5OSByYW5nZSAtIHNlcnZlciBoYWQgYW4gZXJyb3IsIHJlcXVlc3QgbWlnaHQgYmUgcmV0cnllZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvci5zdGF0dXMpO1xuICAgIH1cbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gYXdhaXQgZXJyb3IuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCBlKTtcbiAgICB9XG4gICAgbGV0IGVycm9yQ29kZSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXNwb25zZUFQSVZlcnNpb24gPSBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihlcnJvcik7XG4gICAgaWYgKHJlc3BvbnNlQVBJVmVyc2lvbiAmJlxuICAgICAgICByZXNwb25zZUFQSVZlcnNpb24uZ2V0VGltZSgpID49IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLnRpbWVzdGFtcCAmJlxuICAgICAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZGF0YSAmJlxuICAgICAgICB0eXBlb2YgZGF0YS5jb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvckNvZGUgPSBkYXRhLmNvZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICYmIHR5cGVvZiBkYXRhLmVycm9yX2NvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuZXJyb3JfY29kZTtcbiAgICB9XG4gICAgaWYgKCFlcnJvckNvZGUpIHtcbiAgICAgICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHdlYWsgcGFzc3dvcmQgZXJyb3JzLCB3aGVuIHRoZXJlIHdlcmUgbm8gZXJyb3IgY29kZXNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YSAmJlxuICAgICAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzLCBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnd2Vha19wYXNzd29yZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsICgoX2EgPSBkYXRhLndlYWtfcGFzc3dvcmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFzb25zKSB8fCBbXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gJ3Nlc3Npb25fbm90X2ZvdW5kJykge1xuICAgICAgICAvLyBUaGUgYHNlc3Npb25faWRgIGluc2lkZSB0aGUgSldUIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSByb3cgaW4gdGhlXG4gICAgICAgIC8vIGBzZXNzaW9uc2AgdGFibGUuIFRoaXMgdXN1YWxseSBtZWFucyB0aGUgdXNlciBoYXMgc2lnbmVkIG91dCwgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVsZXRlZCwgb3IgdGhlaXIgc2Vzc2lvbiBoYXMgc29tZWhvdyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cyB8fCA1MDAsIGVycm9yQ29kZSk7XG59XG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IG1ldGhvZCwgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBwYXJhbWV0ZXJzKTtcbn07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3JlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoIWhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdKSB7XG4gICAgICAgIGhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdID0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10ubmFtZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5qd3QpIHtcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke29wdGlvbnMuand0fWA7XG4gICAgfVxuICAgIGNvbnN0IHFzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8pIHtcbiAgICAgICAgcXNbJ3JlZGlyZWN0X3RvJ10gPSBvcHRpb25zLnJlZGlyZWN0VG87XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gT2JqZWN0LmtleXMocXMpLmxlbmd0aCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocXMpLnRvU3RyaW5nKCkgOiAnJztcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwgKyBxdWVyeVN0cmluZywge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBub1Jlc29sdmVKc29uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbixcbiAgICB9LCB7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpO1xuICAgIHJldHVybiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKSA/IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy54Zm9ybShkYXRhKSA6IHsgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIGVycm9yOiBudWxsIH07XG59XG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hlcih1cmwsIE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RQYXJhbXMpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgLy8gZmV0Y2ggZmFpbGVkLCBsaWtlbHkgZHVlIHRvIGEgbmV0d29yayBvciBDT1JTIGVycm9yXG4gICAgICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCAwKTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICBpZiAoaGFzU2Vzc2lvbihkYXRhKSkge1xuICAgICAgICBzZXNzaW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgIGlmICghZGF0YS5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICBzZXNzaW9uLmV4cGlyZXNfYXQgPSBleHBpcmVzQXQoZGF0YS5leHBpcmVzX2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1c2VyID0gKF9hID0gZGF0YS51c2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhO1xuICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgdXNlciB9LCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZChkYXRhKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpO1xuICAgIGlmICghcmVzcG9uc2UuZXJyb3IgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSAmJlxuICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYSwgaSkgPT4gYSAmJiB0eXBlb2YgaSA9PT0gJ3N0cmluZycsIHRydWUpKSB7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEud2Vha19wYXNzd29yZCA9IGRhdGEud2Vha19wYXNzd29yZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF91c2VyUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB1c2VyID0gKF9hID0gZGF0YS51c2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhO1xuICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9zc29SZXNwb25zZShkYXRhKSB7XG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHsgYWN0aW9uX2xpbmssIGVtYWlsX290cCwgaGFzaGVkX3Rva2VuLCByZWRpcmVjdF90bywgdmVyaWZpY2F0aW9uX3R5cGUgfSA9IGRhdGEsIHJlc3QgPSBfX3Jlc3QoZGF0YSwgW1wiYWN0aW9uX2xpbmtcIiwgXCJlbWFpbF9vdHBcIiwgXCJoYXNoZWRfdG9rZW5cIiwgXCJyZWRpcmVjdF90b1wiLCBcInZlcmlmaWNhdGlvbl90eXBlXCJdKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBhY3Rpb25fbGluayxcbiAgICAgICAgZW1haWxfb3RwLFxuICAgICAgICBoYXNoZWRfdG9rZW4sXG4gICAgICAgIHJlZGlyZWN0X3RvLFxuICAgICAgICB2ZXJpZmljYXRpb25fdHlwZSxcbiAgICB9O1xuICAgIGNvbnN0IHVzZXIgPSBPYmplY3QuYXNzaWduKHt9LCByZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogaGFzU2Vzc2lvbiBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIG9iamVjdCBjb250YWlucyBhIHZhbGlkIHNlc3Npb25cbiAqIEBwYXJhbSBkYXRhIEEgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgc2Vzc2lvbiBpcyBpbiB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFzU2Vzc2lvbihkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuYWNjZXNzX3Rva2VuICYmIGRhdGEucmVmcmVzaF90b2tlbiAmJiBkYXRhLmV4cGlyZXNfaW47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiX19yZXN0IiwiQVBJX1ZFUlNJT05TIiwiQVBJX1ZFUlNJT05fSEVBREVSX05BTUUiLCJleHBpcmVzQXQiLCJsb29rc0xpa2VGZXRjaFJlc3BvbnNlIiwicGFyc2VSZXNwb25zZUFQSVZlcnNpb24iLCJBdXRoQXBpRXJyb3IiLCJBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsIkF1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIl9nZXRFcnJvck1lc3NhZ2UiLCJlcnIiLCJtc2ciLCJtZXNzYWdlIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJORVRXT1JLX0VSUk9SX0NPREVTIiwiaGFuZGxlRXJyb3IiLCJfYSIsImluY2x1ZGVzIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJlIiwiZXJyb3JDb2RlIiwidW5kZWZpbmVkIiwicmVzcG9uc2VBUElWZXJzaW9uIiwiZ2V0VGltZSIsInRpbWVzdGFtcCIsImNvZGUiLCJlcnJvcl9jb2RlIiwid2Vha19wYXNzd29yZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYXNvbnMiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhIiwiaSIsIl9nZXRSZXF1ZXN0UGFyYW1zIiwibWV0aG9kIiwib3B0aW9ucyIsInBhcmFtZXRlcnMiLCJib2R5IiwicGFyYW1zIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsIl9yZXF1ZXN0IiwiZmV0Y2hlciIsInVybCIsIm5hbWUiLCJqd3QiLCJxcyIsInF1ZXJ5IiwicmVkaXJlY3RUbyIsInF1ZXJ5U3RyaW5nIiwia2V5cyIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwiX2hhbmRsZVJlcXVlc3QiLCJub1Jlc29sdmVKc29uIiwieGZvcm0iLCJyZXF1ZXN0UGFyYW1zIiwicmVzdWx0IiwiY29uc29sZSIsIm9rIiwiX3Nlc3Npb25SZXNwb25zZSIsInNlc3Npb24iLCJoYXNTZXNzaW9uIiwiZXhwaXJlc19hdCIsImV4cGlyZXNfaW4iLCJ1c2VyIiwiX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkIiwicmVzcG9uc2UiLCJfdXNlclJlc3BvbnNlIiwiX3Nzb1Jlc3BvbnNlIiwiX2dlbmVyYXRlTGlua1Jlc3BvbnNlIiwiYWN0aW9uX2xpbmsiLCJlbWFpbF9vdHAiLCJoYXNoZWRfdG9rZW4iLCJyZWRpcmVjdF90byIsInZlcmlmaWNhdGlvbl90eXBlIiwicmVzdCIsInByb3BlcnRpZXMiLCJfbm9SZXNvbHZlSnNvblJlc3BvbnNlIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaF90b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generateCallbackId: () => (/* binding */ generateCallbackId),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getAlgorithm: () => (/* binding */ getAlgorithm),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   insecureUserWarningProxy: () => (/* binding */ insecureUserWarningProxy),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   userNotAvailableProxy: () => (/* binding */ userNotAvailableProxy),\n/* harmony export */   validateExp: () => (/* binding */ validateExp),\n/* harmony export */   validateUUID: () => (/* binding */ validateUUID)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\n/**\n * Generates a unique identifier for internal callback subscriptions.\n *\n * This function uses JavaScript Symbols to create guaranteed-unique identifiers\n * for auth state change callbacks. Symbols are ideal for this use case because:\n * - They are guaranteed unique by the JavaScript runtime\n * - They work in all environments (browser, SSR, Node.js)\n * - They avoid issues with Next.js 16 deterministic rendering requirements\n * - They are perfect for internal, non-serializable identifiers\n *\n * Note: This function is only used for internal subscription management,\n * not for security-critical operations like session tokens.\n */ function generateCallbackId() {\n    return Symbol(\"auth-callback\");\n}\nconst isBrowser = ()=> false && 0;\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return (...args)=>customFetch(...args);\n    }\n    return (...args)=>fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"Invalid JWT structure\");\n    }\n    // Regex checks for base64url format\n    for(let i = 0; i < parts.length; i++){\n        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"JWT not in base64url format\");\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),\n        signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1]\n        }\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    } catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error(\"Missing exp claim\");\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error(\"JWT has expired\");\n    }\n}\nfunction getAlgorithm(alg) {\n    switch(alg){\n        case \"RS256\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        case \"ES256\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        default:\n            throw new Error(\"Invalid alg claim\");\n    }\n}\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\nfunction validateUUID(str) {\n    if (!UUID_REGEX.test(str)) {\n        throw new Error(\"@supabase/auth-js: Expected parameter to be UUID but is not\");\n    }\n}\nfunction userNotAvailableProxy() {\n    const proxyTarget = {};\n    return new Proxy(proxyTarget, {\n        get: (target, prop)=>{\n            if (prop === \"__isUserNotAvailableProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms.\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\") {\n                    // Node.js util.inspect\n                    return undefined;\n                }\n            }\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"${prop}\" property of the session object is not supported. Please use getUser() instead.`);\n        },\n        set: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        },\n        deleteProperty: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        }\n    });\n}\n/**\n * Creates a proxy around a user object that warns when properties are accessed on the server.\n * This is used to alert developers that using user data from getSession() on the server is insecure.\n *\n * @param user The actual user object to wrap\n * @param suppressWarningRef An object with a 'value' property that controls warning suppression\n * @returns A proxied user object that warns on property access\n */ function insecureUserWarningProxy(user, suppressWarningRef) {\n    return new Proxy(user, {\n        get: (target, prop, receiver)=>{\n            // Allow internal checks without warning\n            if (prop === \"__isInsecureUserWarningProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\" || sProp === \"Symbol(nodejs.util.inspect.custom)\") {\n                    // Return the actual value for these symbols to allow proper inspection\n                    return Reflect.get(target, prop, receiver);\n                }\n            }\n            // Emit warning on first property access\n            if (!suppressWarningRef.value && typeof prop === \"string\") {\n                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                suppressWarningRef.value = true;\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\n/**\n * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).\n * Note: Only works for JSON-safe data.\n */ function deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ3hCO0FBQzBCO0FBQ2xFLFNBQVNLLFVBQVVDLFNBQVM7SUFDL0IsTUFBTUMsVUFBVUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7SUFDeEMsT0FBT0osVUFBVUQ7QUFDckI7QUFDQTs7Ozs7Ozs7Ozs7O0NBWUMsR0FDTSxTQUFTTTtJQUNaLE9BQU9DLE9BQU87QUFDbEI7QUFDTyxNQUFNQyxZQUFZLElBQU0sTUFBa0IsSUFBZSxDQUFvQixDQUFZO0FBQ2hHLE1BQU1FLHlCQUF5QjtJQUMzQkMsUUFBUTtJQUNSQyxVQUFVO0FBQ2Q7QUFDQTs7Q0FFQyxHQUNNLE1BQU1DLHVCQUF1QjtJQUNoQyxJQUFJLENBQUNMLGFBQWE7UUFDZCxPQUFPO0lBQ1g7SUFDQSxJQUFJO1FBQ0EsSUFBSSxPQUFPTSxXQUFXQyxZQUFZLEtBQUssVUFBVTtZQUM3QyxPQUFPO1FBQ1g7SUFDSixFQUNBLE9BQU9DLEdBQUc7UUFDTiw4Q0FBOEM7UUFDOUMsT0FBTztJQUNYO0lBQ0EsSUFBSU4sdUJBQXVCQyxNQUFNLEVBQUU7UUFDL0IsT0FBT0QsdUJBQXVCRSxRQUFRO0lBQzFDO0lBQ0EsTUFBTUssWUFBWSxDQUFDLEtBQUssRUFBRWYsS0FBS2dCLE1BQU0sR0FBRyxFQUFFaEIsS0FBS2dCLE1BQU0sR0FBRyxDQUFDO0lBQ3pELElBQUk7UUFDQUosV0FBV0MsWUFBWSxDQUFDSSxPQUFPLENBQUNGLFdBQVdBO1FBQzNDSCxXQUFXQyxZQUFZLENBQUNLLFVBQVUsQ0FBQ0g7UUFDbkNQLHVCQUF1QkMsTUFBTSxHQUFHO1FBQ2hDRCx1QkFBdUJFLFFBQVEsR0FBRztJQUN0QyxFQUNBLE9BQU9JLEdBQUc7UUFDTixtQ0FBbUM7UUFDbkMsK0tBQStLO1FBQy9LTix1QkFB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O2dCQUMxQixNQUFNQyxRQUFRRCxLQUFLbEUsUUFBUTtnQkFDM0IsSUFBSW1FLFVBQVUsZ0NBQ1ZBLFVBQVUsZ0NBQ1ZBLFVBQVUsaUNBQ1ZBLFVBQVUsc0NBQXNDO29CQUNoRCx1RUFBdUU7b0JBQ3ZFLE9BQU9TLFFBQVEzQixHQUFHLENBQUNnQixRQUFRQyxNQUFNUztnQkFDckM7WUFDSjtZQUNBLHdDQUF3QztZQUN4QyxJQUFJLENBQUNELG1CQUFtQjdILEtBQUssSUFBSSxPQUFPcUgsU0FBUyxVQUFVO2dCQUN2RGxDLFFBQVFDLElBQUksQ0FBQztnQkFDYnlDLG1CQUFtQjdILEtBQUssR0FBRztZQUMvQjtZQUNBLE9BQU8rSCxRQUFRM0IsR0FBRyxDQUFDZ0IsUUFBUUMsTUFBTVM7UUFDckM7SUFDSjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0UsVUFBVUMsR0FBRztJQUN6QixPQUFPcEgsS0FBS0ksS0FBSyxDQUFDSixLQUFLQyxTQUFTLENBQUNtSDtBQUNyQyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9oZWxwZXJzLmpzPzVhNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUsIEJBU0U2NFVSTF9SRUdFWCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IEF1dGhJbnZhbGlkSnd0RXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBiYXNlNjRVcmxUb1VpbnQ4QXJyYXksIHN0cmluZ0Zyb21CYXNlNjRVUkwgfSBmcm9tICcuL2Jhc2U2NHVybCc7XG5leHBvcnQgZnVuY3Rpb24gZXhwaXJlc0F0KGV4cGlyZXNJbikge1xuICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICByZXR1cm4gdGltZU5vdyArIGV4cGlyZXNJbjtcbn1cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGludGVybmFsIGNhbGxiYWNrIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB1c2VzIEphdmFTY3JpcHQgU3ltYm9scyB0byBjcmVhdGUgZ3VhcmFudGVlZC11bmlxdWUgaWRlbnRpZmllcnNcbiAqIGZvciBhdXRoIHN0YXRlIGNoYW5nZSBjYWxsYmFja3MuIFN5bWJvbHMgYXJlIGlkZWFsIGZvciB0aGlzIHVzZSBjYXNlIGJlY2F1c2U6XG4gKiAtIFRoZXkgYXJlIGd1YXJhbnRlZWQgdW5pcXVlIGJ5IHRoZSBKYXZhU2NyaXB0IHJ1bnRpbWVcbiAqIC0gVGhleSB3b3JrIGluIGFsbCBlbnZpcm9ubWVudHMgKGJyb3dzZXIsIFNTUiwgTm9kZS5qcylcbiAqIC0gVGhleSBhdm9pZCBpc3N1ZXMgd2l0aCBOZXh0LmpzIDE2IGRldGVybWluaXN0aWMgcmVuZGVyaW5nIHJlcXVpcmVtZW50c1xuICogLSBUaGV5IGFyZSBwZXJmZWN0IGZvciBpbnRlcm5hbCwgbm9uLXNlcmlhbGl6YWJsZSBpZGVudGlmaWVyc1xuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIGZvciBpbnRlcm5hbCBzdWJzY3JpcHRpb24gbWFuYWdlbWVudCxcbiAqIG5vdCBmb3Igc2VjdXJpdHktY3JpdGljYWwgb3BlcmF0aW9ucyBsaWtlIHNlc3Npb24gdG9rZW5zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDYWxsYmFja0lkKCkge1xuICAgIHJldHVybiBTeW1ib2woJ2F1dGgtY2FsbGJhY2snKTtcbn1cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSAoKSA9PiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cyA9IHtcbiAgICB0ZXN0ZWQ6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbn07XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGxvY2FsU3RvcmFnZSBpcyBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLlxuICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRE9NIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZyBgbG9jYWxTdG9yYWdlYFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCkge1xuICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbiAgICB9XG4gICAgY29uc3QgcmFuZG9tS2V5ID0gYGxzd3QtJHtNYXRoLnJhbmRvbSgpfSR7TWF0aC5yYW5kb20oKX1gO1xuICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0ocmFuZG9tS2V5LCByYW5kb21LZXkpO1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHJhbmRvbUtleSk7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGxvY2FsU3RvcmFnZSBjYW4ndCBiZSB3cml0dGVuIHRvXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LmNocm9taXVtLm9yZy9mb3ItdGVzdGVycy9idWctcmVwb3J0aW5nLWd1aWRlbGluZXMvdW5jYXVnaHQtc2VjdXJpdHllcnJvci1mYWlsZWQtdG8tcmVhZC10aGUtbG9jYWxzdG9yYWdlLXByb3BlcnR5LWZyb20td2luZG93LWFjY2Vzcy1pcy1kZW5pZWQtZm9yLXRoaXMtZG9jdW1lbnRcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQgPSB0cnVlO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLndyaXRhYmxlO1xufTtcbi8qKlxuICogRXh0cmFjdHMgcGFyYW1ldGVycyBlbmNvZGVkIGluIHRoZSBVUkwgYm90aCBpbiB0aGUgcXVlcnkgYW5kIGZyYWdtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXJzRnJvbVVSTChocmVmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChocmVmKTtcbiAgICBpZiAodXJsLmhhc2ggJiYgdXJsLmhhc2hbMF0gPT09ICcjJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFzaFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLmhhc2guc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIGhhc2hTZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaGFzaCBpcyBub3QgYSBxdWVyeSBzdHJpbmdcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzZWFyY2ggcGFyYW1ldGVycyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBoYXNoIHBhcmFtZXRlcnNcbiAgICB1cmwuc2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlLmpzb24gPT09ICdmdW5jdGlvbicpO1xufTtcbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXksIGRhdGEpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5EZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVCh0b2tlbikge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUJBU0U2NFVSTF9SRUdFWC50ZXN0KHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXVCBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC8vIHVzaW5nIGJhc2U2NHVybCBsaWJcbiAgICAgICAgaGVhZGVyOiBKU09OLnBhcnNlKHN0cmluZ0Zyb21CYXNlNjRVUkwocGFydHNbMF0pKSxcbiAgICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzFdKSksXG4gICAgICAgIHNpZ25hdHVyZTogYmFzZTY0VXJsVG9VaW50OEFycmF5KHBhcnRzWzJdKSxcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogcGFydHNbMV0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGUoZm4sIGlzUmV0cnlhYmxlKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGVjMmhleChkZWMpIHtcbiAgICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMik7XG59XG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gICAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+JztcbiAgICAgICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoO1xuICAgICAgICBsZXQgdmVyaWZpZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJyk7XG59XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKTtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUEtDRUNoYWxsZW5nZSh2ZXJpZmllcikge1xuICAgIGNvbnN0IGhhc0NyeXB0b1N1cHBvcnQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXZWJDcnlwdG8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIENvZGUgY2hhbGxlbmdlIG1ldGhvZCB3aWxsIGRlZmF1bHQgdG8gdXNlIHBsYWluIGluc3RlYWQgb2Ygc2hhMjU2LicpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcik7XG4gICAgcmV0dXJuIGJ0b2EoaGFzaGVkKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChzdG9yYWdlLCBzdG9yYWdlS2V5LCBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKCk7XG4gICAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllcjtcbiAgICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgICAgIHN0b3JlZENvZGVWZXJpZmllciArPSAnL1BBU1NXT1JEX1JFQ09WRVJZJztcbiAgICB9XG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2JztcbiAgICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdO1xufVxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKTtcbiAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghYXBpVmVyc2lvbi5tYXRjaChBUElfVkVSU0lPTl9SRUdFWCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRXhwKGV4cCkge1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHAgY2xhaW0nKTtcbiAgICB9XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGlmIChleHAgPD0gdGltZU5vdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBoYXMgZXhwaXJlZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGdvcml0aG0oYWxnKSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbGcgY2xhaW0nKTtcbiAgICB9XG59XG5jb25zdCBVVUlEX1JFR0VYID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kLztcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVVSUQoc3RyKSB7XG4gICAgaWYgKCFVVUlEX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBFeHBlY3RlZCBwYXJhbWV0ZXIgdG8gYmUgVVVJRCBidXQgaXMgbm90Jyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZXJOb3RBdmFpbGFibGVQcm94eSgpIHtcbiAgICBjb25zdCBwcm94eVRhcmdldCA9IHt9O1xuICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19faXNVc2VyTm90QXZhaWxhYmxlUHJveHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1Byb3AgPSBwcm9wLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1ByaW1pdGl2ZSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHV0aWwuaW5zcGVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIEFjY2Vzc2luZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIGluc3RlYWQuYCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIFNldHRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHk6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBjbGllbnQgd2FzIGNyZWF0ZWQgd2l0aCB1c2VyU3RvcmFnZSBvcHRpb24gYW5kIHRoZXJlIHdhcyBubyB1c2VyIHN0b3JlZCBpbiB0aGUgdXNlciBzdG9yYWdlLiBEZWxldGluZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIHRvIGZldGNoIGEgdXNlciBvYmplY3QgeW91IGNhbiBtYW5pcHVsYXRlLmApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgYXJvdW5kIGEgdXNlciBvYmplY3QgdGhhdCB3YXJucyB3aGVuIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkIG9uIHRoZSBzZXJ2ZXIuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxlcnQgZGV2ZWxvcGVycyB0aGF0IHVzaW5nIHVzZXIgZGF0YSBmcm9tIGdldFNlc3Npb24oKSBvbiB0aGUgc2VydmVyIGlzIGluc2VjdXJlLlxuICpcbiAqIEBwYXJhbSB1c2VyIFRoZSBhY3R1YWwgdXNlciBvYmplY3QgdG8gd3JhcFxuICogQHBhcmFtIHN1cHByZXNzV2FybmluZ1JlZiBBbiBvYmplY3Qgd2l0aCBhICd2YWx1ZScgcHJvcGVydHkgdGhhdCBjb250cm9scyB3YXJuaW5nIHN1cHByZXNzaW9uXG4gKiBAcmV0dXJucyBBIHByb3hpZWQgdXNlciBvYmplY3QgdGhhdCB3YXJucyBvbiBwcm9wZXJ0eSBhY2Nlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VjdXJlVXNlcldhcm5pbmdQcm94eSh1c2VyLCBzdXBwcmVzc1dhcm5pbmdSZWYpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHVzZXIsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgLy8gQWxsb3cgaW50ZXJuYWwgY2hlY2tzIHdpdGhvdXQgd2FybmluZ1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfX2lzSW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJldmVudGF0aXZlIGNoZWNrIGZvciBjb21tb24gcHJvYmxlbWF0aWMgc3ltYm9scyBkdXJpbmcgY2xvbmluZy9pbnNwZWN0aW9uXG4gICAgICAgICAgICAvLyBUaGVzZSBzeW1ib2xzIG1pZ2h0IGJlIGFjY2Vzc2VkIGJ5IHN0cnVjdHVyZWRDbG9uZSBvciBvdGhlciBpbnRlcm5hbCBtZWNoYW5pc21zXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1Byb3AgPSBwcm9wLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1ByaW1pdGl2ZSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJyB8fFxuICAgICAgICAgICAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbChub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIHZhbHVlIGZvciB0aGVzZSBzeW1ib2xzIHRvIGFsbG93IHByb3BlciBpbnNwZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IHdhcm5pbmcgb24gZmlyc3QgcHJvcGVydHkgYWNjZXNzXG4gICAgICAgICAgICBpZiAoIXN1cHByZXNzV2FybmluZ1JlZi52YWx1ZSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgIHN1cHByZXNzV2FybmluZ1JlZi52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIERlZXAgY2xvbmVzIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHVzaW5nIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkuXG4gKiBOb3RlOiBPbmx5IHdvcmtzIGZvciBKU09OLXNhZmUgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiQkFTRTY0VVJMX1JFR0VYIiwiQXV0aEludmFsaWRKd3RFcnJvciIsImJhc2U2NFVybFRvVWludDhBcnJheSIsInN0cmluZ0Zyb21CYXNlNjRVUkwiLCJleHBpcmVzQXQiLCJleHBpcmVzSW4iLCJ0aW1lTm93IiwiTWF0aCIsInJvdW5kIiwiRGF0ZSIsIm5vdyIsImdlbmVyYXRlQ2FsbGJhY2tJZCIsIlN5bWJvbCIsImlzQnJvd3NlciIsImRvY3VtZW50IiwibG9jYWxTdG9yYWdlV3JpdGVUZXN0cyIsInRlc3RlZCIsIndyaXRhYmxlIiwic3VwcG9ydHNMb2NhbFN0b3JhZ2UiLCJnbG9iYWxUaGlzIiwibG9jYWxTdG9yYWdlIiwiZSIsInJhbmRvbUtleSIsInJhbmRvbSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwicGFyc2VQYXJhbWV0ZXJzRnJvbVVSTCIsImhyZWYiLCJyZXN1bHQiLCJ1cmwiLCJVUkwiLCJoYXNoIiwiaGFzaFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInN1YnN0cmluZyIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsInNlYXJjaFBhcmFtcyIsInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwibG9va3NMaWtlRmV0Y2hSZXNwb25zZSIsIm1heWJlUmVzcG9uc2UiLCJqc29uIiwic2V0SXRlbUFzeW5jIiwic3RvcmFnZSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0SXRlbUFzeW5jIiwiZ2V0SXRlbSIsInBhcnNlIiwiX2EiLCJyZW1vdmVJdGVtQXN5bmMiLCJEZWZlcnJlZCIsImNvbnN0cnVjdG9yIiwicHJvbWlzZSIsInByb21pc2VDb25zdHJ1Y3RvciIsInJlcyIsInJlaiIsInJlc29sdmUiLCJyZWplY3QiLCJQcm9taXNlIiwiZGVjb2RlSldUIiwidG9rZW4iLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwiaSIsInRlc3QiLCJoZWFkZXIiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwicmF3Iiwic2xlZXAiLCJ0aW1lIiwiYWNjZXB0Iiwic2V0VGltZW91dCIsInJldHJ5YWJsZSIsImZuIiwiaXNSZXRyeWFibGUiLCJhdHRlbXB0IiwiSW5maW5pdHkiLCJkZWMyaGV4IiwiZGVjIiwidG9TdHJpbmciLCJzdWJzdHIiLCJnZW5lcmF0ZVBLQ0VWZXJpZmllciIsInZlcmlmaWVyTGVuZ3RoIiwiYXJyYXkiLCJVaW50MzJBcnJheSIsImNyeXB0byIsImNoYXJTZXQiLCJjaGFyU2V0TGVuIiwidmVyaWZpZXIiLCJjaGFyQXQiLCJmbG9vciIsImdldFJhbmRvbVZhbHVlcyIsIkFycmF5IiwiZnJvbSIsImpvaW4iLCJzaGEyNTYiLCJyYW5kb21TdHJpbmciLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVkRGF0YSIsImVuY29kZSIsInN1YnRsZSIsImRpZ2VzdCIsImJ5dGVzIiwiVWludDhBcnJheSIsIm1hcCIsImMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UiLCJoYXNDcnlwdG9TdXBwb3J0IiwiY29uc29sZSIsIndhcm4iLCJoYXNoZWQiLCJidG9hIiwicmVwbGFjZSIsImdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QiLCJzdG9yYWdlS2V5IiwiaXNQYXNzd29yZFJlY292ZXJ5IiwiY29kZVZlcmlmaWVyIiwic3RvcmVkQ29kZVZlcmlmaWVyIiwiY29kZUNoYWxsZW5nZSIsImNvZGVDaGFsbGVuZ2VNZXRob2QiLCJBUElfVkVSU0lPTl9SRUdFWCIsInBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIiwicmVzcG9uc2UiLCJhcGlWZXJzaW9uIiwiaGVhZGVycyIsImdldCIsIm1hdGNoIiwiZGF0ZSIsInZhbGlkYXRlRXhwIiwiZXhwIiwiRXJyb3IiLCJnZXRBbGdvcml0aG0iLCJhbGciLCJuYW1lIiwibmFtZWRDdXJ2ZSIsIlVVSURfUkVHRVgiLCJ2YWxpZGF0ZVVVSUQiLCJzdHIiLCJ1c2VyTm90QXZhaWxhYmxlUHJveHkiLCJwcm94eVRhcmdldCIsIlByb3h5IiwidGFyZ2V0IiwicHJvcCIsInNQcm9wIiwidW5kZWZpbmVkIiwic2V0IiwiX3RhcmdldCIsImRlbGV0ZVByb3BlcnR5IiwiaW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5IiwidXNlciIsInN1cHByZXNzV2FybmluZ1JlZiIsInJlY2VpdmVyIiwiUmVmbGVjdCIsImRlZXBDbG9uZSIsIm9iaiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2FsLXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQUNNLFNBQVNBLDBCQUEwQkMsUUFBUSxDQUFDLENBQUM7SUFDaEQsT0FBTztRQUNIQyxTQUFTLENBQUNDO1lBQ04sT0FBT0YsS0FBSyxDQUFDRSxJQUFJLElBQUk7UUFDekI7UUFDQUMsU0FBUyxDQUFDRCxLQUFLRTtZQUNYSixLQUFLLENBQUNFLElBQUksR0FBR0U7UUFDakI7UUFDQUMsWUFBWSxDQUFDSDtZQUNULE9BQU9GLEtBQUssQ0FBQ0UsSUFBSTtRQUNyQjtJQUNKO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcz8yM2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsInN0b3JlIiwiZ2V0SXRlbSIsImtleSIsInNldEl0ZW0iLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */ const internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n *\n * @example\n * ```ts\n * import { LockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * class CustomLockError extends LockAcquireTimeoutError {\n *   constructor() {\n *     super('Lock timed out')\n *   }\n * }\n * ```\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\n/**\n * Error thrown when the browser Navigator Lock API fails to acquire a lock.\n *\n * @example\n * ```ts\n * import { NavigatorLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new NavigatorLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Error thrown when the process-level lock helper cannot acquire a lock.\n *\n * @example\n * ```ts\n * import { ProcessLockAcquireTimeoutError } from '@supabase/auth-js'\n *\n * throw new ProcessLockAcquireTimeoutError('Lock timed out')\n * ```\n */ class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await navigatorLock('sync-user', 1000, async () => {\n *   await refreshSession()\n * })\n * ```\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(()=>globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                } else {\n                    if (internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n * @example\n * ```ts\n * await processLock('migrate', 5000, async () => {\n *   await runMigration()\n * })\n * ```\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(()=>{\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0 ? new Promise((_, reject)=>{\n            setTimeout(()=>{\n                console.warn(`@supabase/gotrue-js: Lock \"${name}\" acquisition timed out after ${acquireTimeout}ms. ` + \"This may be caused by another operation holding the lock. \" + \"Consider increasing lockAcquireTimeout or checking for stuck operations.\");\n                reject(new ProcessLockAcquireTimeoutError(`Acquiring process lock with name \"${name}\" timed out`));\n            }, acquireTimeout);\n        }) : null\n    ].filter((x)=>x)).catch((e)=>{\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    }).then(async ()=>{\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e)=>{\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUQ7QUFDakQ7O0NBRUMsR0FDTSxNQUFNQyxZQUFZO0lBQ3JCOztLQUVDLEdBQ0RDLE9BQU8sQ0FBQyxDQUFFQyxDQUFBQSxjQUNOSCw4REFBb0JBLE1BQ3BCRyxXQUFXQyxZQUFZLElBQ3ZCRCxXQUFXQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxzQ0FBc0MsTUFBSztBQUNuRixFQUFFO0FBQ0Y7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sTUFBTUMsZ0NBQWdDQztJQUN6Q0MsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLGdCQUFnQixHQUFHO0lBQzVCO0FBQ0o7QUFDQTs7Ozs7Ozs7O0NBU0MsR0FDTSxNQUFNQyx5Q0FBeUNMO0FBQ3REO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTU0sdUNBQXVDTjtBQUNwRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E4QkMsR0FDTSxlQUFlTyxjQUFjQyxJQUFJLEVBQUVDLGNBQWMsRUFBRUMsRUFBRTtJQUN4RCxJQUFJZixVQUFVQyxLQUFLLEVBQUU7UUFDakJlLFFBQVFDLEdBQUcsQ0FBQyxvREFBb0RKLE1BQU1DO0lBQzFFO0lBQ0EsTUFBTUksa0JBQWtCLElBQUloQixXQUFXaUIsZUFBZTtJQUN0RCxJQUFJTCxpQkFBaUIsR0FBRztRQUNwQk0sV0FBVztZQUNQRixnQkFBZ0JHLEtBQUs7WUFDckIsSUFBSXJCLFVBQVVDLEtBQUssRUFBRTtnQkFDakJlLFFBQVFDLEdBQUcsQ0FBQyx3REFBd0RKO1lBQ3hFO1FBQ0osR0FBR0M7SUFDUDtJQUNBLG9GQUFvRjtJQUNwRiwwRUFBMEU7SUFDMUUseUVBQXlFO0lBQ3pFLDBFQUEwRTtJQUMxRSwyRUFBMkU7SUFDM0UsNkVBQTZFO0lBQzdFLHdFQUF3RTtJ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QUFNZ0M7WUFDTixPQUFPO1FBQ1g7UUFDQSxNQUFNTDtJQUNWO0lBQ0EseUVBQXlFO0lBQ3pFLHlDQUF5QztJQUN6QyxPQUFPLE1BQU1NO0FBQ2pCLEVBQ0EsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzPzAzODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3VwcG9ydHNMb2NhbFN0b3JhZ2UgfSBmcm9tICcuL2hlbHBlcnMnO1xuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbHMgPSB7XG4gICAgLyoqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGRlYnVnOiAhIShnbG9iYWxUaGlzICYmXG4gICAgICAgIHN1cHBvcnRzTG9jYWxTdG9yYWdlKCkgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UgJiZcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc3VwYWJhc2UuZ290cnVlLWpzLmxvY2tzLmRlYnVnJykgPT09ICd0cnVlJyksXG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhIGxvY2sgY2Fubm90IGJlIGFjcXVpcmVkIGFmdGVyIHNvbWUgYW1vdW50IG9mIHRpbWUuXG4gKlxuICogVXNlIHRoZSB7QGxpbmsgI2lzQWNxdWlyZVRpbWVvdXR9IHByb3BlcnR5IGluc3RlYWQgb2YgY2hlY2tpbmcgd2l0aCBgaW5zdGFuY2VvZmAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIGNsYXNzIEN1c3RvbUxvY2tFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgc3VwZXIoJ0xvY2sgdGltZWQgb3V0JylcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmlzQWNxdWlyZVRpbWVvdXQgPSB0cnVlO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIGJyb3dzZXIgTmF2aWdhdG9yIExvY2sgQVBJIGZhaWxzIHRvIGFjcXVpcmUgYSBsb2NrLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC1qcydcbiAqXG4gKiB0aHJvdyBuZXcgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoJ0xvY2sgdGltZWQgb3V0JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IgZXh0ZW5kcyBMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB7XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBwcm9jZXNzLWxldmVsIGxvY2sgaGVscGVyIGNhbm5vdCBhY3F1aXJlIGEgbG9jay5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJ1xuICpcbiAqIHRocm93IG5ldyBQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IoJ0xvY2sgdGltZWQgb3V0JylcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xufVxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHVzaW5nIHRoZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgQVBJLiBJdFxuICogaXMgYXZhaWxhYmxlIG9uIGFsbCBicm93c2VycyByZWxlYXNlZCBhZnRlciAyMDIyLTAzLTE1IHdpdGggU2FmYXJpIGJlaW5nIHRoZVxuICogbGFzdCBvbmUgdG8gcmVsZWFzZSBzdXBwb3J0LiBJZiB0aGUgQVBJIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgZnVuY3Rpb24gd2lsbFxuICogdGhyb3cuIE1ha2Ugc3VyZSB5b3UgY2hlY2sgYXZhaWxhYmxpbGl0eSBiZWZvcmUgY29uZmlndXJpbmcge0BsaW5rXG4gKiBHb1RydWVDbGllbnR9LlxuICpcbiAqIFlvdSBjYW4gdHVybiBvbiBkZWJ1Z2dpbmcgYnkgc2V0dGluZyB0aGUgYHN1cGFiYXNlLmdvdHJ1ZS1qcy5sb2Nrcy5kZWJ1Z2BcbiAqIGxvY2FsIHN0b3JhZ2UgaXRlbSB0byBgdHJ1ZWAuXG4gKlxuICogSW50ZXJuYWxzOlxuICpcbiAqIFNpbmNlIHRoZSBMb2NrTWFuYWdlciBBUEkgZG9lcyBub3QgcHJlc2VydmUgc3RhY2sgdHJhY2VzIGZvciB0aGUgYXN5bmNcbiAqIGZ1bmN0aW9uIHBhc3NlZCBpbiB0aGUgYHJlcXVlc3RgIG1ldGhvZCwgYSB0cmljayBpcyB1c2VkIHdoZXJlIGFjcXVpcmluZyB0aGVcbiAqIGxvY2sgcmVsZWFzZXMgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgcHJvbWlzZSB0byBydW4gdGhlIG9wZXJhdGlvbiBpbiB0aGUgYGZuYFxuICogZnVuY3Rpb24uIFRoZSBsb2NrIHdhaXRzIGZvciB0aGF0IHByb21pc2UgdG8gZmluaXNoICh3aXRoIG9yIHdpdGhvdXQgZXJyb3IpLFxuICogd2hpbGUgdGhlIGZ1bmN0aW9uIHdpbGwgZmluYWxseSB3YWl0IGZvciB0aGUgcmVzdWx0IGFueXdheS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGF3YWl0IG5hdmlnYXRvckxvY2soJ3N5bmMtdXNlcicsIDEwMDAsIGFzeW5jICgpID0+IHtcbiAqICAgYXdhaXQgcmVmcmVzaFNlc3Npb24oKVxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdG9yTG9jayhuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlIGxvY2snLCBuYW1lLCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmIChhY3F1aXJlVGltZW91dCA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIC8vIE1ETiBhcnRpY2xlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdFxuICAgIC8vIFdyYXBwaW5nIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgd2l0aCBhIHBsYWluIFByb21pc2UgaXMgZG9uZSBhcyBzb21lXG4gICAgLy8gbGlicmFyaWVzIGxpa2Ugem9uZS5qcyBwYXRjaCB0aGUgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGV4ZWN1dGlvblxuICAgIC8vIGNvbnRleHQuIEhvd2V2ZXIsIGl0IGFwcGVhcnMgdGhhdCBtb3N0IGJyb3dzZXJzIHVzZSBhbiBpbnRlcm5hbCBwcm9taXNlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gd2hlbiB1c2luZyB0aGUgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSBBUEkgY2F1c2luZyB0aGVtXG4gICAgLy8gdG8gbG9zZSBjb250ZXh0IGFuZCBlbWl0IGNvbmZ1c2luZyBsb2cgbWVzc2FnZXMgb3IgYnJlYWsgY2VydGFpbiBmZWF0dXJlcy5cbiAgICAvLyBUaGlzIHdyYXBwaW5nIGlzIGJlbGlldmVkIHRvIGhlbHAgem9uZS5qcyB0cmFjayB0aGUgZXhlY3V0aW9uIGNvbnRleHRcbiAgICAvLyBiZXR0ZXIuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChuYW1lLCBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSwgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZWQnLCBuYW1lLCBsb2NrLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gcHJldGVuZCB0aGUgbG9jayBpcyBhY3F1aXJlZCBpbiB0aGUgbmFtZSBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gdXNpbmcgI3JlcXVlc3Qgd2l0aG91dCBpZkF2YWlsYWJsZSBzZXQgdG8gdHJ1ZSwgaXQgYXBwZWFycyB0aGlzIGJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTG9ja01hbmFnZXIgc3BlYyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xufVxuY29uc3QgUFJPQ0VTU19MT0NLUyA9IHt9O1xuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHRoYXQgd29ya3Mgb25seSBpbiB0aGUgY3VycmVudCBwcm9jZXNzLlxuICogVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgbGlrZSBSZWFjdCBOYXRpdmUgb3Igb3RoZXIgbm9uLWJyb3dzZXJcbiAqIHNpbmdsZS1wcm9jZXNzIChpLmUuIG5vIGNvbmNlcHQgb2YgXCJ0YWJzXCIpIGVudmlyb25tZW50cy5cbiAqXG4gKiBVc2Uge0BsaW5rICNuYXZpZ2F0b3JMb2NrfSBpbiBicm93c2VyIGVudmlyb25tZW50cy5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGF3YWl0IHByb2Nlc3NMb2NrKCdtaWdyYXRlJywgNTAwMCwgYXN5bmMgKCkgPT4ge1xuICogICBhd2FpdCBydW5NaWdyYXRpb24oKVxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0xvY2sobmFtZSwgYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHByZXZpb3VzT3BlcmF0aW9uID0gKF9hID0gUFJPQ0VTU19MT0NLU1tuYW1lXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgY29uc3QgY3VycmVudE9wZXJhdGlvbiA9IFByb21pc2UucmFjZShbXG4gICAgICAgIHByZXZpb3VzT3BlcmF0aW9uLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvciBvZiBwcmV2aW91cyBvcGVyYXRpb24gdGhhdCB3ZSdyZSB3YWl0aW5nIHRvIGZpbmlzaFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pLFxuICAgICAgICBhY3F1aXJlVGltZW91dCA+PSAwXG4gICAgICAgICAgICA/IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBAc3VwYWJhc2UvZ290cnVlLWpzOiBMb2NrIFwiJHtuYW1lfVwiIGFjcXVpc2l0aW9uIHRpbWVkIG91dCBhZnRlciAke2FjcXVpcmVUaW1lb3V0fW1zLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW5vdGhlciBvcGVyYXRpb24gaG9sZGluZyB0aGUgbG9jay4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29uc2lkZXIgaW5jcmVhc2luZyBsb2NrQWNxdWlyZVRpbWVvdXQgb3IgY2hlY2tpbmcgZm9yIHN0dWNrIG9wZXJhdGlvbnMuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUHJvY2Vzc0xvY2tBY3F1aXJlVGltZW91dEVycm9yKGBBY3F1aXJpbmcgcHJvY2VzcyBsb2NrIHdpdGggbmFtZSBcIiR7bmFtZX1cIiB0aW1lZCBvdXRgKSk7XG4gICAgICAgICAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICBdLmZpbHRlcigoeCkgPT4geCkpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBwcmV2aW91cyBvcGVyYXRpb25zIGZpbmlzaGVkIGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmFjZSBvbiB0aGUgYWNxdWlyZVxuICAgICAgICAvLyB0aW1lb3V0LCBzbyB0aGUgY3VycmVudCBvcGVyYXRpb24gY2FuIGZpbmFsbHkgc3RhcnRcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgfSk7XG4gICAgUFJPQ0VTU19MT0NLU1tuYW1lXSA9IGN1cnJlbnRPcGVyYXRpb24uY2F0Y2goYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBvcGVyYXRpb24gdGltZWQgb3V0LCBpdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBmaW5pc2hlZCwgc28gd2UgbmVlZCBjb250bnVlIHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgICAgICAgYXdhaXQgcHJldmlvdXNPcGVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICAgIC8vIGZpbmFsbHkgd2FpdCBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRvIGZpbmlzaCBzdWNjZXNzZnVsbHksIHdpdGggYW5cbiAgICAvLyBlcnJvciBvciB3aXRoIGFuIGFjcXVpcmUgdGltZW91dCBlcnJvclxuICAgIHJldHVybiBhd2FpdCBjdXJyZW50T3BlcmF0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9ja3MuanMubWFwIl0sIm5hbWVzIjpbInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiaW50ZXJuYWxzIiwiZGVidWciLCJnbG9iYWxUaGlzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJpc0FjcXVpcmVUaW1lb3V0IiwiTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJuYXZpZ2F0b3JMb2NrIiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJjb25zb2xlIiwibG9nIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibmF2aWdhdG9yIiwibG9ja3MiLCJyZXF1ZXN0IiwibW9kZSIsImlmQXZhaWxhYmxlIiwic2lnbmFsIiwibG9jayIsInJlc3VsdCIsInF1ZXJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJ3YXJuIiwiUFJPQ0VTU19MT0NLUyIsInByb2Nlc3NMb2NrIiwiX2EiLCJwcmV2aW91c09wZXJhdGlvbiIsImN1cnJlbnRPcGVyYXRpb24iLCJyYWNlIiwiY2F0Y2giLCJfIiwicmVqZWN0IiwiZmlsdGVyIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDTSxTQUFTQTtJQUNaLElBQUksT0FBT0MsZUFBZSxVQUN0QjtJQUNKLElBQUk7UUFDQUMsT0FBT0MsY0FBYyxDQUFDRCxPQUFPRSxTQUFTLEVBQUUsYUFBYTtZQUNqREMsS0FBSztnQkFDRCxPQUFPLElBQUk7WUFDZjtZQUNBQyxjQUFjO1FBQ2xCO1FBQ0EsMkNBQTJDO1FBQzNDQyxVQUFVTixVQUFVLEdBQUdNO1FBQ3ZCLDJDQUEyQztRQUMzQyxPQUFPTCxPQUFPRSxTQUFTLENBQUNHLFNBQVM7SUFDckMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSSxPQUFPQyxTQUFTLGFBQWE7WUFDN0IsNkNBQTZDO1lBQzdDQSxLQUFLUixVQUFVLEdBQUdRO1FBQ3RCO0lBQ0o7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9wb2x5ZmlsbHMuanM/NjNlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5ZmlsbEdsb2JhbFRoaXMoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnX19tYWdpY19fJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgICAgICBfX21hZ2ljX18uZ2xvYmFsVGhpcyA9IF9fbWFnaWNfXztcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgICAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX187XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBnbG9iYWxzJ1xuICAgICAgICAgICAgc2VsZi5nbG9iYWxUaGlzID0gc2VsZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxscy5qcy5tYXAiXSwibmFtZXMiOlsicG9seWZpbGxHbG9iYWxUaGlzIiwiZ2xvYmFsVGhpcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwiX19tYWdpY19fIiwiZSIsInNlbGYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* binding */ SIGN_OUT_SCOPES)\n/* harmony export */ });\nconst WeakPasswordReasons = [\n    \"length\",\n    \"characters\",\n    \"pwned\"\n];\nconst AMRMethods = [\n    \"password\",\n    \"otp\",\n    \"oauth\",\n    \"totp\",\n    \"mfa/totp\",\n    \"mfa/phone\",\n    \"mfa/webauthn\",\n    \"anonymous\",\n    \"sso/saml\",\n    \"magiclink\",\n    \"web3\",\n    \"oauth_provider/authorization_code\"\n];\nconst FactorTypes = [\n    \"totp\",\n    \"phone\",\n    \"webauthn\"\n];\nconst FactorVerificationStatuses = [\n    \"verified\",\n    \"unverified\"\n];\nconst MFATOTPChannels = [\n    \"sms\",\n    \"whatsapp\"\n];\nconst SIGN_OUT_SCOPES = [\n    \"global\",\n    \"local\",\n    \"others\"\n]; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxzQkFBc0I7SUFBQztJQUFVO0lBQWM7Q0FBUTtBQUM3RCxNQUFNQyxhQUFhO0lBQ2Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0g7QUFDRCxNQUFNQyxjQUFjO0lBQUM7SUFBUTtJQUFTO0NBQVc7QUFDakQsTUFBTUMsNkJBQTZCO0lBQUM7SUFBWTtDQUFhO0FBQzdELE1BQU1DLGtCQUFrQjtJQUFDO0lBQU87Q0FBVztBQUNwQyxNQUFNQyxrQkFBa0I7SUFBQztJQUFVO0lBQVM7Q0FBUyxDQUFDLENBQzdELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi90eXBlcy5qcz8xZjYxIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFdlYWtQYXNzd29yZFJlYXNvbnMgPSBbJ2xlbmd0aCcsICdjaGFyYWN0ZXJzJywgJ3B3bmVkJ107XG5jb25zdCBBTVJNZXRob2RzID0gW1xuICAgICdwYXNzd29yZCcsXG4gICAgJ290cCcsXG4gICAgJ29hdXRoJyxcbiAgICAndG90cCcsXG4gICAgJ21mYS90b3RwJyxcbiAgICAnbWZhL3Bob25lJyxcbiAgICAnbWZhL3dlYmF1dGhuJyxcbiAgICAnYW5vbnltb3VzJyxcbiAgICAnc3NvL3NhbWwnLFxuICAgICdtYWdpY2xpbmsnLFxuICAgICd3ZWIzJyxcbiAgICAnb2F1dGhfcHJvdmlkZXIvYXV0aG9yaXphdGlvbl9jb2RlJyxcbl07XG5jb25zdCBGYWN0b3JUeXBlcyA9IFsndG90cCcsICdwaG9uZScsICd3ZWJhdXRobiddO1xuY29uc3QgRmFjdG9yVmVyaWZpY2F0aW9uU3RhdHVzZXMgPSBbJ3ZlcmlmaWVkJywgJ3VudmVyaWZpZWQnXTtcbmNvbnN0IE1GQVRPVFBDaGFubmVscyA9IFsnc21zJywgJ3doYXRzYXBwJ107XG5leHBvcnQgY29uc3QgU0lHTl9PVVRfU0NPUEVTID0gWydnbG9iYWwnLCAnbG9jYWwnLCAnb3RoZXJzJ107XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiV2Vha1Bhc3N3b3JkUmVhc29ucyIsIkFNUk1ldGhvZHMiLCJGYWN0b3JUeXBlcyIsIkZhY3RvclZlcmlmaWNhdGlvblN0YXR1c2VzIiwiTUZBVE9UUENoYW5uZWxzIiwiU0lHTl9PVVRfU0NPUEVTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.90.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZFQUE2RTtBQUM3RSxnRUFBZ0U7QUFDaEUsdUVBQXVFO0FBQ3ZFLGlFQUFpRTtBQUNqRSxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQzFELE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcz85NzdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuOTAuMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSiweMessage: () => (/* binding */ createSiweMessage),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n// types and functions copied over from viem so this library doesn't depend on it\nfunction getAddress(address) {\n    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n        throw new Error(`@supabase/auth-js: Address \"${address}\" is invalid.`);\n    }\n    return address.toLowerCase();\n}\nfunction fromHex(hex) {\n    return parseInt(hex, 16);\n}\nfunction toHex(value) {\n    const bytes = new TextEncoder().encode(value);\n    const hex = Array.from(bytes, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    return \"0x\" + hex;\n}\n/**\n * Creates EIP-4361 formatted message.\n */ function createSiweMessage(parameters) {\n    var _a;\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version } = parameters;\n    // Validate fields\n    {\n        if (!Number.isInteger(chainId)) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);\n        if (!domain) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.`);\n        if (nonce && nonce.length < 8) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: ${nonce}`);\n        if (!uri) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.`);\n        if (version !== \"1\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ${version}`);\n        if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes(\"\\n\")) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\\\n'. Provided value: ${parameters.statement}`);\n    }\n    // Construct message\n    const address = getAddress(parameters.address);\n    const origin = scheme ? `${scheme}://${domain}` : domain;\n    const statement = parameters.statement ? `${parameters.statement}\\n` : \"\";\n    const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n    let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}${nonce ? `\\nNonce: ${nonce}` : \"\"}\\nIssued At: ${issuedAt.toISOString()}`;\n    if (expirationTime) suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n    if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n    if (requestId) suffix += `\\nRequest ID: ${requestId}`;\n    if (resources) {\n        let content = \"\\nResources:\";\n        for (const resource of resources){\n            if (!resource || typeof resource !== \"string\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: ${resource}`);\n            content += `\\n- ${resource}`;\n        }\n        suffix += content;\n    }\n    return `${prefix}\\n${suffix}`;\n} //# sourceMappingURL=ethereum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYjMvZXRoZXJldW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlGQUFpRjtBQUMxRSxTQUFTQSxXQUFXQyxPQUFPO0lBQzlCLElBQUksQ0FBQyxzQkFBc0JDLElBQUksQ0FBQ0QsVUFBVTtRQUN0QyxNQUFNLElBQUlFLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRUYsUUFBUSxhQUFhLENBQUM7SUFDekU7SUFDQSxPQUFPQSxRQUFRRyxXQUFXO0FBQzlCO0FBQ08sU0FBU0MsUUFBUUMsR0FBRztJQUN2QixPQUFPQyxTQUFTRCxLQUFLO0FBQ3pCO0FBQ08sU0FBU0UsTUFBTUMsS0FBSztJQUN2QixNQUFNQyxRQUFRLElBQUlDLGNBQWNDLE1BQU0sQ0FBQ0g7SUFDdkMsTUFBTUgsTUFBTU8sTUFBTUMsSUFBSSxDQUFDSixPQUFPLENBQUNLLE9BQVNBLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUM7SUFDakYsT0FBUSxPQUFPWjtBQUNuQjtBQUNBOztDQUVDLEdBQ00sU0FBU2Esa0JBQWtCQyxVQUFVO0lBQ3hDLElBQUlDO0lBQ0osTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsY0FBYyxFQUFFQyxXQUFXLElBQUlDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFHLEdBQUdiO0lBQ2xJLGtCQUFrQjtJQUNsQjtRQUNJLElBQUksQ0FBQ2MsT0FBT0MsU0FBUyxDQUFDYixVQUNsQixNQUFNLElBQUluQixNQUFNLENBQUMsOEdBQThHLEVBQUVtQixRQUFRLENBQUM7UUFDOUksSUFBSSxDQUFDQyxRQUNELE1BQU0sSUFBSXBCLE1BQU0sQ0FBQyxnRkFBZ0YsQ0FBQztRQUN0RyxJQUFJd0IsU0FBU0EsTUFBTVMsTUFBTSxHQUFHLEdBQ3hCLE1BQU0sSUFBSWpDLE1BQU0sQ0FBQyw0R0FBNEcsRUFBRXdCLE1BQU0sQ0FBQztRQUMxSSxJQUFJLENBQUNLLEtBQ0QsTUFBTSxJQUFJN0IsTUFBTSxDQUFDLDBFQUEwRSxDQUFDO1FBQ2hHLElBQUk4QixZQUFZLEtBQ1osTUFBTSxJQUFJOUIsTUFBTSxDQUFDLDhGQUE4RixFQUFFOEIsUUFBUSxDQUFDO1FBQzlILElBQUksQ0FBQ1osS0FBS0QsV0FBV2lCLFNBQVMsTUFBTSxRQUFRaEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsUUFBUSxDQUFDLE9BQzdFLE1BQU0sSUFBSW5DLE1BQU0sQ0FBQyw2R0FBNkcsRUFBRWlCLFdBQVdpQixTQUFTLENBQUMsQ0FBQztJQUM5SjtJQUNBLG9CQUFvQjtJQUNwQixNQUFNcEMsVUFBVUQsV0FBV29CLFdBQVduQixPQUFPO0lBQzdDLE1BQU1zQyxTQUFTUixTQUFTLENBQUMsRUFBRUEsT0FBTyxHQUFHLEVBQUVSLE9BQU8sQ0FBQyxHQUFHQTtJQUNsRCxNQUFNYyxZQUFZakIsV0FBV2lCLFNBQVMsR0FBRyxDQUFDLEVBQUVqQixXQUFXaUIsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHO0lBQ3ZFLE1BQU1HLFNBQVMsQ0FBQyxFQUFFRCxPQUFPLG1EQUFtRCxFQUFFdEMsUUFBUSxJQUFJLEVBQUVvQyxVQUFVLENBQUM7SUFDdkcsSUFBSUksU0FBUyxDQUFDLEtBQUssRUFBRVQsSUFBSSxXQUFXLEVBQUVDLFFBQVEsWUFBWSxFQUFFWCxRQUFRLEVBQUVLLFFBQVEsQ0FBQyxTQUFTLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEdBQUcsYUFBYSxFQUFFRixTQUFTaUIsV0FBVyxHQUFHLENBQUM7SUFDOUksSUFBSWxCLGdCQUNBaUIsVUFBVSxDQUFDLG1CQUFtQixFQUFFakIsZUFBZWtCLFdBQVcsR0FBRyxDQUFDO0lBQ2xFLElBQUlkLFdBQ0FhLFVBQVUsQ0FBQyxjQUFjLEVBQUViLFVBQVVjLFdBQVcsR0FBRyxDQUFDO0lBQ3hELElBQUliLFdBQ0FZLFVBQVUsQ0FBQyxjQUFjLEVBQUVaLFVBQVUsQ0FBQztJQUMxQyxJQUFJQyxXQUFXO1FBQ1gsSUFBSWEsVUFBVTtRQUNkLEtBQUssTUFBTUMsWUFBWWQsVUFBVztZQUM5QixJQUFJLENBQUNjLFlBQVksT0FBT0EsYUFBYSxVQUNqQyxNQUFNLElBQUl6QyxNQUFNLENBQUMsa0hBQWtILEVBQUV5QyxTQUFTLENBQUM7WUFDbkpELFdBQVcsQ0FBQyxJQUFJLEVBQUVDLFNBQVMsQ0FBQztRQUNoQztRQUNBSCxVQUFVRTtJQUNkO0lBQ0EsT0FBTyxDQUFDLEVBQUVILE9BQU8sRUFBRSxFQUFFQyxPQUFPLENBQUM7QUFDakMsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViMy9ldGhlcmV1bS5qcz8yMGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHR5cGVzIGFuZCBmdW5jdGlvbnMgY29waWVkIG92ZXIgZnJvbSB2aWVtIHNvIHRoaXMgbGlicmFyeSBkb2Vzbid0IGRlcGVuZCBvbiBpdFxuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmApO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICAgIGNvbnN0IGhleCA9IEFycmF5LmZyb20oYnl0ZXMsIChieXRlKSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gKCcweCcgKyBoZXgpO1xufVxuLyoqXG4gKiBDcmVhdGVzIEVJUC00MzYxIGZvcm1hdHRlZCBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2l3ZU1lc3NhZ2UocGFyYW1ldGVycykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGNoYWluSWQsIGRvbWFpbiwgZXhwaXJhdGlvblRpbWUsIGlzc3VlZEF0ID0gbmV3IERhdGUoKSwgbm9uY2UsIG5vdEJlZm9yZSwgcmVxdWVzdElkLCByZXNvdXJjZXMsIHNjaGVtZSwgdXJpLCB2ZXJzaW9uLCB9ID0gcGFyYW1ldGVycztcbiAgICAvLyBWYWxpZGF0ZSBmaWVsZHNcbiAgICB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwiY2hhaW5JZFwiLiBDaGFpbiBJRCBtdXN0IGJlIGEgRUlQLTE1NSBjaGFpbiBJRC4gUHJvdmlkZWQgdmFsdWU6ICR7Y2hhaW5JZH1gKTtcbiAgICAgICAgaWYgKCFkb21haW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcImRvbWFpblwiLiBEb21haW4gbXVzdCBiZSBwcm92aWRlZC5gKTtcbiAgICAgICAgaWYgKG5vbmNlICYmIG5vbmNlLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcIm5vbmNlXCIuIE5vbmNlIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzLiBQcm92aWRlZCB2YWx1ZTogJHtub25jZX1gKTtcbiAgICAgICAgaWYgKCF1cmkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInVyaVwiLiBVUkkgbXVzdCBiZSBwcm92aWRlZC5gKTtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09ICcxJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwidmVyc2lvblwiLiBWZXJzaW9uIG11c3QgYmUgJzEnLiBQcm92aWRlZCB2YWx1ZTogJHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoKF9hID0gcGFyYW1ldGVycy5zdGF0ZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInN0YXRlbWVudFwiLiBTdGF0ZW1lbnQgbXVzdCBub3QgaW5jbHVkZSAnXFxcXG4nLiBQcm92aWRlZCB2YWx1ZTogJHtwYXJhbWV0ZXJzLnN0YXRlbWVudH1gKTtcbiAgICB9XG4gICAgLy8gQ29uc3RydWN0IG1lc3NhZ2VcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhwYXJhbWV0ZXJzLmFkZHJlc3MpO1xuICAgIGNvbnN0IG9yaWdpbiA9IHNjaGVtZSA/IGAke3NjaGVtZX06Ly8ke2RvbWFpbn1gIDogZG9tYWluO1xuICAgIGNvbnN0IHN0YXRlbWVudCA9IHBhcmFtZXRlcnMuc3RhdGVtZW50ID8gYCR7cGFyYW1ldGVycy5zdGF0ZW1lbnR9XFxuYCA6ICcnO1xuICAgIGNvbnN0IHByZWZpeCA9IGAke29yaWdpbn0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6XFxuJHthZGRyZXNzfVxcblxcbiR7c3RhdGVtZW50fWA7XG4gICAgbGV0IHN1ZmZpeCA9IGBVUkk6ICR7dXJpfVxcblZlcnNpb246ICR7dmVyc2lvbn1cXG5DaGFpbiBJRDogJHtjaGFpbklkfSR7bm9uY2UgPyBgXFxuTm9uY2U6ICR7bm9uY2V9YCA6ICcnfVxcbklzc3VlZCBBdDogJHtpc3N1ZWRBdC50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lKVxuICAgICAgICBzdWZmaXggKz0gYFxcbkV4cGlyYXRpb24gVGltZTogJHtleHBpcmF0aW9uVGltZS50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKG5vdEJlZm9yZSlcbiAgICAgICAgc3VmZml4ICs9IGBcXG5Ob3QgQmVmb3JlOiAke25vdEJlZm9yZS50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKHJlcXVlc3RJZClcbiAgICAgICAgc3VmZml4ICs9IGBcXG5SZXF1ZXN0IElEOiAke3JlcXVlc3RJZH1gO1xuICAgIGlmIChyZXNvdXJjZXMpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnXFxuUmVzb3VyY2VzOic7XG4gICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJlc291cmNlIHx8IHR5cGVvZiByZXNvdXJjZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJyZXNvdXJjZXNcIi4gRXZlcnkgcmVzb3VyY2UgbXVzdCBiZSBhIHZhbGlkIHN0cmluZy4gUHJvdmlkZWQgdmFsdWU6ICR7cmVzb3VyY2V9YCk7XG4gICAgICAgICAgICBjb250ZW50ICs9IGBcXG4tICR7cmVzb3VyY2V9YDtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggKz0gY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZWZpeH1cXG4ke3N1ZmZpeH1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJldW0uanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJhZGRyZXNzIiwidGVzdCIsIkVycm9yIiwidG9Mb3dlckNhc2UiLCJmcm9tSGV4IiwiaGV4IiwicGFyc2VJbnQiLCJ0b0hleCIsInZhbHVlIiwiYnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIkFycmF5IiwiZnJvbSIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsImNyZWF0ZVNpd2VNZXNzYWdlIiwicGFyYW1ldGVycyIsIl9hIiwiY2hhaW5JZCIsImRvbWFpbiIsImV4cGlyYXRpb25UaW1lIiwiaXNzdWVkQXQiLCJEYXRlIiwibm9uY2UiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJzY2hlbWUiLCJ1cmkiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibGVuZ3RoIiwic3RhdGVtZW50IiwiaW5jbHVkZXMiLCJvcmlnaW4iLCJwcmVmaXgiLCJzdWZmaXgiLCJ0b0lTT1N0cmluZyIsImNvbnRlbnQiLCJyZXNvdXJjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnError: () => (/* binding */ WebAuthnError),\n/* harmony export */   WebAuthnUnknownError: () => (/* binding */ WebAuthnUnknownError),\n/* harmony export */   identifyAuthenticationError: () => (/* binding */ identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* binding */ identifyRegistrationError),\n/* harmony export */   isWebAuthnError: () => (/* binding */ isWebAuthnError)\n/* harmony export */ });\n/* harmony import */ var _webauthn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n/* eslint-disable @typescript-eslint/ban-ts-comment */ \n/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */ class WebAuthnError extends Error {\n    constructor({ message, code, cause, name }){\n        var _a;\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, {\n            cause\n        });\n        this.__isWebAuthnError = true;\n        this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== void 0 ? _a : \"Unknown Error\";\n        this.code = code;\n    }\n}\n/**\n * Error class for unknown WebAuthn errors.\n * Wraps unexpected errors that don't match known WebAuthn error conditions.\n */ class WebAuthnUnknownError extends WebAuthnError {\n    constructor(message, originalError){\n        super({\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: originalError,\n            message\n        });\n        this.name = \"WebAuthnUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Type guard to check if an error is a WebAuthnError.\n * @param {unknown} error - The error to check\n * @returns {boolean} True if the error is a WebAuthnError\n */ function isWebAuthnError(error) {\n    return typeof error === \"object\" && error !== null && \"__isWebAuthnError\" in error;\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n */ function identifyRegistrationError({ error, options }) {\n    var _a, _b, _c;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Registration ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"ConstraintError\") {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: \"Discoverable credentials were required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n                cause: error\n            });\n        } else if (// @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === \"conditional\" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: \"User verification was required during automatic registration but it could not be performed\",\n                code: \"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE\",\n                cause: error\n            });\n        } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === \"required\") {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: \"User verification was required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"InvalidStateError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: \"The authenticator was previously registered\",\n            code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n            cause: error\n        });\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"NotSupportedError\") {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param)=>param.type === \"public-key\");\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n                cause: error\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n            code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"TypeError\") {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: \"User ID was not between 1 and 64 characters\",\n                code: \"ERROR_INVALID_USER_ID_LENGTH\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n */ function identifyAuthenticationError({ error, options }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Authentication ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n} //# sourceMappingURL=webauthn.errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmVycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxvREFBb0QsR0FDVDtBQUMzQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1DLHNCQUFzQkM7SUFDL0JDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDekMsSUFBSUM7UUFDSixpRUFBaUU7UUFDakUsS0FBSyxDQUFDSixTQUFTO1lBQUVFO1FBQU07UUFDdkIsSUFBSSxDQUFDRyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNGLElBQUksR0FBRyxDQUFDQyxLQUFLRCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFRRCxpQkFBaUJKLFFBQVFJLE1BQU1DLElBQUksR0FBR0csU0FBUyxNQUFPLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2hKLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTU0sNkJBQTZCVjtJQUN0Q0UsWUFBWUMsT0FBTyxFQUFFUSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDO1lBQ0ZQLE1BQU07WUFDTkMsT0FBT007WUFDUFI7UUFDSjtRQUNBLElBQUksQ0FBQ0csSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSyxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0JBQWdCQyxLQUFLO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsdUJBQXVCQTtBQUNqRjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU0MsMEJBQTBCLEVBQUVELEtBQUssRUFBRUUsT0FBTyxFQUFHO0lBQ3pELElBQUlSLElBQUlTLElBQUlDO0lBQ1osTUFBTSxFQUFFQyxTQUFTLEVBQUUsR0FBR0g7SUFD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SyxpQkFBaUI7UUFDckMsTUFBTXlCLGtCQUFrQkMsT0FBT0MsUUFBUSxDQUFDQyxRQUFRO1FBQ2hELElBQUksQ0FBQ25DLHdEQUFhQSxDQUFDZ0Msa0JBQWtCO1lBQ2pDLGdGQUFnRjtZQUNoRixPQUFPLElBQUkvQixjQUFjO2dCQUNyQkcsU0FBUyxDQUFDLEVBQUU2QixPQUFPQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQztnQkFDM0Q5QixNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0osT0FDSyxJQUFJSyxVQUFVc0IsSUFBSSxLQUFLVCxpQkFBaUI7WUFDekMsZ0ZBQWdGO1lBQ2hGLE9BQU8sSUFBSS9CLGNBQWM7Z0JBQ3JCRyxTQUFTLENBQUMsV0FBVyxFQUFFZSxVQUFVc0IsSUFBSSxDQUFDLDRCQUE0QixDQUFDO2dCQUNuRXBDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLGdCQUFnQjtRQUNwQyxtRUFBbUU7UUFDbkUsb0VBQW9FO1FBQ3BFLE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSjtJQUNBLE9BQU8sSUFBSWIsY0FBYztRQUNyQkcsU0FBUztRQUNUQyxNQUFNO1FBQ05DLE9BQU9RO0lBQ1g7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWJhdXRobi5lcnJvcnMuanM/Yjk1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmltcG9ydCB7IGlzVmFsaWREb21haW4gfSBmcm9tICcuL3dlYmF1dGhuJztcbi8qKlxuICogQSBjdXN0b20gRXJyb3IgdXNlZCB0byByZXR1cm4gYSBtb3JlIG51YW5jZWQgZXJyb3IgZGV0YWlsaW5nIF93aHlfIG9uZSBvZiB0aGUgZWlnaHQgZG9jdW1lbnRlZFxuICogZXJyb3JzIGluIHRoZSBzcGVjIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYCBvclxuICogYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWA6XG4gKlxuICogLSBgQWJvcnRFcnJvcmBcbiAqIC0gYENvbnN0cmFpbnRFcnJvcmBcbiAqIC0gYEludmFsaWRTdGF0ZUVycm9yYFxuICogLSBgTm90QWxsb3dlZEVycm9yYFxuICogLSBgTm90U3VwcG9ydGVkRXJyb3JgXG4gKiAtIGBTZWN1cml0eUVycm9yYFxuICogLSBgVHlwZUVycm9yYFxuICogLSBgVW5rbm93bkVycm9yYFxuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHdlcmUgZGV0ZXJtaW5lZCB0aHJvdWdoIGludmVzdGlnYXRpb24gb2YgdGhlIHNwZWMgdG8gZGV0ZXJtaW5lIHVuZGVyIHdoaWNoXG4gKiBzY2VuYXJpb3MgYSBnaXZlbiBlcnJvciB3b3VsZCBiZSByYWlzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY29kZSwgY2F1c2UsIG5hbWUsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBoZWxwIFJvbGx1cCB1bmRlcnN0YW5kIHRoYXQgYGNhdXNlYCBpcyBva2F5IHRvIHNldFxuICAgICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICAgICAgICB0aGlzLl9faXNXZWJBdXRobkVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gKF9hID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5uYW1lIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ1Vua25vd24gRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgY2xhc3MgZm9yIHVua25vd24gV2ViQXV0aG4gZXJyb3JzLlxuICogV3JhcHMgdW5leHBlY3RlZCBlcnJvcnMgdGhhdCBkb24ndCBtYXRjaCBrbm93biBXZWJBdXRobiBlcnJvciBjb25kaXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5Vbmtub3duRXJyb3IgZXh0ZW5kcyBXZWJBdXRobkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IG9yaWdpbmFsRXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dlYkF1dGhuVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBXZWJBdXRobkVycm9yLlxuICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGEgV2ViQXV0aG5FcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJBdXRobkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNXZWJBdXRobkVycm9yJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogQXR0ZW1wdCB0byBpbnR1aXQgX3doeV8gYW4gZXJyb3Igd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClgLlxuICogTWFwcyBicm93c2VyIGVycm9ycyB0byBzcGVjaWZpYyBXZWJBdXRobiBlcnJvciBjb2RlcyBmb3IgYmV0dGVyIGRlYnVnZ2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBFcnJvciBpZGVudGlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Vycm9yfSBwYXJhbXMuZXJyb3IgLSBUaGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBicm93c2VyXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IHBhcmFtcy5vcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGNyZWRlbnRpYWxzLmNyZWF0ZSgpXG4gKiBAcmV0dXJucyB7V2ViQXV0aG5FcnJvcn0gQSBXZWJBdXRobkVycm9yIHdpdGggYSBzcGVjaWZpYyBlcnJvciBjb2RlXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWF0ZSBDcmVkZW50aWFsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcih7IGVycm9yLCBvcHRpb25zLCB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMgd2FzIG1pc3NpbmcgcmVxdWlyZWQgcHVibGljS2V5IHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWdpc3RyYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0NvbnN0cmFpbnRFcnJvcicpIHtcbiAgICAgICAgaWYgKCgoX2EgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcXVpcmVSZXNpZGVudEtleSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRGlzY292ZXJhYmxlIGNyZWRlbnRpYWxzIHdlcmUgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19ESVNDT1ZFUkFCTEVfQ1JFREVOVElBTF9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogYG1lZGlhdGlvbmAgZG9lc24ndCB5ZXQgZXhpc3Qgb24gQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBidXQgaXQncyBwb3NzaWJsZSBhcyBvZiBTZXB0IDIwMjRcbiAgICAgICAgb3B0aW9ucy5tZWRpYXRpb24gPT09ICdjb25kaXRpb25hbCcgJiZcbiAgICAgICAgICAgICgoX2IgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVzZXJWZXJpZmljYXRpb24pID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAyMi40KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciB2ZXJpZmljYXRpb24gd2FzIHJlcXVpcmVkIGR1cmluZyBhdXRvbWF0aWMgcmVnaXN0cmF0aW9uIGJ1dCBpdCBjb3VsZCBub3QgYmUgcGVyZm9ybWVkJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUT19SRUdJU1RFUl9VU0VSX1ZFUklGSUNBVElPTl9GQUlMVVJFJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9jID0gcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyVmVyaWZpY2F0aW9uKSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19VU0VSX1ZFUklGSUNBVElPTl9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMjApXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAzKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfUFJFVklPVVNMWV9SRUdJU1RFUkVEJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RTdXBwb3J0ZWRFcnJvcicpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQdWJLZXlDcmVkUGFyYW1zID0gcHVibGljS2V5LnB1YktleUNyZWRQYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4gcGFyYW0udHlwZSA9PT0gJ3B1YmxpYy1rZXknKTtcbiAgICAgICAgaWYgKHZhbGlkUHViS2V5Q3JlZFBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBlbnRyeSBpbiBwdWJLZXlDcmVkUGFyYW1zIHdhcyBvZiB0eXBlIFwicHVibGljLWtleVwiJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfTUFMRk9STUVEX1BVQktFWUNSRURQQVJBTVMnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAyKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ05vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBhbnkgb2YgdGhlIHNwZWNpZmllZCBwdWJLZXlDcmVkUGFyYW1zIGFsZ29yaXRobXMnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTk9fU1VQUE9SVEVEX1BVQktFWUNSRURQQVJBTVNfQUxHJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghaXNWYWxpZERvbWFpbihlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDcpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwLmlkICE9PSBlZmZlY3RpdmVEb21haW4pIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgOClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwLmlkfVwiIGlzIGludmFsaWQgZm9yIHRoaXMgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9SUF9JRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleS51c2VyLmlkLmJ5dGVMZW5ndGggPCAxIHx8IHB1YmxpY0tleS51c2VyLmlkLmJ5dGVMZW5ndGggPiA2NCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCA1KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciBJRCB3YXMgbm90IGJldHdlZW4gMSBhbmQgNjQgY2hhcmFjdGVycycsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfVVNFUl9JRF9MRU5HVEgnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdVbmtub3duRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAxKVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgOClcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgYXV0aGVudGljYXRvciB3YXMgdW5hYmxlIHRvIHByb2Nlc3MgdGhlIHNwZWNpZmllZCBvcHRpb25zLCBvciBjb3VsZCBub3QgY3JlYXRlIGEgbmV3IGNyZWRlbnRpYWwnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfR0VORVJBTF9FUlJPUicsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnYSBOb24tV2ViYXV0aG4gcmVsYXRlZCBlcnJvciBoYXMgb2NjdXJyZWQnLFxuICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pO1xufVxuLyoqXG4gKiBBdHRlbXB0IHRvIGludHVpdCBfd2h5XyBhbiBlcnJvciB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWAuXG4gKiBNYXBzIGJyb3dzZXIgZXJyb3JzIHRvIHNwZWNpZmljIFdlYkF1dGhuIGVycm9yIGNvZGVzIGZvciBiZXR0ZXIgZGVidWdnaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEVycm9yIGlkZW50aWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RXJyb3J9IHBhcmFtcy5lcnJvciAtIFRoZSBlcnJvciB0aHJvd24gYnkgdGhlIGJyb3dzZXJcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5nZXQoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWdldEFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEdldCBBc3NlcnRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IoeyBlcnJvciwgb3B0aW9ucywgfSkge1xuICAgIGNvbnN0IHsgcHVibGljS2V5IH0gPSBvcHRpb25zO1xuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb25zIHdhcyBtaXNzaW5nIHJlcXVpcmVkIHB1YmxpY0tleSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDE2KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdGhlIGVycm9yIGRpcmVjdGx5IHRocm91Z2guIFBsYXRmb3JtcyBhcmUgb3ZlcmxvYWRpbmcgdGhpcyBlcnJvciBiZXlvbmQgd2hhdCB0aGUgc3BlY1xuICAgICAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZURvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRG9tYWluKGVmZmVjdGl2ZURvbWFpbikpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWRpc2NvdmVyLWZyb20tZXh0ZXJuYWwtc291cmNlIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwSWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwSWR9XCIgaXMgaW52YWxpZCBmb3IgdGhpcyBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1JQX0lEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEpXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLWdldC1hc3NlcnRpb24gKFN0ZXAgMTIpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBhc3NlcnRpb24gc2lnbmF0dXJlJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2EgTm9uLVdlYmF1dGhuIHJlbGF0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJyxcbiAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmF1dGhuLmVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiaXNWYWxpZERvbWFpbiIsIldlYkF1dGhuRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNvZGUiLCJjYXVzZSIsIm5hbWUiLCJfYSIsIl9faXNXZWJBdXRobkVycm9yIiwidW5kZWZpbmVkIiwiV2ViQXV0aG5Vbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiaXNXZWJBdXRobkVycm9yIiwiZXJyb3IiLCJpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yIiwib3B0aW9ucyIsIl9iIiwiX2MiLCJwdWJsaWNLZXkiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJtZWRpYXRpb24iLCJ1c2VyVmVyaWZpY2F0aW9uIiwidmFsaWRQdWJLZXlDcmVkUGFyYW1zIiwicHViS2V5Q3JlZFBhcmFtcyIsImZpbHRlciIsInBhcmFtIiwidHlwZSIsImxlbmd0aCIsImVmZmVjdGl2ZURvbWFpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJycCIsImlkIiwidXNlciIsImJ5dGVMZW5ndGgiLCJpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IiLCJycElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CREATION_OPTIONS: () => (/* binding */ DEFAULT_CREATION_OPTIONS),\n/* harmony export */   DEFAULT_REQUEST_OPTIONS: () => (/* binding */ DEFAULT_REQUEST_OPTIONS),\n/* harmony export */   WebAuthnAbortService: () => (/* binding */ WebAuthnAbortService),\n/* harmony export */   WebAuthnApi: () => (/* binding */ WebAuthnApi),\n/* harmony export */   WebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnError),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   deserializeCredentialCreationOptions: () => (/* binding */ deserializeCredentialCreationOptions),\n/* harmony export */   deserializeCredentialRequestOptions: () => (/* binding */ deserializeCredentialRequestOptions),\n/* harmony export */   getCredential: () => (/* binding */ getCredential),\n/* harmony export */   identifyAuthenticationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError),\n/* harmony export */   isValidDomain: () => (/* binding */ isValidDomain),\n/* harmony export */   isWebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.isWebAuthnError),\n/* harmony export */   mergeCredentialCreationOptions: () => (/* binding */ mergeCredentialCreationOptions),\n/* harmony export */   mergeCredentialRequestOptions: () => (/* binding */ mergeCredentialRequestOptions),\n/* harmony export */   serializeCredentialCreationResponse: () => (/* binding */ serializeCredentialCreationResponse),\n/* harmony export */   serializeCredentialRequestResponse: () => (/* binding */ serializeCredentialRequestResponse),\n/* harmony export */   webAuthnAbortService: () => (/* binding */ webAuthnAbortService)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webauthn.errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\");\n\n\n\n\n\n\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */ class WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */ createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error(\"Cancelling existing WebAuthn API call for new one\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */ cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error(\"Manually cancelling existing WebAuthn API call\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */ const webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */ function deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential creation options are required\");\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseCreationOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */ options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"user\",\n        \"excludeCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), {\n        id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(userOpts.id).buffer\n    });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge,\n        user\n    });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for(let i = 0; i < excludeCredentials.length; i++){\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */ function deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential request options are required\");\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseRequestOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"allowCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge\n    });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for(let i = 0; i < allowCredentials.length; i++){\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))\n        },\n        type: \"public-key\",\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            authenticatorData: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle ? (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : undefined\n        },\n        type: \"public-key\",\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */ function isValidDomain(hostname) {\n    return(// Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */ function browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && \"PublicKeyCredential\" in window && window.PublicKeyCredential && \"credentials\" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === \"function\" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === \"function\");\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */ async function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */ async function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\nconst DEFAULT_CREATION_OPTIONS = {\n    hints: [\n        \"security-key\"\n    ],\n    authenticatorSelection: {\n        authenticatorAttachment: \"cross-platform\",\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n        residentKey: \"discouraged\"\n    },\n    attestation: \"direct\"\n};\nconst DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n    hints: [\n        \"security-key\"\n    ],\n    attestation: \"direct\"\n};\nfunction deepMerge(...sources) {\n    const isObject = (val)=>val !== null && typeof val === \"object\" && !Array.isArray(val);\n    const isArrayBufferLike = (val)=>val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources){\n        if (!source) continue;\n        for(const key in source){\n            const value = source[key];\n            if (value === undefined) continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            } else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            } else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                } else {\n                    result[key] = deepMerge(value);\n                }\n            } else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */ function mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */ function mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */ class WebAuthnApi {\n    constructor(client){\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */ async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n            factorType: \"webauthn\"\n        }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */ async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */ if (challengeResponse.webauthn.type === \"create\") {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    user.name = `${user.id}:${friendlyName}`;\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch(challengeResponse.webauthn.type){\n                case \"create\":\n                    {\n                        const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                        const { data, error } = await createCredential({\n                            publicKey: options,\n                            signal: abortSignal\n                        });\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                case \"request\":\n                    {\n                        const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                        const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n                            publicKey: options,\n                            signal: abortSignal\n                        }));\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n            }\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in challenge\", error)\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */ async _verify({ challengeId, factorId, webauthn }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */ async _authenticate({ factorId, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } = {} }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn authentication\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                request: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in authenticate\", error)\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */ async _register({ friendlyName, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } = {} }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn registration\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName\n            });\n            if (!factor) {\n                await this.client.mfa.listFactors().then((factors)=>{\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v)=>v.factor_type === \"webauthn\" && v.friendly_name === friendlyName && v.status !== \"unverified\");\n                }).then((factor)=>factor ? this.client.mfa.unenroll({\n                        factorId: factor === null || factor === void 0 ? void 0 : factor.id\n                    }) : void 0);\n                return {\n                    data: null,\n                    error: enrollError\n                };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                create: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in register\", error)\n            };\n        }\n    }\n} //# sourceMappingURL=webauthn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3VDO0FBQ0Y7QUFDOUI7QUFDNEc7QUFDaEQ7QUFDbEc7Ozs7OztDQU1DLEdBQ00sTUFBTVk7SUFDVDs7Ozs7O0tBTUMsR0FDREMsdUJBQXVCO1FBQ25CLDRGQUE0RjtRQUM1RixJQUFJLElBQUksQ0FBQ0MsVUFBVSxFQUFFO1lBQ2pCLE1BQU1DLGFBQWEsSUFBSUMsTUFBTTtZQUM3QkQsV0FBV0UsSUFBSSxHQUFHO1lBQ2xCLElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxLQUFLLENBQUNIO1FBQzFCO1FBQ0EsTUFBTUksZ0JBQWdCLElBQUlDO1FBQzFCLElBQUksQ0FBQ04sVUFBVSxHQUFHSztRQUNsQixPQUFPQSxjQUFjRSxNQUFNO0lBQy9CO0lBQ0E7Ozs7O0tBS0MsR0FDREMsaUJBQWlCO1FBQ2IsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUNqQixNQUFNQyxhQUFhLElBQUlDLE1BQU07WUFDN0JELFdBQVdFLElBQUksR0FBRztZQUNsQixJQUFJLENBQUNILFVBQVUsQ0FBQ0ksS0FBSyxDQUFDSDtZQUN0QixJQUFJLENBQUNELFVBQVUsR0FBR1M7UUFDdEI7SUFDSjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQyx1QkFBdUIsSUFBSVosdUJBQXVCO0FBQy9EOzs7Ozs7OztDQVFDLEdBQ00sU0FBU2EscUNBQXFDQyxPQUFPO0lBQ3hELElBQUksQ0FBQ0EsU0FBUztRQUNWLE1BQU0sSUFBSVYsTUFBTTtJQUNwQjtJQUNBLHVFQUF1RTtJQUN2RSxJQUFJLE9BQU9XLHdCQUF3QixlQUMvQixrQ0FBa0NBLHVCQUNsQyxPQUFPQSxvQkFDRkMsNEJBQTRCLEtBQUssWUFBWTtRQUNsRCx5Q0FBeUM7UUFDekMsT0FBT0Qsb0JBQW9CQyw0QkFBNEIsQ0FDdkQs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T0FBTyxDQUFDO2dCQUNoQlEsVUFBVWdCLE9BQU9wRyxFQUFFO2dCQUNuQjZGLGFBQWFOLGtCQUFrQk0sV0FBVztnQkFDMUNSLFVBQVU7b0JBQ05XO29CQUNBRTtvQkFDQTVGLE1BQU1pRixrQkFBa0JGLFFBQVEsQ0FBQy9FLElBQUk7b0JBQ3JDd0YscUJBQXFCUCxrQkFBa0JGLFFBQVEsQ0FBQ1MsbUJBQW1CO2dCQUN2RTtZQUNKO1FBQ0osRUFDQSxPQUFPckQsT0FBTztZQUNWLElBQUkxRSxvREFBV0EsQ0FBQzBFLFFBQVE7Z0JBQ3BCLE9BQU87b0JBQUVELE1BQU07b0JBQU1DO2dCQUFNO1lBQy9CO1lBQ0EsT0FBTztnQkFDSEQsTUFBTTtnQkFDTkMsT0FBTyxJQUFJM0UscURBQWdCQSxDQUFDLGdDQUFnQzJFO1lBQ2hFO1FBQ0o7SUFDSjtBQUNKLEVBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmpzPzg4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBiYXNlNjRVcmxUb1VpbnQ4QXJyYXksIGJ5dGVzVG9CYXNlNjRVUkwgfSBmcm9tICcuL2Jhc2U2NHVybCc7XG5pbXBvcnQgeyBBdXRoRXJyb3IsIEF1dGhVbmtub3duRXJyb3IsIGlzQXV0aEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciwgaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciwgaXNXZWJBdXRobkVycm9yLCBXZWJBdXRobkVycm9yLCBXZWJBdXRoblVua25vd25FcnJvciwgfSBmcm9tICcuL3dlYmF1dGhuLmVycm9ycyc7XG5leHBvcnQgeyBXZWJBdXRobkVycm9yLCBpc1dlYkF1dGhuRXJyb3IsIGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IsIGlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciB9O1xuLyoqXG4gKiBXZWJBdXRobiBhYm9ydCBzZXJ2aWNlIHRvIG1hbmFnZSBjZXJlbW9ueSBjYW5jZWxsYXRpb24uXG4gKiBFbnN1cmVzIG9ubHkgb25lIFdlYkF1dGhuIGNlcmVtb255IGlzIGFjdGl2ZSBhdCBhIHRpbWUgdG8gcHJldmVudCBcIm9wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIgZXJyb3JzLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBjbGFzcyBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tYXV0b21hdGlvbi13ZWJkcml2ZXItY2FwYWJpbGl0eSBXM0MgV2ViQXV0aG4gU3BlYyAtIEFib3J0aW5nIENlcmVtb25pZXN9XG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkFib3J0U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGFib3J0IHNpZ25hbCBmb3IgYSBuZXcgV2ViQXV0aG4gb3BlcmF0aW9uLlxuICAgICAqIEF1dG9tYXRpY2FsbHkgY2FuY2VscyBhbnkgZXhpc3Rpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Fib3J0U2lnbmFsfSBTaWduYWwgdG8gcGFzcyB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgb3IgLmdldCgpXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsIE1ETiAtIEFib3J0U2lnbmFsfVxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0Fib3J0U2lnbmFsKCkge1xuICAgICAgICAvLyBBYm9ydCBhbnkgZXhpc3RpbmcgY2FsbHMgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIG9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdDYW5jZWxsaW5nIGV4aXN0aW5nIFdlYkF1dGhuIEFQSSBjYWxsIGZvciBuZXcgb25lJyk7XG4gICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoYWJvcnRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3Q29udHJvbGxlcjtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBjYW5jZWwgdGhlIGN1cnJlbnQgV2ViQXV0aG4gb3BlcmF0aW9uLlxuICAgICAqIFVzZWZ1bCBmb3IgY2xlYW5pbmcgdXAgd2hlbiB1c2VyIGNhbmNlbHMgb3IgbmF2aWdhdGVzIGF3YXkuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRDb250cm9sbGVyL2Fib3J0IE1ETiAtIEFib3J0Q29udHJvbGxlci5hYm9ydH1cbiAgICAgKi9cbiAgICBjYW5jZWxDZXJlbW9ueSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignTWFudWFsbHkgY2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCcpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBTaW5nbGV0b24gaW5zdGFuY2UgdG8gZW5zdXJlIG9ubHkgb25lIFdlYkF1dGhuIGNlcmVtb255IGlzIGFjdGl2ZSBhdCBhIHRpbWUuXG4gKiBUaGlzIHByZXZlbnRzIFwib3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiBlcnJvcnMgd2hlbiByZXRyeWluZyBXZWJBdXRobiBvcGVyYXRpb25zLlxuICpcbiAqIEBleHBlcmltZW50YWwgVGhpcyBpbnN0YW5jZSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKi9cbmV4cG9ydCBjb25zdCB3ZWJBdXRobkFib3J0U2VydmljZSA9IG5ldyBXZWJBdXRobkFib3J0U2VydmljZSgpO1xuLyoqXG4gKiBDb252ZXJ0IGJhc2U2NHVybCBlbmNvZGVkIHN0cmluZ3MgaW4gV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zIHRvIEFycmF5QnVmZmVyc1xuICogYXMgcmVxdWlyZWQgYnkgdGhlIFdlYkF1dGhuIGJyb3dzZXIgQVBJLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtTZXJ2ZXJDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zfSBvcHRpb25zIC0gSlNPTiBvcHRpb25zIGZyb20gc2VydmVyIHdpdGggYmFzZTY0dXJsIGVuY29kZWQgZmllbGRzXG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gT3B0aW9ucyByZWFkeSBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiBXM0MgV2ViQXV0aG4gU3BlYyAtIHBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9ucyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgdGhlIG5hdGl2ZSBwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIG1ldGhvZCBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICdwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OJyBpbiBQdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgIHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsXG4gICAgICAgICAgICAucGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gUHVibGljS2V5Q3JlZGVudGlhbC5wYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OKFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSBvcHRpb25zIGhlcmUgYXMgdHlwZXNjcmlwdCBzdGlsbCBkb2Vzbid0IGtub3cgYWJvdXQgZnV0dXJlIHdlYmF1dGhuIHR5cGVzICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtYW51YWwgcGFyc2luZyBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgbWV0aG9kXG4gICAgLy8gRGVzdHJ1Y3R1cmUgdG8gc2VwYXJhdGUgZmllbGRzIHRoYXQgbmVlZCB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHsgY2hhbGxlbmdlOiBjaGFsbGVuZ2VTdHIsIHVzZXI6IHVzZXJPcHRzLCBleGNsdWRlQ3JlZGVudGlhbHMgfSA9IG9wdGlvbnMsIHJlc3RPcHRpb25zID0gX19yZXN0KG9wdGlvbnNcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgICwgW1wiY2hhbGxlbmdlXCIsIFwidXNlclwiLCBcImV4Y2x1ZGVDcmVkZW50aWFsc1wiXSk7XG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY2hhbGxlbmdlU3RyKS5idWZmZXI7XG4gICAgLy8gQ29udmVydCB1c2VyLmlkIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgdXNlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXNlck9wdHMpLCB7IGlkOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkodXNlck9wdHMuaWQpLmJ1ZmZlciB9KTtcbiAgICAvLyBCdWlsZCB0aGUgcmVzdWx0IG9iamVjdFxuICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdE9wdGlvbnMpLCB7IGNoYWxsZW5nZSxcbiAgICAgICAgdXNlciB9KTtcbiAgICAvLyBPbmx5IGFkZCBleGNsdWRlQ3JlZGVudGlhbHMgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGV4Y2x1ZGVDcmVkZW50aWFscyAmJiBleGNsdWRlQ3JlZGVudGlhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQuZXhjbHVkZUNyZWRlbnRpYWxzID0gbmV3IEFycmF5KGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3JlZCA9IGV4Y2x1ZGVDcmVkZW50aWFsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5leGNsdWRlQ3JlZGVudGlhbHNbaV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWQpLCB7IGlkOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY3JlZC5pZCkuYnVmZmVyLCB0eXBlOiBjcmVkLnR5cGUgfHwgJ3B1YmxpYy1rZXknLCBcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHRyYW5zcG9ydHMgdG8gaGFuZGxlIGZ1dHVyZSB0cmFuc3BvcnQgdHlwZXMgbGlrZSBcImNhYmxlXCJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzOiBjcmVkLnRyYW5zcG9ydHMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29udmVydCBiYXNlNjR1cmwgZW5jb2RlZCBzdHJpbmdzIGluIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIHRvIEFycmF5QnVmZmVyc1xuICogYXMgcmVxdWlyZWQgYnkgdGhlIFdlYkF1dGhuIGJyb3dzZXIgQVBJLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlckNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gb3B0aW9ucyAtIEpTT04gb3B0aW9ucyBmcm9tIHNlcnZlciB3aXRoIGJhc2U2NHVybCBlbmNvZGVkIGZpZWxkc1xuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gT3B0aW9ucyByZWFkeSBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIFczQyBXZWJBdXRobiBTcGVjIC0gcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgbmF0aXZlIHBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiBtZXRob2QgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAncGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OJyBpbiBQdWJsaWNLZXlDcmVkZW50aWFsICYmXG4gICAgICAgIHR5cGVvZiBQdWJsaWNLZXlDcmVkZW50aWFsXG4gICAgICAgICAgICAucGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBQdWJsaWNLZXlDcmVkZW50aWFsLnBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTihvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIHBhcnNpbmcgZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIG1ldGhvZFxuICAgIC8vIERlc3RydWN0dXJlIHRvIHNlcGFyYXRlIGZpZWxkcyB0aGF0IG5lZWQgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCB7IGNoYWxsZW5nZTogY2hhbGxlbmdlU3RyLCBhbGxvd0NyZWRlbnRpYWxzIH0gPSBvcHRpb25zLCByZXN0T3B0aW9ucyA9IF9fcmVzdChvcHRpb25zXG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICAsIFtcImNoYWxsZW5nZVwiLCBcImFsbG93Q3JlZGVudGlhbHNcIl0pO1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgY29uc3QgY2hhbGxlbmdlID0gYmFzZTY0VXJsVG9VaW50OEFycmF5KGNoYWxsZW5nZVN0cikuYnVmZmVyO1xuICAgIC8vIEJ1aWxkIHRoZSByZXN1bHQgb2JqZWN0XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0T3B0aW9ucyksIHsgY2hhbGxlbmdlIH0pO1xuICAgIC8vIE9ubHkgYWRkIGFsbG93Q3JlZGVudGlhbHMgaWYgaXQgZXhpc3RzXG4gICAgaWYgKGFsbG93Q3JlZGVudGlhbHMgJiYgYWxsb3dDcmVkZW50aWFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5hbGxvd0NyZWRlbnRpYWxzID0gbmV3IEFycmF5KGFsbG93Q3JlZGVudGlhbHMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkID0gYWxsb3dDcmVkZW50aWFsc1tpXTtcbiAgICAgICAgICAgIHJlc3VsdC5hbGxvd0NyZWRlbnRpYWxzW2ldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjcmVkKSwgeyBpZDogYmFzZTY0VXJsVG9VaW50OEFycmF5KGNyZWQuaWQpLmJ1ZmZlciwgdHlwZTogY3JlZC50eXBlIHx8ICdwdWJsaWMta2V5JywgXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCB0cmFuc3BvcnRzIHRvIGhhbmRsZSBmdXR1cmUgdHJhbnNwb3J0IHR5cGVzIGxpa2UgXCJjYWJsZVwiXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0czogY3JlZC50cmFuc3BvcnRzIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIENvbnZlcnQgYSByZWdpc3RyYXRpb24vZW5yb2xsbWVudCBjcmVkZW50aWFsIHJlc3BvbnNlIHRvIHNlcnZlciBmb3JtYXQuXG4gKiBTZXJpYWxpemVzIGJpbmFyeSBmaWVsZHMgdG8gYmFzZTY0dXJsIGZvciBKU09OIHRyYW5zbWlzc2lvbi5cbiAqIFN1cHBvcnRzIGJvdGggbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgdG9KU09OIGFuZCBtYW51YWwgZmFsbGJhY2suXG4gKlxuICogQHBhcmFtIHtSZWdpc3RyYXRpb25DcmVkZW50aWFsfSBjcmVkZW50aWFsIC0gQ3JlZGVudGlhbCBmcm9tIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKVxuICogQHJldHVybnMge1JlZ2lzdHJhdGlvblJlc3BvbnNlSlNPTn0gSlNPTi1zZXJpYWxpemFibGUgY3JlZGVudGlhbCBmb3Igc2VydmVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RvbS1wdWJsaWNrZXljcmVkZW50aWFsLXRvanNvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIHRvSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKGNyZWRlbnRpYWwpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIGNyZWRlbnRpYWwgaW5zdGFuY2UgaGFzIHRoZSB0b0pTT04gbWV0aG9kXG4gICAgaWYgKCd0b0pTT04nIGluIGNyZWRlbnRpYWwgJiYgdHlwZW9mIGNyZWRlbnRpYWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBjcmVkZW50aWFsLnRvSlNPTigpO1xuICAgIH1cbiAgICBjb25zdCBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQgPSBjcmVkZW50aWFsO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByYXdJZDogY3JlZGVudGlhbC5pZCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGF0dGVzdGF0aW9uT2JqZWN0OiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGNyZWRlbnRpYWwucmVzcG9uc2UuYXR0ZXN0YXRpb25PYmplY3QpKSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGNyZWRlbnRpYWwucmVzcG9uc2UuY2xpZW50RGF0YUpTT04pKSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICBjbGllbnRFeHRlbnNpb25SZXN1bHRzOiBjcmVkZW50aWFsLmdldENsaWVudEV4dGVuc2lvblJlc3VsdHMoKSxcbiAgICAgICAgLy8gQ29udmVydCBudWxsIHRvIHVuZGVmaW5lZCBhbmQgY2FzdCB0byBBdXRoZW50aWNhdG9yQXR0YWNobWVudCB0eXBlXG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiAoKF9hID0gY3JlZGVudGlhbFdpdGhBdHRhY2htZW50LmF1dGhlbnRpY2F0b3JBdHRhY2htZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgYW4gYXV0aGVudGljYXRpb24vdmVyaWZpY2F0aW9uIGNyZWRlbnRpYWwgcmVzcG9uc2UgdG8gc2VydmVyIGZvcm1hdC5cbiAqIFNlcmlhbGl6ZXMgYmluYXJ5IGZpZWxkcyB0byBiYXNlNjR1cmwgZm9yIEpTT04gdHJhbnNtaXNzaW9uLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyB0b0pTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge0F1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbH0gY3JlZGVudGlhbCAtIENyZWRlbnRpYWwgZnJvbSBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClcbiAqIEByZXR1cm5zIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlSlNPTn0gSlNPTi1zZXJpYWxpemFibGUgY3JlZGVudGlhbCBmb3Igc2VydmVyXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RvbS1wdWJsaWNrZXljcmVkZW50aWFsLXRvanNvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIHRvSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UoY3JlZGVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBDaGVjayBpZiB0aGUgY3JlZGVudGlhbCBpbnN0YW5jZSBoYXMgdGhlIHRvSlNPTiBtZXRob2RcbiAgICBpZiAoJ3RvSlNPTicgaW4gY3JlZGVudGlhbCAmJiB0eXBlb2YgY3JlZGVudGlhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWwudG9KU09OKCk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBjb252ZXJzaW9uIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdG9KU09OXG4gICAgLy8gQWNjZXNzIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHZpYSB0eXBlIGFzc2VydGlvbiB0byBoYW5kbGUgVHlwZVNjcmlwdCB2ZXJzaW9uIGRpZmZlcmVuY2VzXG4gICAgLy8gQHNpbXBsZXdlYmF1dGhuL3R5cGVzIGluY2x1ZGVzIHRoaXMgcHJvcGVydHkgYnV0IGJhc2UgVHlwZVNjcmlwdCA0LjcuNCBkb2Vzbid0XG4gICAgY29uc3QgY3JlZGVudGlhbFdpdGhBdHRhY2htZW50ID0gY3JlZGVudGlhbDtcbiAgICBjb25zdCBjbGllbnRFeHRlbnNpb25SZXN1bHRzID0gY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCk7XG4gICAgY29uc3QgYXNzZXJ0aW9uUmVzcG9uc2UgPSBjcmVkZW50aWFsLnJlc3BvbnNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByYXdJZDogY3JlZGVudGlhbC5pZCwgLy8gVzNDIHNwZWMgZXhwZWN0cyByYXdJZCB0byBtYXRjaCBpZCBmb3IgSlNPTiBmb3JtYXRcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0b3JEYXRhOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLmF1dGhlbnRpY2F0b3JEYXRhKSksXG4gICAgICAgICAgICBjbGllbnREYXRhSlNPTjogYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS5jbGllbnREYXRhSlNPTikpLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLnNpZ25hdHVyZSkpLFxuICAgICAgICAgICAgdXNlckhhbmRsZTogYXNzZXJ0aW9uUmVzcG9uc2UudXNlckhhbmRsZVxuICAgICAgICAgICAgICAgID8gYnl0ZXNUb0Jhc2U2NFVSTChuZXcgVWludDhBcnJheShhc3NlcnRpb25SZXNwb25zZS51c2VySGFuZGxlKSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3B1YmxpYy1rZXknLFxuICAgICAgICBjbGllbnRFeHRlbnNpb25SZXN1bHRzLFxuICAgICAgICAvLyBDb252ZXJ0IG51bGwgdG8gdW5kZWZpbmVkIGFuZCBjYXN0IHRvIEF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHR5cGVcbiAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6ICgoX2EgPSBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQuYXV0aGVudGljYXRvckF0dGFjaG1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCksXG4gICAgfTtcbn1cbi8qKlxuICogQSBzaW1wbGUgdGVzdCB0byBkZXRlcm1pbmUgaWYgYSBob3N0bmFtZSBpcyBhIHByb3Blcmx5LWZvcm1hdHRlZCBkb21haW4gbmFtZS5cbiAqIENvbnNpZGVycyBsb2NhbGhvc3QgdmFsaWQgZm9yIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAqXG4gKiBBIFwidmFsaWQgZG9tYWluXCIgaXMgZGVmaW5lZCBoZXJlOiBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3ZhbGlkLWRvbWFpblxuICpcbiAqIFJlZ2V4IHNvdXJjZWQgZnJvbSBoZXJlOlxuICogaHR0cHM6Ly93d3cub3JlaWxseS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MTQ0OTMyNzQ1My9jaDA4czE1Lmh0bWxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWUgLSBUaGUgaG9zdG5hbWUgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbGlkIGRvbWFpbiBvciBsb2NhbGhvc3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdmFsaWQtZG9tYWluIFdIQVRXRyBVUkwgU3BlYyAtIFZhbGlkIERvbWFpbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREb21haW4oaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gKFxuICAgIC8vIENvbnNpZGVyIGxvY2FsaG9zdCB2YWxpZCBhcyB3ZWxsIHNpbmNlIGl0J3Mgb2theSB3cnQgU2VjdXJlIENvbnRleHRzXG4gICAgaG9zdG5hbWUgPT09ICdsb2NhbGhvc3QnIHx8IC9eKFthLXowLTldKygtW2EtejAtOV0rKSpcXC4pK1thLXpdezIsfSQvaS50ZXN0KGhvc3RuYW1lKSk7XG59XG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIFdlYkF1dGhuLlxuICogQ2hlY2tzIGZvciBuZWNlc3NhcnkgV2ViIEFQSXM6IFB1YmxpY0tleUNyZWRlbnRpYWwgYW5kIENyZWRlbnRpYWwgTWFuYWdlbWVudC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBicm93c2VyIHN1cHBvcnRzIFdlYkF1dGhuXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVibGljS2V5Q3JlZGVudGlhbCNicm93c2VyX2NvbXBhdGliaWxpdHkgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbCBCcm93c2VyIENvbXBhdGliaWxpdHl9XG4gKi9cbmZ1bmN0aW9uIGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuICEhKGlzQnJvd3NlcigpICYmXG4gICAgICAgICdQdWJsaWNLZXlDcmVkZW50aWFsJyBpbiB3aW5kb3cgJiZcbiAgICAgICAgd2luZG93LlB1YmxpY0tleUNyZWRlbnRpYWwgJiZcbiAgICAgICAgJ2NyZWRlbnRpYWxzJyBpbiBuYXZpZ2F0b3IgJiZcbiAgICAgICAgdHlwZW9mICgoX2EgPSBuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuY3JlZGVudGlhbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGUpID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiAoKF9iID0gbmF2aWdhdG9yID09PSBudWxsIHx8IG5hdmlnYXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmF2aWdhdG9yLmNyZWRlbnRpYWxzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZSBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgdXNpbmcgdGhlIGJyb3dzZXIncyBjcmVkZW50aWFscyBBUEkuXG4gKiBXcmFwcyBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgd2l0aCBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBPcHRpb25zIGluY2x1ZGluZyBwdWJsaWNLZXkgcGFyYW1ldGVyc1xuICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdDxSZWdpc3RyYXRpb25DcmVkZW50aWFsLCBXZWJBdXRobkVycm9yPj59IENyZWF0ZWQgY3JlZGVudGlhbCBvciBlcnJvclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBDcmVhdGUgQ3JlZGVudGlhbH1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcmVkZW50aWFsc0NvbnRhaW5lci9jcmVhdGUgTUROIC0gY3JlZGVudGlhbHMuY3JlYXRlfVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ3JlZGVudGlhbChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSB0eXBlIGhlcmUgdW50aWwgdHlwZXNjcmlwdCB0eXBlcyBhcmUgdXBkYXRlZCAqL1xuICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0VtcHR5IGNyZWRlbnRpYWwgcmVzcG9uc2UnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUHVibGljS2V5Q3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdCcm93c2VyIHJldHVybmVkIHVuZXhwZWN0ZWQgY3JlZGVudGlhbCB0eXBlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIEdldCBhIFdlYkF1dGhuIGNyZWRlbnRpYWwgdXNpbmcgdGhlIGJyb3dzZXIncyBjcmVkZW50aWFscyBBUEkuXG4gKiBXcmFwcyBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KCkgd2l0aCBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbnMgaW5jbHVkaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PEF1dGhlbnRpY2F0aW9uQ3JlZGVudGlhbCwgV2ViQXV0aG5FcnJvcj4+fSBSZXRyaWV2ZWQgY3JlZGVudGlhbCBvciBlcnJvclxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWdldEFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEdldCBBc3NlcnRpb259XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3JlZGVudGlhbHNDb250YWluZXIvZ2V0IE1ETiAtIGNyZWRlbnRpYWxzLmdldH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENyZWRlbnRpYWwob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChcbiAgICAgICAgLyoqIHdlIGFzc2VydCB0aGUgdHlwZSBoZXJlIHVudGlsIHR5cGVzY3JpcHQgdHlwZXMgYXJlIHVwZGF0ZWQgKi9cbiAgICAgICAgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdFbXB0eSBjcmVkZW50aWFsIHJlc3BvbnNlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignQnJvd3NlciByZXR1cm5lZCB1bmV4cGVjdGVkIGNyZWRlbnRpYWwgdHlwZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UsIGVycm9yOiBudWxsIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICBlcnJvcjogaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9DUkVBVElPTl9PUFRJT05TID0ge1xuICAgIGhpbnRzOiBbJ3NlY3VyaXR5LWtleSddLFxuICAgIGF1dGhlbnRpY2F0b3JTZWxlY3Rpb246IHtcbiAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6ICdjcm9zcy1wbGF0Zm9ybScsXG4gICAgICAgIHJlcXVpcmVSZXNpZGVudEtleTogZmFsc2UsXG4gICAgICAgIC8qKiBzZXQgdG8gcHJlZmVycmVkIGJlY2F1c2Ugb2xkZXIgeXViaWtleXMgZG9uJ3QgaGF2ZSBQSU4vQmlvbWV0cmljICovXG4gICAgICAgIHVzZXJWZXJpZmljYXRpb246ICdwcmVmZXJyZWQnLFxuICAgICAgICByZXNpZGVudEtleTogJ2Rpc2NvdXJhZ2VkJyxcbiAgICB9LFxuICAgIGF0dGVzdGF0aW9uOiAnZGlyZWN0Jyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9SRVFVRVNUX09QVElPTlMgPSB7XG4gICAgLyoqIHNldCB0byBwcmVmZXJyZWQgYmVjYXVzZSBvbGRlciB5dWJpa2V5cyBkb24ndCBoYXZlIFBJTi9CaW9tZXRyaWMgKi9cbiAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICBoaW50czogWydzZWN1cml0eS1rZXknXSxcbiAgICBhdHRlc3RhdGlvbjogJ2RpcmVjdCcsXG59O1xuZnVuY3Rpb24gZGVlcE1lcmdlKC4uLnNvdXJjZXMpIHtcbiAgICBjb25zdCBpc09iamVjdCA9ICh2YWwpID0+IHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgIGNvbnN0IGlzQXJyYXlCdWZmZXJMaWtlID0gKHZhbCkgPT4gdmFsIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIGFycmF5IHJlZmVyZW5jZSwgaW5jbHVkaW5nIHVuaW9ucyBsaWtlIEF1dGhlbnRpY2F0b3JUcmFuc3BvcnRbXVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyTGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZXN1bHRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QoZXhpc3RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKGV4aXN0aW5nLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBNZXJnZXMgV2ViQXV0aG4gY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zIHdpdGggb3ZlcnJpZGVzLlxuICogU2V0cyBzZW5zaWJsZSBkZWZhdWx0cyBmb3IgYXV0aGVudGljYXRvciBzZWxlY3Rpb24gYW5kIGV4dGVuc2lvbnMuXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBiYXNlT3B0aW9ucyAtIFRoZSBiYXNlIG9wdGlvbnMgZnJvbSB0aGUgc2VydmVyXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE9wdGlvbmFsIG92ZXJyaWRlcyB0byBhcHBseVxuICogQHBhcmFtIHtzdHJpbmd9IGZyaWVuZGx5TmFtZSAtIE9wdGlvbmFsIGZyaWVuZGx5IG5hbWUgZm9yIHRoZSBjcmVkZW50aWFsXG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gTWVyZ2VkIGNyZWRlbnRpYWwgY3JlYXRpb24gb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkaWN0ZGVmLWF1dGhlbnRpY2F0b3JzZWxlY3Rpb25jcml0ZXJpYSBXM0MgV2ViQXV0aG4gU3BlYyAtIEF1dGhlbnRpY2F0b3JTZWxlY3Rpb25Dcml0ZXJpYX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhiYXNlT3B0aW9ucywgb3ZlcnJpZGVzKSB7XG4gICAgcmV0dXJuIGRlZXBNZXJnZShERUZBVUxUX0NSRUFUSU9OX09QVElPTlMsIGJhc2VPcHRpb25zLCBvdmVycmlkZXMgfHwge30pO1xufVxuLyoqXG4gKiBNZXJnZXMgV2ViQXV0aG4gY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMgd2l0aCBvdmVycmlkZXMuXG4gKiBTZXRzIHNlbnNpYmxlIGRlZmF1bHRzIGZvciB1c2VyIHZlcmlmaWNhdGlvbiBhbmQgaGludHMuXG4gKlxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IGJhc2VPcHRpb25zIC0gVGhlIGJhc2Ugb3B0aW9ucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBvdmVycmlkZXMgLSBPcHRpb25hbCBvdmVycmlkZXMgdG8gYXBwbHlcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IE1lcmdlZCBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9uc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNkaWN0ZGVmLXB1YmxpY2tleWNyZWRlbnRpYWxyZXF1ZXN0b3B0aW9ucyBXM0MgV2ViQXV0aG4gU3BlYyAtIFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKGJhc2VPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZGVlcE1lcmdlKERFRkFVTFRfUkVRVUVTVF9PUFRJT05TLCBiYXNlT3B0aW9ucywgb3ZlcnJpZGVzIHx8IHt9KTtcbn1cbi8qKlxuICogV2ViQXV0aG4gQVBJIHdyYXBwZXIgZm9yIFN1cGFiYXNlIEF1dGguXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBlbnJvbGxpbmcsIGNoYWxsZW5naW5nLCB2ZXJpZnlpbmcsIGF1dGhlbnRpY2F0aW5nLCBhbmQgcmVnaXN0ZXJpbmcgV2ViQXV0aG4gY3JlZGVudGlhbHMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vIFczQyBXZWJBdXRobiBTcGVjaWZpY2F0aW9ufVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYl9BdXRoZW50aWNhdGlvbl9BUEkgTUROIC0gV2ViIEF1dGhlbnRpY2F0aW9uIEFQSX1cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkF1dGhuQXBpIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIC8vIEJpbmQgYWxsIG1ldGhvZHMgc28gdGhleSBjYW4gYmUgZGVzdHJ1Y3R1cmVkXG4gICAgICAgIHRoaXMuZW5yb2xsID0gdGhpcy5fZW5yb2xsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2hhbGxlbmdlID0gdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudmVyaWZ5ID0gdGhpcy5fdmVyaWZ5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRlID0gdGhpcy5fYXV0aGVudGljYXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXIgPSB0aGlzLl9yZWdpc3Rlci5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnJvbGwgYSBuZXcgV2ViQXV0aG4gZmFjdG9yLlxuICAgICAqIENyZWF0ZXMgYW4gdW52ZXJpZmllZCBXZWJBdXRobiBmYWN0b3IgdGhhdCBtdXN0IGJlIHZlcmlmaWVkIHdpdGggYSBjcmVkZW50aWFsLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPbWl0PE1GQUVucm9sbFdlYmF1dGhuUGFyYW1zLCAnZmFjdG9yVHlwZSc+fSBwYXJhbXMgLSBFbnJvbGxtZW50IHBhcmFtZXRlcnMgKGZyaWVuZGx5TmFtZSByZXF1aXJlZClcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoTUZBRW5yb2xsV2ViYXV0aG5SZXNwb25zZT59IEVucm9sbGVkIGZhY3RvciBkZXRhaWxzIG9yIGVycm9yXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RlcmluZyBhIE5ldyBDcmVkZW50aWFsfVxuICAgICAqL1xuICAgIGFzeW5jIF9lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5tZmEuZW5yb2xsKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBmYWN0b3JUeXBlOiAnd2ViYXV0aG4nIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbGxlbmdlIGZvciBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9yIGF1dGhlbnRpY2F0aW9uLlxuICAgICAqIENvbWJpbmVzIHNlcnZlciBjaGFsbGVuZ2Ugd2l0aCBicm93c2VyIGNyZWRlbnRpYWwgb3BlcmF0aW9ucy5cbiAgICAgKiBIYW5kbGVzIGJvdGggcmVnaXN0cmF0aW9uIChjcmVhdGUpIGFuZCBhdXRoZW50aWNhdGlvbiAocmVxdWVzdCkgZmxvd3MuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge01GQUNoYWxsZW5nZVdlYmF1dGhuUGFyYW1zICYgeyBmcmllbmRseU5hbWU/OiBzdHJpbmc7IHNpZ25hbD86IEFib3J0U2lnbmFsIH19IHBhcmFtcyAtIENoYWxsZW5nZSBwYXJhbWV0ZXJzIGluY2x1ZGluZyBmYWN0b3JJZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgLSBBbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBwYXJhbWV0ZXJzIHBhc3NlZCB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHNcbiAgICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5jcmVhdGUgLSBPdmVycmlkZSBvcHRpb25zIGZvciBjcmVkZW50aWFsIGNyZWF0aW9uXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcy5yZXF1ZXN0IC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgY3JlZGVudGlhbCByZXF1ZXN0XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWVzdFJlc3VsdD59IENoYWxsZW5nZSByZXNwb25zZSB3aXRoIGNyZWRlbnRpYWwgb3IgZXJyb3JcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlZGVudGlhbC1jcmVhdGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWRlbnRpYWwgQ3JlYXRpb259XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXZlcmlmeWluZy1hc3NlcnRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBWZXJpZnlpbmcgQXNzZXJ0aW9ufVxuICAgICAqL1xuICAgIGFzeW5jIF9jaGFsbGVuZ2UoeyBmYWN0b3JJZCwgd2ViYXV0aG4sIGZyaWVuZGx5TmFtZSwgc2lnbmFsLCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgZnJvbSBzZXJ2ZXIgdXNpbmcgdGhlIGNsaWVudCdzIE1GQSBtZXRob2RzXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuY2xpZW50Lm1mYS5jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhYm9ydFNpZ25hbCA9IHNpZ25hbCAhPT0gbnVsbCAmJiBzaWduYWwgIT09IHZvaWQgMCA/IHNpZ25hbCA6IHdlYkF1dGhuQWJvcnRTZXJ2aWNlLmNyZWF0ZU5ld0Fib3J0U2lnbmFsKCk7XG4gICAgICAgICAgICAvKiogd2ViYXV0aG4gd2lsbCBmYWlsIGlmIGVpdGhlciBvZiB0aGUgbmFtZS9kaXNwbGF5bmFtZSBhcmUgYmxhbmsgKi9cbiAgICAgICAgICAgIGlmIChjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlID09PSAnY3JlYXRlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdXNlciB9ID0gY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleTtcbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLm5hbWUgPSBgJHt1c2VyLmlkfToke2ZyaWVuZGx5TmFtZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXVzZXIuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5kaXNwbGF5TmFtZSA9IHVzZXIubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjcmVhdGUnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSwgb3ZlcnJpZGVzID09PSBudWxsIHx8IG92ZXJyaWRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcnJpZGVzLmNyZWF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNyZWF0ZUNyZWRlbnRpYWwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBvcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcXVlc3QnOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5LCBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMucmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGdldENyZWRlbnRpYWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogb3B0aW9ucywgc2lnbmFsOiBhYm9ydFNpZ25hbCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdVbmV4cGVjdGVkIGVycm9yIGluIGNoYWxsZW5nZScsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZ5IGEgV2ViQXV0aG4gY3JlZGVudGlhbCB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICogQ29tcGxldGVzIHRoZSBXZWJBdXRobiBjZXJlbW9ueSBieSBzZW5kaW5nIHRoZSBjcmVkZW50aWFsIHRvIHRoZSBzZXJ2ZXIgZm9yIHZlcmlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBWZXJpZmljYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuY2hhbGxlbmdlSWQgLSBJRCBvZiB0aGUgY2hhbGxlbmdlIGJlaW5nIHZlcmlmaWVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5mYWN0b3JJZCAtIElEIG9mIHRoZSBXZWJBdXRobiBmYWN0b3JcbiAgICAgKiBAcGFyYW0ge01GQVZlcmlmeVdlYmF1dGhuUGFyYW1zPFQ+Wyd3ZWJhdXRobiddfSBwYXJhbXMud2ViYXV0aG4gLSBXZWJBdXRobiBjcmVkZW50aWFsIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXV0aE1GQVZlcmlmeVJlc3BvbnNlPn0gVmVyaWZpY2F0aW9uIHJlc3VsdCB3aXRoIHNlc3Npb24gb3IgZXJyb3JcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tdmVyaWZ5aW5nLWFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIFZlcmlmeWluZyBhbiBBdXRoZW50aWNhdGlvbiBBc3NlcnRpb259XG4gICAgICogKi9cbiAgICBhc3luYyBfdmVyaWZ5KHsgY2hhbGxlbmdlSWQsIGZhY3RvcklkLCB3ZWJhdXRobiwgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQubWZhLnZlcmlmeSh7XG4gICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgIGNoYWxsZW5nZUlkLFxuICAgICAgICAgICAgd2ViYXV0aG46IHdlYmF1dGhuLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgV2ViQXV0aG4gYXV0aGVudGljYXRpb24gZmxvdy5cbiAgICAgKiBQZXJmb3JtcyBjaGFsbGVuZ2UgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIGV4aXN0aW5nIGNyZWRlbnRpYWxzLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZhY3RvcklkIC0gSUQgb2YgdGhlIFdlYkF1dGhuIGZhY3RvciB0byBhdXRoZW50aWNhdGUgd2l0aFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMud2ViYXV0aG4gLSBXZWJBdXRobiBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy53ZWJhdXRobi5ycElkIC0gUmVseWluZyBQYXJ0eSBJRCAoZGVmYXVsdHMgdG8gY3VycmVudCBob3N0bmFtZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXJhbXMud2ViYXV0aG4ucnBPcmlnaW5zIC0gQWxsb3dlZCBvcmlnaW5zIChkZWZhdWx0cyB0byBjdXJyZW50IG9yaWdpbilcbiAgICAgKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBwYXJhbXMud2ViYXV0aG4uc2lnbmFsIC0gT3B0aW9uYWwgYWJvcnQgc2lnbmFsXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PEF1dGhNRkFWZXJpZnlSZXNwb25zZURhdGEsIFdlYkF1dGhuRXJyb3IgfCBBdXRoRXJyb3I+Pn0gQXV0aGVudGljYXRpb24gcmVzdWx0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWF1dGhlbnRpY2F0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gQXV0aGVudGljYXRpb24gQ2VyZW1vbnl9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyBNRE4gLSBQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnN9XG4gICAgICovXG4gICAgYXN5bmMgX2F1dGhlbnRpY2F0ZSh7IGZhY3RvcklkLCB3ZWJhdXRobjogeyBycElkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgOiB1bmRlZmluZWQsIHJwT3JpZ2lucyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gW3dpbmRvdy5sb2NhdGlvbi5vcmlnaW5dIDogdW5kZWZpbmVkLCBzaWduYWwsIH0gPSB7fSwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghcnBJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEVycm9yKCdycElkIGlzIHJlcXVpcmVkIGZvciBXZWJBdXRobiBhdXRoZW50aWNhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGNoYWxsZW5nZSBhbmQgY3JlZGVudGlhbFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHsgcnBJZCwgcnBPcmlnaW5zIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgfSwgeyByZXF1ZXN0OiBvdmVycmlkZXMgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdlYmF1dGhuIH0gPSBjaGFsbGVuZ2VSZXNwb25zZTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSBjcmVkZW50aWFsXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogd2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiB3ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGUnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbiBmbG93LlxuICAgICAqIFBlcmZvcm1zIGVucm9sbG1lbnQsIGNoYWxsZW5nZSwgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIG5ldyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZnJpZW5kbHlOYW1lIC0gVXNlci1mcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YSwgV2ViQXV0aG5FcnJvciB8IEF1dGhFcnJvcj4+fSBSZWdpc3RyYXRpb24gcmVzdWx0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RyYXRpb24gQ2VyZW1vbnl9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc31cbiAgICAgKi9cbiAgICBhc3luYyBfcmVnaXN0ZXIoeyBmcmllbmRseU5hbWUsIHdlYmF1dGhuOiB7IHJwSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IHVuZGVmaW5lZCwgcnBPcmlnaW5zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl0gOiB1bmRlZmluZWQsIHNpZ25hbCwgfSA9IHt9LCB9LCBvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKCFycElkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoRXJyb3IoJ3JwSWQgaXMgcmVxdWlyZWQgZm9yIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5yb2xsIGZhY3RvclxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBmYWN0b3IsIGVycm9yOiBlbnJvbGxFcnJvciB9ID0gYXdhaXQgdGhpcy5fZW5yb2xsKHtcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghZmFjdG9yKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGllbnQubWZhXG4gICAgICAgICAgICAgICAgICAgIC5saXN0RmFjdG9ycygpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmYWN0b3JzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IGZhY3RvcnMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFsbC5maW5kKCh2KSA9PiB2LmZhY3Rvcl90eXBlID09PSAnd2ViYXV0aG4nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2LmZyaWVuZGx5X25hbWUgPT09IGZyaWVuZGx5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5zdGF0dXMgIT09ICd1bnZlcmlmaWVkJyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKGZhY3RvcikgPT4gKGZhY3RvciA/IHRoaXMuY2xpZW50Lm1mYS51bmVucm9sbCh7IGZhY3RvcklkOiBmYWN0b3IgPT09IG51bGwgfHwgZmFjdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWN0b3IuaWQgfSkgOiB2b2lkIDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogZW5yb2xsRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjaGFsbGVuZ2UgYW5kIGNyZWF0ZSBjcmVkZW50aWFsXG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZVJlc3BvbnNlLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBmcmllbmRseU5hbWU6IGZhY3Rvci5mcmllbmRseV9uYW1lLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7IHJwSWQsIHJwT3JpZ2lucyB9LFxuICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBjcmVhdGU6IG92ZXJyaWRlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjaGFsbGVuZ2VSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQ6IGZhY3Rvci5pZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiByZWdpc3RlcicsIGVycm9yKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJhdXRobi5qcy5tYXAiXSwibmFtZXMiOlsiX19yZXN0IiwiYmFzZTY0VXJsVG9VaW50OEFycmF5IiwiYnl0ZXNUb0Jhc2U2NFVSTCIsIkF1dGhFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJpc0F1dGhFcnJvciIsImlzQnJvd3NlciIsImlkZW50aWZ5QXV0aGVudGljYXRpb25FcnJvciIsImlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IiLCJpc1dlYkF1dGhuRXJyb3IiLCJXZWJBdXRobkVycm9yIiwiV2ViQXV0aG5Vbmtub3duRXJyb3IiLCJXZWJBdXRobkFib3J0U2VydmljZSIsImNyZWF0ZU5ld0Fib3J0U2lnbmFsIiwiY29udHJvbGxlciIsImFib3J0RXJyb3IiLCJFcnJvciIsIm5hbWUiLCJhYm9ydCIsIm5ld0NvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJzaWduYWwiLCJjYW5jZWxDZXJlbW9ueSIsInVuZGVmaW5lZCIsIndlYkF1dGhuQWJvcnRTZXJ2aWNlIiwiZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIiwib3B0aW9ucyIsIlB1YmxpY0tleUNyZWRlbnRpYWwiLCJwYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIiwiY2hhbGxlbmdlIiwiY2hhbGxlbmdlU3RyIiwidXNlciIsInVzZXJPcHRzIiwiZXhjbHVkZUNyZWRlbnRpYWxzIiwicmVzdE9wdGlvbnMiLCJidWZmZXIiLCJPYmplY3QiLCJhc3NpZ24iLCJpZCIsInJlc3VsdCIsImxlbmd0aCIsIkFycmF5IiwiaSIsImNyZWQiLCJ0eXBlIiwidHJhbnNwb3J0cyIsImRlc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwicGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIiwiYWxsb3dDcmVkZW50aWFscyIsInNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlIiwiY3JlZGVudGlhbCIsIl9hIiwidG9KU09OIiwiY3JlZGVudGlhbFdpdGhBdHRhY2htZW50IiwicmF3SWQiLCJyZXNwb25zZSIsImF0dGVzdGF0aW9uT2JqZWN0IiwiVWludDhBcnJheSIsImNsaWVudERhdGFKU09OIiwiY2xpZW50RXh0ZW5zaW9uUmVzdWx0cyIsImdldENsaWVudEV4dGVuc2lvblJlc3VsdHMiLCJhdXRoZW50aWNhdG9yQXR0YWNobWVudCIsInNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UiLCJhc3NlcnRpb25SZXNwb25zZSIsImF1dGhlbnRpY2F0b3JEYXRhIiwic2lnbmF0dXJlIiwidXNlckhhbmRsZSIsImlzVmFsaWREb21haW4iLCJob3N0bmFtZSIsInRlc3QiLCJicm93c2VyU3VwcG9ydHNXZWJBdXRobiIsIl9iIiwid2luZG93IiwibmF2aWdhdG9yIiwiY3JlZGVudGlhbHMiLCJjcmVhdGUiLCJnZXQiLCJjcmVhdGVDcmVkZW50aWFsIiwiZGF0YSIsImVycm9yIiwiZXJyIiwiZ2V0Q3JlZGVudGlhbCIsIkRFRkFVTFRfQ1JFQVRJT05fT1BUSU9OUyIsImhpbnRzIiwiYXV0aGVudGljYXRvclNlbGVjdGlvbiIsInJlcXVpcmVSZXNpZGVudEtleSIsInVzZXJWZXJpZmljYXRpb24iLCJyZXNpZGVudEtleSIsImF0dGVzdGF0aW9uIiwiREVGQVVMVF9SRVFVRVNUX09QVElPTlMiLCJkZWVwTWVyZ2UiLCJzb3VyY2VzIiwiaXNPYmplY3QiLCJ2YWwiLCJpc0FycmF5IiwiaXNBcnJheUJ1ZmZlckxpa2UiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsInNvdXJjZSIsImtleSIsInZhbHVlIiwiZXhpc3RpbmciLCJtZXJnZUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMiLCJiYXNlT3B0aW9ucyIsIm92ZXJyaWRlcyIsIm1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwiV2ViQXV0aG5BcGkiLCJjb25zdHJ1Y3RvciIsImNsaWVudCIsImVucm9sbCIsIl9lbnJvbGwiLCJiaW5kIiwiX2NoYWxsZW5nZSIsInZlcmlmeSIsIl92ZXJpZnkiLCJhdXRoZW50aWNhdGUiLCJfYXV0aGVudGljYXRlIiwicmVnaXN0ZXIiLCJfcmVnaXN0ZXIiLCJwYXJhbXMiLCJtZmEiLCJmYWN0b3JUeXBlIiwiZmFjdG9ySWQiLCJ3ZWJhdXRobiIsImZyaWVuZGx5TmFtZSIsImNoYWxsZW5nZVJlc3BvbnNlIiwiY2hhbGxlbmdlRXJyb3IiLCJhYm9ydFNpZ25hbCIsImNyZWRlbnRpYWxfb3B0aW9ucyIsInB1YmxpY0tleSIsImRpc3BsYXlOYW1lIiwiY2hhbGxlbmdlSWQiLCJjcmVkZW50aWFsX3Jlc3BvbnNlIiwicmVxdWVzdCIsInJwSWQiLCJsb2NhdGlvbiIsInJwT3JpZ2lucyIsIm9yaWdpbiIsImZhY3RvciIsImVucm9sbEVycm9yIiwibGlzdEZhY3RvcnMiLCJ0aGVuIiwiZmFjdG9ycyIsImFsbCIsImZpbmQiLCJ2IiwiZmFjdG9yX3R5cGUiLCJmcmllbmRseV9uYW1lIiwic3RhdHVzIiwidW5lbnJvbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n\n\n\n/**\n * Client for invoking Supabase Edge Functions.\n */ class FunctionsClient {\n    /**\n     * Creates a new Functions client bound to an Edge Functions URL.\n     *\n     * @example\n     * ```ts\n     * import { FunctionsClient, FunctionRegion } from '@supabase/functions-js'\n     *\n     * const functions = new FunctionsClient('https://xyzcompany.supabase.co/functions/v1', {\n     *   headers: { apikey: 'public-anon-key' },\n     *   region: FunctionRegion.UsEast1,\n     * })\n     * ```\n     */ constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     * @example\n     * ```ts\n     * functions.setAuth(session.access_token)\n     * ```\n     */ setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     * @example\n     * ```ts\n     * const { data, error } = await functions.invoke('hello-world', {\n     *   body: { name: 'Ada' },\n     * })\n     * ```\n     */ invoke(functionName_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(functionName, options = {}) {\n            var _a;\n            let timeoutId;\n            let timeoutController;\n            try {\n                const { headers, method, body: functionArgs, signal, timeout } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(`${this.url}/${functionName}`);\n                if (region && region !== \"any\") {\n                    _headers[\"x-region\"] = region;\n                    url.searchParams.set(\"forceFunctionRegion\", region);\n                }\n                let body;\n                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n                    if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers[\"Content-Type\"] = \"application/octet-stream\";\n                        body = functionArgs;\n                    } else if (typeof functionArgs === \"string\") {\n                        // plain string\n                        _headers[\"Content-Type\"] = \"text/plain\";\n                        body = functionArgs;\n                    } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    } else {\n                        // default, assume this is JSON\n                        _headers[\"Content-Type\"] = \"application/json\";\n                        body = JSON.stringify(functionArgs);\n                    }\n                } else {\n                    if (functionArgs && typeof functionArgs !== \"string\" && !(typeof Blob !== \"undefined\" && functionArgs instanceof Blob) && !(functionArgs instanceof ArrayBuffer) && !(typeof FormData !== \"undefined\" && functionArgs instanceof FormData)) {\n                        body = JSON.stringify(functionArgs);\n                    } else {\n                        body = functionArgs;\n                    }\n                }\n                // Handle timeout by creating an AbortController\n                let effectiveSignal = signal;\n                if (timeout) {\n                    timeoutController = new AbortController();\n                    timeoutId = setTimeout(()=>timeoutController.abort(), timeout);\n                    // If user provided their own signal, we need to respect both\n                    if (signal) {\n                        effectiveSignal = timeoutController.signal;\n                        // If the user's signal is aborted, abort our timeout controller too\n                        signal.addEventListener(\"abort\", ()=>timeoutController.abort());\n                    } else {\n                        effectiveSignal = timeoutController.signal;\n                    }\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || \"POST\",\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal: effectiveSignal\n                }).catch((fetchError)=>{\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get(\"x-relay-error\");\n                if (isRelayError && isRelayError === \"true\") {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n                let data;\n                if (responseType === \"application/json\") {\n                    data = yield response.json();\n                } else if (responseType === \"application/octet-stream\" || responseType === \"application/pdf\") {\n                    data = yield response.blob();\n                } else if (responseType === \"text/event-stream\") {\n                    data = response;\n                } else if (responseType === \"multipart/form-data\") {\n                    data = yield response.formData();\n                } else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return {\n                    data,\n                    error: null,\n                    response\n                };\n            } catch (error) {\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError || error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError ? error.context : undefined\n                };\n            } finally{\n                // Clear the timeout if it was set\n                if (timeoutId) {\n                    clearTimeout(timeoutId);\n                }\n            }\n        });\n    }\n} //# sourceMappingURL=FunctionsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9GdW5jdGlvbnNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNNO0FBQ2dFO0FBQ3hHOztDQUVDLEdBQ00sTUFBTU07SUFDVDs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREMsWUFBWUMsR0FBRyxFQUFFLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFdBQVcsRUFBRUMsU0FBU1Qsa0RBQWNBLENBQUNVLEdBQUcsRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQy9FLElBQUksQ0FBQ0osR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0UsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0UsS0FBSyxHQUFHWixxREFBWUEsQ0FBQ1M7SUFDOUI7SUFDQTs7Ozs7OztLQU9DLEdBQ0RJLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxhQUFhLEdBQUcsQ0FBQyxPQUFPLEVBQUVELE1BQU0sQ0FBQztJQUNsRDtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDREUsT0FBT0MsY0FBYyxFQUFFO1FBQ25CLE9BQU9sQixnREFBU0EsQ0FBQyxJQUFJLEVBQUVtQixXQUFXLEtBQUssR0FBRyxVQUFXQyxZQUFZLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO1lBQzNFLElBQUlDO1lBQ0osSUFBSUM7WUFDSixJQUFJQztZQUNKLElBQUk7Z0JBQ0EsTUFBTSxFQUFFZixPQUFPLEVBQUVnQixNQUFNLEVBQUVDLE1BQU1DLFlBQVksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR1I7Z0JBQ2pFLElBQUlTLFdBQVcsQ0FBQztnQkFDaEIsSUFBSSxFQUFFbkIsTUFBTSxFQUFFLEdBQUdVO2dCQUNqQixJQUFJLENBQUNWLFFBQVE7b0JBQ1RBLFNBQVMsSUFBSSxDQUFDQSxNQUFNO2dCQUN4QjtnQkFDQSw4Q0FBOEM7Z0JBQzlDLE1BQU1ILE1BQU0sSUFBSXVCLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQ3ZCLEdBQUcsQ0FBQyxDQUFDLEVBQUVZLGFBQWEsQ0FBQztnQkFDakQsSUFBSVQsVUFBVUEsV0FBVyxPQUFPO29CQUM1Qm1CLFFBQVEsQ0FBQyxXQUFXLEdBQUduQjtvQkFDdkJILElBQUl3QixZQUFZLENBQUNDLEdBQUcsQ0FBQyx1QkFBdUJ0QjtnQkFDaEQ7Z0JBQ0EsSUFBSWU7Z0JBQ0osSUFBSUMsZ0JBQ0MsWUFBWSxDQUFDTyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDNUIsU0FBUyxtQkFBb0IsQ0FBQ0EsT0FBTSxHQUFJO29CQUMzRixJQUFJLE9BQVE2QixTQUFTLGVBQWVYLHdCQUF3QlcsUUFDeERYLHdCQUF3QlksYUFBYTt3QkFDckMsMkNBQTJDO3dCQUMzQyw4RUFBOEU7d0JBQzlFVCxRQUFRLENBQUMsZUFBZSxHQUFHO3dCQUMzQkosT0FBT0M7b0JBQ1gsT0FDSyxJQUFJLE9BQU9BLGlCQUFpQixVQUFVO3dCQUN2QyxlQUFlO3dCQUNmRyxRQUFRLENBQUMsZUFBZSxHQUFHO3dCQUMzQkosT0FBT0M7b0JBQ1gsT0FDSyxJQUFJLE9BQU9hLGFBQWEsZUFBZWIsd0JBQXdCYSxVQUFVO3dCQUMxRSxpQ0FBaUM7d0JBQ2pDLDBEQUEwRDt3QkFDMURkLE9BQU9DO29CQUNYLE9BQ0s7d0JBQ0QsK0JBQStCO3dCQUMvQkcsUUFBUSxDQUFDLGVBQWUsR0FBRzt3QkFDM0JKLE9BQU9lLEtBQUtDLFNBQVMsQ0FBQ2Y7b0JBQzFCO2dCQUNKLE9BQ0s7b0JBQ0QsSUFBSUEsZ0JBQ0EsT0FBT0EsaUJBQWlCLFlBQ3hCLENBQUUsUUFBT1csU0FBUyxlQUFlWCx3QkFBd0JXLElBQUcsS0FDNUQsQ0FBRVgsQ0FBQUEsd0JBQXdCWSxXQUFVLEtBQ3BDLENBQUUsUUFBT0MsYUFBYSxlQUFlYix3QkFBd0JhLFFBQU8sR0FBSTt3QkFDeEVkLE9BQU9lLEtBQUtDLFNBQVMsQ0FBQ2Y7b0JBQzFCLE9BQ0s7d0JBQ0RELE9BQU9DO29CQUNYO2dCQUNKO2dCQUNBLGdEQUFnRDtnQkFDaEQsSUFBSWdCLGtCQUFrQmY7Z0JBQ3RCLElBQUlDLFNBQVM7b0JBQ1RMLG9CQUFvQixJQUFJb0I7b0JBQ3hCckIsWUFBWXNCLFdBQVcsSUFBTXJCLGtCQUFrQnNCLEtBQUssSUFBSWpCO29CQUN4RCw2REFBNkQ7b0JBQzdELElBQUlELFFBQVE7d0JBQ1JlLGtCQUFrQm5CLGtCQUFrQkksTUFBTTt3QkFDMUMsb0VBQW9FO3dCQUNwRUEsT0FBT21CLGdCQUFnQixDQUFDLFNBQVMsSUFBTXZCLGtCQUFrQnNCLEtBQUs7b0JBQ2xFLE9BQ0s7d0JBQ0RILGtCQUFrQm5CLGtCQUFrQkksTUFBTTtvQkFDOUM7Z0JBQ0o7Z0JBQ0EsTUFBTW9CLFdBQVcsTUFBTSxJQUFJLENBQUNuQyxLQUFLLENBQUNMLElBQUl5QyxRQUFRLElBQUk7b0JBQzlDeEIsUUFBUUEsVUFBVTtvQkFDbEIscUNBQXFDO29CQUNyQywwQkFBMEI7b0JBQzFCLDBCQUEwQjtvQkFDMUIsaUNBQWlDO29CQUNqQ2hCLFNBQVN5QixPQUFPZ0IsTUFBTSxDQUFDaEIsT0FBT2dCLE1BQU0sQ0FBQ2hCLE9BQU9nQixNQUFNLENBQUMsQ0FBQyxHQUFHcEIsV0FBVyxJQUFJLENBQUNyQixPQUFPLEdBQUdBO29CQUNqRmlCO29CQUNBRSxRQUFRZTtnQkFDWixHQUFHUSxLQUFLLENBQUMsQ0FBQ0M7b0JBQ04sTUFBTSxJQUFJakQsdURBQW1CQSxDQUFDaUQ7Z0JBQ2xDO2dCQUNBLE1BQU1DLGVBQWVMLFNBQVN2QyxPQUFPLENBQUM2QyxHQUFHLENBQUM7Z0JBQzFDLElBQUlELGdCQUFnQkEsaUJBQWlCLFFBQVE7b0JBQ3pDLE1BQU0sSUFBSWhELHVEQUFtQkEsQ0FBQzJDO2dCQUNsQztnQkFDQSxJQUFJLENBQUNBLFNBQVNPLEVBQUUsRUFBRTtvQkFDZCxNQUFNLElBQUluRCxzREFBa0JBLENBQUM0QztnQkFDakM7Z0JBQ0EsSUFBSVEsZUFBZSxDQUFDLENBQUNsQyxLQUFLMEIsU0FBU3ZDLE9BQU8sQ0FBQzZDLEdBQUcsQ0FBQyxlQUFjLE1BQU8sUUFBUWhDLE9BQU8sS0FBSyxJQUFJQSxLQUFLLFlBQVcsRUFBR21DLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQyxJQUFJO2dCQUNqSSxJQUFJQztnQkFDSixJQUFJSCxpQkFBaUIsb0JBQW9CO29CQUNyQ0csT0FBTyxNQUFNWCxTQUFTWSxJQUFJO2dCQUM5QixPQUNLLElBQUlKLGlCQUFpQiw4QkFDdEJBLGlCQUFpQixtQkFBbUI7b0JBQ3BDRyxPQUFPLE1BQU1YLFNBQVNhLElBQUk7Z0JBQzlCLE9BQ0ssSUFBSUwsaUJBQWlCLHFCQUFxQjtvQkFDM0NHLE9BQU9YO2dCQUNYLE9BQ0ssSUFBSVEsaUJBQWlCLHVCQUF1QjtvQkFDN0NHLE9BQU8sTUFBTVgsU0FBU2MsUUFBUTtnQkFDbEMsT0FDSztvQkFDRCxrQkFBa0I7b0JBQ2xCSCxPQUFPLE1BQU1YLFNBQVNlLElBQUk7Z0JBQzlCO2dCQUNBLE9BQU87b0JBQUVKO29CQUFNSyxPQUFPO29CQUFNaEI7Z0JBQVM7WUFDekMsRUFDQSxPQUFPZ0IsT0FBTztnQkFDVixPQUFPO29CQUNITCxNQUFNO29CQUNOSztvQkFDQWhCLFVBQVVnQixpQkFBaUI1RCxzREFBa0JBLElBQUk0RCxpQkFBaUIzRCx1REFBbUJBLEdBQy9FMkQsTUFBTUMsT0FBTyxHQUNiQztnQkFDVjtZQUNKLFNBQ1E7Z0JBQ0osa0NBQWtDO2dCQUNsQyxJQUFJM0MsV0FBVztvQkFDWDRDLGFBQWE1QztnQkFDakI7WUFDSjtRQUNKO0lBQ0o7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tb2R1bGUvRnVuY3Rpb25zQ2xpZW50LmpzPzVjMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuL2hlbHBlcic7XG5pbXBvcnQgeyBGdW5jdGlvblJlZ2lvbiwgRnVuY3Rpb25zRmV0Y2hFcnJvciwgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCB9IGZyb20gJy4vdHlwZXMnO1xuLyoqXG4gKiBDbGllbnQgZm9yIGludm9raW5nIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb25zLlxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZ1bmN0aW9ucyBjbGllbnQgYm91bmQgdG8gYW4gRWRnZSBGdW5jdGlvbnMgVVJMLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCwgRnVuY3Rpb25SZWdpb24gfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QgZnVuY3Rpb25zID0gbmV3IEZ1bmN0aW9uc0NsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL2Z1bmN0aW9ucy92MScsIHtcbiAgICAgKiAgIGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuICAgICAqICAgcmVnaW9uOiBGdW5jdGlvblJlZ2lvbi5Vc0Vhc3QxLFxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJsLCB7IGhlYWRlcnMgPSB7fSwgY3VzdG9tRmV0Y2gsIHJlZ2lvbiA9IEZ1bmN0aW9uUmVnaW9uLkFueSwgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChjdXN0b21GZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGF1dGhvcml6YXRpb24gaGVhZGVyXG4gICAgICogQHBhcmFtIHRva2VuIC0gdGhlIG5ldyBqd3QgdG9rZW4gc2VudCBpbiB0aGUgYXV0aG9yaXNhdGlvbiBoZWFkZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogZnVuY3Rpb25zLnNldEF1dGgoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2V0QXV0aCh0b2tlbikge1xuICAgICAgICB0aGlzLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGEgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIGludm9raW5nIHRoZSBGdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZnVuY3Rpb25zLmludm9rZSgnaGVsbG8td29ybGQnLCB7XG4gICAgICogICBib2R5OiB7IG5hbWU6ICdBZGEnIH0sXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpbnZva2UoZnVuY3Rpb25OYW1lXzEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChmdW5jdGlvbk5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgbGV0IHRpbWVvdXRJZDtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0Q29udHJvbGxlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncywgc2lnbmFsLCB0aW1lb3V0IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlZ2lvbiBhcyBxdWVyeSBwYXJhbWV0ZXIgdXNpbmcgVVJMIEFQSVxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2ZvcmNlRnVuY3Rpb25SZWdpb24nLCByZWdpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICAgICAgICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uQXJncyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGZ1bmN0aW9uQXJncyAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgISh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGZ1bmN0aW9uQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aW1lb3V0IGJ5IGNyZWF0aW5nIGFuIEFib3J0Q29udHJvbGxlclxuICAgICAgICAgICAgICAgIGxldCBlZmZlY3RpdmVTaWduYWwgPSBzaWduYWw7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gdGltZW91dENvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHVzZXIgcHJvdmlkZWQgdGhlaXIgb3duIHNpZ25hbCwgd2UgbmVlZCB0byByZXNwZWN0IGJvdGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlU2lnbmFsID0gdGltZW91dENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIncyBzaWduYWwgaXMgYWJvcnRlZCwgYWJvcnQgb3VyIHRpbWVvdXQgY29udHJvbGxlciB0b29cbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRpbWVvdXRDb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0aXZlU2lnbmFsID0gdGltZW91dENvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5mZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCB8fCAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIGhlYWRlcnMgcHJpb3JpdHkgaXMgKGhpZ2ggdG8gbG93KTpcbiAgICAgICAgICAgICAgICAgICAgLy8gMS4gaW52b2tlLWxldmVsIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gMi4gY2xpZW50LWxldmVsIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gMy4gZGVmYXVsdCBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfaGVhZGVycyksIHRoaXMuaGVhZGVycyksIGhlYWRlcnMpLFxuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGVmZmVjdGl2ZVNpZ25hbCxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zRmV0Y2hFcnJvcihmZXRjaEVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlbGF5RXJyb3IgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1yZWxheS1lcnJvcicpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlbGF5RXJyb3IgJiYgaXNSZWxheUVycm9yID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc1JlbGF5RXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNIdHRwRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2VUeXBlID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RleHQvcGxhaW4nKS5zcGxpdCgnOycpWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyB8fFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVR5cGUgPT09ICdhcHBsaWNhdGlvbi9wZGYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ211bHRpcGFydC9mb3JtLWRhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5mb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsLCByZXNwb25zZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBlcnJvciBpbnN0YW5jZW9mIEZ1bmN0aW9uc0h0dHBFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEZ1bmN0aW9uc1JlbGF5RXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyb3IuY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSB0aW1lb3V0IGlmIGl0IHdhcyBzZXRcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuY3Rpb25zQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJyZXNvbHZlRmV0Y2giLCJGdW5jdGlvblJlZ2lvbiIsIkZ1bmN0aW9uc0ZldGNoRXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvbnNSZWxheUVycm9yIiwiRnVuY3Rpb25zQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiY3VzdG9tRmV0Y2giLCJyZWdpb24iLCJBbnkiLCJmZXRjaCIsInNldEF1dGgiLCJ0b2tlbiIsIkF1dGhvcml6YXRpb24iLCJpbnZva2UiLCJmdW5jdGlvbk5hbWVfMSIsImFyZ3VtZW50cyIsImZ1bmN0aW9uTmFtZSIsIm9wdGlvbnMiLCJfYSIsInRpbWVvdXRJZCIsInRpbWVvdXRDb250cm9sbGVyIiwibWV0aG9kIiwiYm9keSIsImZ1bmN0aW9uQXJncyIsInNpZ25hbCIsInRpbWVvdXQiLCJfaGVhZGVycyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIkJsb2IiLCJBcnJheUJ1ZmZlciIsIkZvcm1EYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsImVmZmVjdGl2ZVNpZ25hbCIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZXNwb25zZSIsInRvU3RyaW5nIiwiYXNzaWduIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwiaXNSZWxheUVycm9yIiwiZ2V0Iiwib2siLCJyZXNwb25zZVR5cGUiLCJzcGxpdCIsInRyaW0iLCJkYXRhIiwianNvbiIsImJsb2IiLCJmb3JtRGF0YSIsInRleHQiLCJlcnJvciIsImNvbnRleHQiLCJ1bmRlZmluZWQiLCJjbGVhclRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)\n/* harmony export */ });\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) {\n        return (...args)=>customFetch(...args);\n    }\n    return (...args)=>fetch(...args);\n}; //# sourceMappingURL=helper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9oZWxwZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLGVBQWUsQ0FBQ0M7SUFDekIsSUFBSUEsYUFBYTtRQUNiLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRCxlQUFlQztJQUN2QztJQUNBLE9BQU8sQ0FBQyxHQUFHQSxPQUFTQyxTQUFTRDtBQUNqQyxFQUFFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9oZWxwZXIuanM/YjY5NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcmVzb2x2ZUZldGNoID0gKGN1c3RvbUZldGNoKSA9PiB7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)\n/* harmony export */ });\n/**\n * Base error for Supabase Edge Function invocations.\n *\n * @example\n * ```ts\n * import { FunctionsError } from '@supabase/functions-js'\n *\n * throw new FunctionsError('Unexpected error invoking function', 'FunctionsError', {\n *   requestId: 'abc123',\n * })\n * ```\n */ class FunctionsError extends Error {\n    constructor(message, name = \"FunctionsError\", context){\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\n/**\n * Error thrown when the network request to an Edge Function fails.\n *\n * @example\n * ```ts\n * import { FunctionsFetchError } from '@supabase/functions-js'\n *\n * throw new FunctionsFetchError({ requestId: 'abc123' })\n * ```\n */ class FunctionsFetchError extends FunctionsError {\n    constructor(context){\n        super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n    }\n}\n/**\n * Error thrown when the Supabase relay cannot reach the Edge Function.\n *\n * @example\n * ```ts\n * import { FunctionsRelayError } from '@supabase/functions-js'\n *\n * throw new FunctionsRelayError({ region: 'us-east-1' })\n * ```\n */ class FunctionsRelayError extends FunctionsError {\n    constructor(context){\n        super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n    }\n}\n/**\n * Error thrown when the Edge Function returns a non-2xx status code.\n *\n * @example\n * ```ts\n * import { FunctionsHttpError } from '@supabase/functions-js'\n *\n * throw new FunctionsHttpError({ status: 500 })\n * ```\n */ class FunctionsHttpError extends FunctionsError {\n    constructor(context){\n        super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function(FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7Ozs7OztDQVdDLEdBQ00sTUFBTUEsdUJBQXVCQztJQUNoQ0MsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLGdCQUFnQixFQUFFQyxPQUFPLENBQUU7UUFDbkQsS0FBSyxDQUFDRjtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUMsNEJBQTRCTjtJQUNyQ0UsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxpREFBaUQsdUJBQXVCQTtJQUNsRjtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUUsNEJBQTRCUDtJQUNyQ0UsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQywwQ0FBMEMsdUJBQXVCQTtJQUMzRTtBQUNKO0FBQ0E7Ozs7Ozs7OztDQVNDLEdBQ00sTUFBTUcsMkJBQTJCUjtJQUNwQ0UsWUFBWUcsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQyxnREFBZ0Qsc0JBQXNCQTtJQUNoRjtBQUNKO0FBQ0EsNENBQTRDO0FBQ3JDLElBQUlJLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLE1BQU0sR0FBRztJQUN4QkEsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLFdBQVcsR0FBRztJQUM3QkEsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLGVBQWUsR0FBRztJQUNqQ0EsY0FBYyxDQUFDLGFBQWEsR0FBRztJQUMvQkEsY0FBYyxDQUFDLGFBQWEsR0FBRztJQUMvQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztBQUNoQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDLEtBQ3hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tb2R1bGUvdHlwZXMuanM/Njg4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgZXJyb3IgZm9yIFN1cGFiYXNlIEVkZ2UgRnVuY3Rpb24gaW52b2NhdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBGdW5jdGlvbnNFcnJvciB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnXG4gKlxuICogdGhyb3cgbmV3IEZ1bmN0aW9uc0Vycm9yKCdVbmV4cGVjdGVkIGVycm9yIGludm9raW5nIGZ1bmN0aW9uJywgJ0Z1bmN0aW9uc0Vycm9yJywge1xuICogICByZXF1ZXN0SWQ6ICdhYmMxMjMnLFxuICogfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbmFtZSA9ICdGdW5jdGlvbnNFcnJvcicsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aHJvd24gd2hlbiB0aGUgbmV0d29yayByZXF1ZXN0IHRvIGFuIEVkZ2UgRnVuY3Rpb24gZmFpbHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBGdW5jdGlvbnNGZXRjaEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAqXG4gKiB0aHJvdyBuZXcgRnVuY3Rpb25zRmV0Y2hFcnJvcih7IHJlcXVlc3RJZDogJ2FiYzEyMycgfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zRmV0Y2hFcnJvciBleHRlbmRzIEZ1bmN0aW9uc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKCdGYWlsZWQgdG8gc2VuZCBhIHJlcXVlc3QgdG8gdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zRmV0Y2hFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgdGhyb3duIHdoZW4gdGhlIFN1cGFiYXNlIHJlbGF5IGNhbm5vdCByZWFjaCB0aGUgRWRnZSBGdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEZ1bmN0aW9uc1JlbGF5RXJyb3IgfSBmcm9tICdAc3VwYWJhc2UvZnVuY3Rpb25zLWpzJ1xuICpcbiAqIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHsgcmVnaW9uOiAndXMtZWFzdC0xJyB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNSZWxheUVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ1JlbGF5IEVycm9yIGludm9raW5nIHRoZSBFZGdlIEZ1bmN0aW9uJywgJ0Z1bmN0aW9uc1JlbGF5RXJyb3InLCBjb250ZXh0KTtcbiAgICB9XG59XG4vKipcbiAqIEVycm9yIHRocm93biB3aGVuIHRoZSBFZGdlIEZ1bmN0aW9uIHJldHVybnMgYSBub24tMnh4IHN0YXR1cyBjb2RlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgRnVuY3Rpb25zSHR0cEVycm9yIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcydcbiAqXG4gKiB0aHJvdyBuZXcgRnVuY3Rpb25zSHR0cEVycm9yKHsgc3RhdHVzOiA1MDAgfSlcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zSHR0cEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ0VkZ2UgRnVuY3Rpb24gcmV0dXJuZWQgYSBub24tMnh4IHN0YXR1cyBjb2RlJywgJ0Z1bmN0aW9uc0h0dHBFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbi8vIERlZmluZSB0aGUgZW51bSBmb3IgdGhlICdyZWdpb24nIHByb3BlcnR5XG5leHBvcnQgdmFyIEZ1bmN0aW9uUmVnaW9uO1xuKGZ1bmN0aW9uIChGdW5jdGlvblJlZ2lvbikge1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQW55XCJdID0gXCJhbnlcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwTm9ydGhlYXN0MVwiXSA9IFwiYXAtbm9ydGhlYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwTm9ydGhlYXN0MlwiXSA9IFwiYXAtbm9ydGhlYXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGgxXCJdID0gXCJhcC1zb3V0aC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoZWFzdDFcIl0gPSBcImFwLXNvdXRoZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBcFNvdXRoZWFzdDJcIl0gPSBcImFwLXNvdXRoZWFzdC0yXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJDYUNlbnRyYWwxXCJdID0gXCJjYS1jZW50cmFsLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1Q2VudHJhbDFcIl0gPSBcImV1LWNlbnRyYWwtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0MVwiXSA9IFwiZXUtd2VzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QyXCJdID0gXCJldS13ZXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDNcIl0gPSBcImV1LXdlc3QtM1wiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiU2FFYXN0MVwiXSA9IFwic2EtZWFzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc0Vhc3QxXCJdID0gXCJ1cy1lYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzV2VzdDFcIl0gPSBcInVzLXdlc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNXZXN0MlwiXSA9IFwidXMtd2VzdC0yXCI7XG59KShGdW5jdGlvblJlZ2lvbiB8fCAoRnVuY3Rpb25SZWdpb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIkZ1bmN0aW9uc0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJuYW1lIiwiY29udGV4dCIsIkZ1bmN0aW9uc0ZldGNoRXJyb3IiLCJGdW5jdGlvbnNSZWxheUVycm9yIiwiRnVuY3Rpb25zSHR0cEVycm9yIiwiRnVuY3Rpb25SZWdpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   \"default\": () => (/* binding */ RealtimeChannel)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */ class RealtimeChannel {\n    /**\n     * Creates a channel that can broadcast messages, sync presence, and listen to Postgres changes.\n     *\n     * The topic determines which realtime stream you are subscribing to. Config options let you\n     * enable acknowledgement for broadcasts, presence tracking, or private channels.\n     *\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * const channel = new RealtimeChannel('realtime:public:messages', { config: {} }, client)\n     * ```\n     */ constructor(/** Topic name can be any string. */ topic, params = {\n        config: {}\n    }, socket){\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, \"\");\n        this.params.config = Object.assign({\n            broadcast: {\n                ack: false,\n                self: false\n            },\n            presence: {\n                key: \"\",\n                enabled: false\n            },\n            private: false\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive(\"ok\", ()=>{\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"timeout\", ()=>{\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"error\", (reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref)=>{\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n        }\n    }\n    /** Subscribe registers your client with the server */ subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate } } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), {\n                    enabled: presence_enabled\n                }),\n                postgres_changes,\n                private: isPrivate\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e)=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(()=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({\n                config\n            }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush.receive(\"ok\", async ({ postgres_changes })=>{\n                var _a;\n                // Only refresh auth if using callback-based tokens\n                if (!this.socket._isManualToken()) {\n                    this.socket.setAuth();\n                }\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                } else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for(let i = 0; i < bindingsLen; i++){\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter && serverPostgresFilter.event === event && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.schema, schema) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.table, table) && RealtimeChannel.isFilterValueEqual(serverPostgresFilter.filter, filter)) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                                id: serverPostgresFilter.id\n                            }));\n                        } else {\n                            this.unsubscribe();\n                            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(\"mismatch between server and client bindings for postgres changes\"));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            }).receive(\"error\", (error)=>{\n                this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n                return;\n            }).receive(\"timeout\", ()=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    /**\n     * Returns the current presence state for this channel.\n     *\n     * The shape is a map keyed by presence key (for example a user id) where each entry contains the\n     * tracked metadata for that user.\n     */ presenceState() {\n        return this.presence.state;\n    }\n    /**\n     * Sends the supplied payload to the presence tracker so other subscribers can see that this\n     * client is online. Use `untrack` to stop broadcasting presence for the same key.\n     */ async track(payload, opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"track\",\n            payload\n        }, opts.timeout || this.timeout);\n    }\n    /**\n     * Removes the current presence state for this client.\n     */ async untrack(opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"untrack\"\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log(\"channel\", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(async ()=>await this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a broadcast message explicitly via REST API.\n     *\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\n     *\n     * @param event The name of the broadcast event\n     * @param payload Payload to be sent (required)\n     * @param opts Options including timeout\n     * @returns Promise resolving to object with success status, and error details if failed\n     */ async httpSend(event, payload, opts = {}) {\n        var _a;\n        if (payload === undefined || payload === null) {\n            return Promise.reject(\"Payload is required for httpSend()\");\n        }\n        const headers = {\n            apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n            \"Content-Type\": \"application/json\"\n        };\n        if (this.socket.accessTokenValue) {\n            headers[\"Authorization\"] = `Bearer ${this.socket.accessTokenValue}`;\n        }\n        const options = {\n            method: \"POST\",\n            headers,\n            body: JSON.stringify({\n                messages: [\n                    {\n                        topic: this.subTopic,\n                        event,\n                        payload: payload,\n                        private: this.private\n                    }\n                ]\n            })\n        };\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        if (response.status === 202) {\n            return {\n                success: true\n            };\n        }\n        let errorMessage = response.statusText;\n        try {\n            const errorBody = await response.json();\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\n        } catch (_b) {}\n        return Promise.reject(new Error(errorMessage));\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */ async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === \"broadcast\") {\n            console.warn(\"Realtime send() is automatically falling back to REST API. \" + \"This behavior will be deprecated in the future. \" + \"Please use httpSend() explicitly for REST delivery.\");\n            const { event, payload: endpoint_payload } = args;\n            const headers = {\n                apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                \"Content-Type\": \"application/json\"\n            };\n            if (this.socket.accessTokenValue) {\n                headers[\"Authorization\"] = `Bearer ${this.socket.accessTokenValue}`;\n            }\n            const options = {\n                method: \"POST\",\n                headers,\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private\n                        }\n                    ]\n                })\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? \"ok\" : \"error\";\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    return \"timed out\";\n                } else {\n                    return \"error\";\n                }\n            }\n        } else {\n            return new Promise((resolve)=>{\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve(\"ok\");\n                }\n                push.receive(\"ok\", ()=>resolve(\"ok\"));\n                push.receive(\"error\", ()=>resolve(\"error\"));\n                push.receive(\"timeout\", ()=>resolve(\"timed out\"));\n            });\n        }\n    }\n    /**\n     * Updates the payload that will be sent the next time the channel joins (reconnects).\n     * Useful for rotating access tokens or updating config without re-creating the channel.\n     */ updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe(timeout = this.timeout) {\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = ()=>{\n            this.socket.log(\"channel\", `leave ${this.topic}`);\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve)=>{\n            leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush.receive(\"ok\", ()=>{\n                onClose();\n                resolve(\"ok\");\n            }).receive(\"timeout\", ()=>{\n                onClose();\n                resolve(\"timed out\");\n            }).receive(\"error\", ()=>{\n                resolve(\"error\");\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger(\"ok\", {});\n            }\n        }).finally(()=>{\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */ teardown() {\n        this.pushBuffer.forEach((push)=>push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */ async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n            signal: controller.signal\n        }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */ _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        } else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */ _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > _lib_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log(\"channel\", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */ _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */ _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */ _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */ _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n        }\n        if ([\n            \"insert\",\n            \"update\",\n            \"delete\"\n        ].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind)=>{\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === \"*\" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind)=>bind.callback(handledPayload, ref));\n        } else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind)=>{\n                var _a, _b, _c, _d, _e, _f;\n                if ([\n                    \"broadcast\",\n                    \"presence\",\n                    \"postgres_changes\"\n                ].includes(typeLower)) {\n                    if (\"id\" in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n                    } else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                } else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind)=>{\n                if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */ _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */ _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */ _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */ _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */ _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */ _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        } else {\n            this.bindings[typeLower] = [\n                binding\n            ];\n        }\n        return this;\n    }\n    /** @internal */ _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */ static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for(const k in obj1){\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Compares two optional filter values for equality.\n     * Treats undefined, null, and empty string as equivalent empty values.\n     * @internal\n     */ static isFilterValueEqual(serverValue, clientValue) {\n        const normalizedServer = serverValue !== null && serverValue !== void 0 ? serverValue : undefined;\n        const normalizedClient = clientValue !== null && clientValue !== void 0 ? clientValue : undefined;\n        return normalizedServer === normalizedClient;\n    }\n    /** @internal */ _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */ _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */ _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason)=>callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */ _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */ _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */ _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n} //# sourceMappingURL=RealtimeChannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQ3pEO0FBQ0U7QUFDa0I7QUFDQztBQUNFO0FBQzlDLElBQUlRLHVDQUF1QztBQUNqRCxVQUFVQSxzQ0FBc0M7SUFDN0NBLHNDQUFzQyxDQUFDLE1BQU0sR0FBRztJQUNoREEsc0NBQXNDLENBQUMsU0FBUyxHQUFHO0lBQ25EQSxzQ0FBc0MsQ0FBQyxTQUFTLEdBQUc7SUFDbkRBLHNDQUFzQyxDQUFDLFNBQVMsR0FBRztBQUN2RCxHQUFHQSwwQ0FBMkNBLENBQUFBLHlDQUF5QyxDQUFDO0FBQ2pGLElBQUlDLHNCQUFzQjtBQUNoQyxVQUFVQSxxQkFBcUI7SUFDNUJBLHFCQUFxQixDQUFDLFlBQVksR0FBRztJQUNyQ0EscUJBQXFCLENBQUMsV0FBVyxHQUFHO0lBQ3BDQSxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRztJQUM1Q0EscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ3RDLEdBQUdBLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDL0MsSUFBSUMsMEJBQTBCO0FBQ3BDLFVBQVVBLHlCQUF5QjtJQUNoQ0EseUJBQXlCLENBQUMsYUFBYSxHQUFHO0lBQzFDQSx5QkFBeUIsQ0FBQyxZQUFZLEdBQUc7SUFDekNBLHlCQUF5QixDQUFDLFNBQVMsR0FBRztJQUN0Q0EseUJBQXlCLENBQUMsZ0JBQWdCLEdBQUc7QUFDakQsR0FBR0EsNkJBQThCQSxDQUFBQSw0QkFBNEIsQ0FBQztBQUN2RCxNQUFNQywwQkFBMEJWLDBEQUFjQSxDQUFDO0FBQ3REOzs7O0NBSUMsR0FDYyxNQUFNVztJQUNqQjs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDREMsWUFDQSxrQ0FBa0MsR0FDbENDLEtBQUssRUFBRUMsU0FBUztRQUFFQyxRQUFRLENBQUM7SUFBRSxDQUFDLEVBQUVDLE1BQU0sQ0FBRTtR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QUksSUFBSSxDQUFDa0IsVUFBVSxJQUFJO1lBQ25CO1FBQ0o7UUFDQSxJQUFJLENBQUNyQyxNQUFNLENBQUNnTSxlQUFlLENBQUMsSUFBSSxDQUFDbk0sS0FBSztRQUN0QyxJQUFJLENBQUNPLEtBQUssR0FBR3BCLDBEQUFjQSxDQUFDb00sT0FBTztRQUNuQyxJQUFJLENBQUNoSyxRQUFRLENBQUM2SyxNQUFNLENBQUM5SztJQUN6QjtJQUNBLGNBQWMsR0FDZCtKLG1CQUFtQnRJLE9BQU8sRUFBRTtRQUN4QixNQUFNc0osVUFBVTtZQUNabEIsS0FBSyxDQUFDO1lBQ05DLEtBQUssQ0FBQztRQUNWO1FBQ0EsSUFBSXJJLFFBQVFzRCxJQUFJLEtBQUssWUFBWXRELFFBQVFzRCxJQUFJLEtBQUssVUFBVTtZQUN4RGdHLFFBQVFsQixHQUFHLEdBQUczTCxnRUFBOEIsQ0FBQ3VELFFBQVF3SixPQUFPLEVBQUV4SixRQUFReUosTUFBTTtRQUNoRjtRQUNBLElBQUl6SixRQUFRc0QsSUFBSSxLQUFLLFlBQVl0RCxRQUFRc0QsSUFBSSxLQUFLLFVBQVU7WUFDeERnRyxRQUFRakIsR0FBRyxHQUFHNUwsZ0VBQThCLENBQUN1RCxRQUFRd0osT0FBTyxFQUFFeEosUUFBUTBKLFVBQVU7UUFDcEY7UUFDQSxPQUFPSjtJQUNYO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDaGFubmVsLmpzP2VjNGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ0hBTk5FTF9FVkVOVFMsIENIQU5ORUxfU1RBVEVTLCBNQVhfUFVTSF9CVUZGRVJfU0laRSB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgUHVzaCBmcm9tICcuL2xpYi9wdXNoJztcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcic7XG5pbXBvcnQgUmVhbHRpbWVQcmVzZW5jZSBmcm9tICcuL1JlYWx0aW1lUHJlc2VuY2UnO1xuaW1wb3J0ICogYXMgVHJhbnNmb3JtZXJzIGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnO1xuZXhwb3J0IHZhciBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVDtcbihmdW5jdGlvbiAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQpIHtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkFMTFwiXSA9IFwiKlwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiSU5TRVJUXCJdID0gXCJJTlNFUlRcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIlVQREFURVwiXSA9IFwiVVBEQVRFXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJERUxFVEVcIl0gPSBcIkRFTEVURVwiO1xufSkoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgfHwgKFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UID0ge30pKTtcbmV4cG9ydCB2YXIgUkVBTFRJTUVfTElTVEVOX1RZUEVTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9MSVNURU5fVFlQRVMpIHtcbiAgICBSRUFMVElNRV9MSVNURU5fVFlQRVNbXCJCUk9BRENBU1RcIl0gPSBcImJyb2FkY2FzdFwiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlBSRVNFTkNFXCJdID0gXCJwcmVzZW5jZVwiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlBPU1RHUkVTX0NIQU5HRVNcIl0gPSBcInBvc3RncmVzX2NoYW5nZXNcIjtcbiAgICBSRUFMVElNRV9MSVNURU5fVFlQRVNbXCJTWVNURU1cIl0gPSBcInN5c3RlbVwiO1xufSkoUkVBTFRJTUVfTElTVEVOX1RZUEVTIHx8IChSRUFMVElNRV9MSVNURU5fVFlQRVMgPSB7fSkpO1xuZXhwb3J0IHZhciBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTKSB7XG4gICAgUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFU1tcIlNVQlNDUklCRURcIl0gPSBcIlNVQlNDUklCRURcIjtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiVElNRURfT1VUXCJdID0gXCJUSU1FRF9PVVRcIjtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiQ0xPU0VEXCJdID0gXCJDTE9TRURcIjtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiQ0hBTk5FTF9FUlJPUlwiXSA9IFwiQ0hBTk5FTF9FUlJPUlwiO1xufSkoUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyB8fCAoUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyA9IHt9KSk7XG5leHBvcnQgY29uc3QgUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMgPSBDSEFOTkVMX1NUQVRFUztcbi8qKiBBIGNoYW5uZWwgaXMgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrIG9mIFJlYWx0aW1lXG4gKiBhbmQgbmFycm93cyB0aGUgc2NvcGUgb2YgZGF0YSBmbG93IHRvIHN1YnNjcmliZWQgY2xpZW50cy5cbiAqIFlvdSBjYW4gdGhpbmsgb2YgYSBjaGFubmVsIGFzIGEgY2hhdHJvb20gd2hlcmUgcGFydGljaXBhbnRzIGFyZSBhYmxlIHRvIHNlZSB3aG8ncyBvbmxpbmVcbiAqIGFuZCBzZW5kIGFuZCByZWNlaXZlIG1lc3NhZ2VzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNoYW5uZWwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjaGFubmVsIHRoYXQgY2FuIGJyb2FkY2FzdCBtZXNzYWdlcywgc3luYyBwcmVzZW5jZSwgYW5kIGxpc3RlbiB0byBQb3N0Z3JlcyBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVGhlIHRvcGljIGRldGVybWluZXMgd2hpY2ggcmVhbHRpbWUgc3RyZWFtIHlvdSBhcmUgc3Vic2NyaWJpbmcgdG8uIENvbmZpZyBvcHRpb25zIGxldCB5b3VcbiAgICAgKiBlbmFibGUgYWNrbm93bGVkZ2VtZW50IGZvciBicm9hZGNhc3RzLCBwcmVzZW5jZSB0cmFja2luZywgb3IgcHJpdmF0ZSBjaGFubmVscy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBpbXBvcnQgUmVhbHRpbWVDbGllbnQgZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJ1xuICAgICAqXG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFJlYWx0aW1lQ2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVhbHRpbWUvdjEnLCB7XG4gICAgICogICBwYXJhbXM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuICAgICAqIH0pXG4gICAgICogY29uc3QgY2hhbm5lbCA9IG5ldyBSZWFsdGltZUNoYW5uZWwoJ3JlYWx0aW1lOnB1YmxpYzptZXNzYWdlcycsIHsgY29uZmlnOiB7fSB9LCBjbGllbnQpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gICAgdG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9LCBzb2NrZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnN1YlRvcGljID0gdG9waWMucmVwbGFjZSgvXnJlYWx0aW1lOi9pLCAnJyk7XG4gICAgICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYnJvYWRjYXN0OiB7IGFjazogZmFsc2UsIHNlbGY6IGZhbHNlIH0sXG4gICAgICAgICAgICBwcmVzZW5jZTogeyBrZXk6ICcnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgcHJpdmF0ZTogZmFsc2UsXG4gICAgICAgIH0sIHBhcmFtcy5jb25maWcpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5fcmVqb2luVW50aWxDb25uZWN0ZWQoKSwgdGhpcy5zb2NrZXQucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudCkgPT4gcHVzaEV2ZW50LnNlbmQoKSk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSm9pbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHRpbWVvdXQgJHt0aGlzLnRvcGljfWAsIHRoaXMuam9pblB1c2gudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ2Vycm9yJywgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIodGhpcy5fcmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UodGhpcyk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwgPSBodHRwRW5kcG9pbnRVUkwodGhpcy5zb2NrZXQuZW5kUG9pbnQpO1xuICAgICAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGUgJiYgKChfYiA9IChfYSA9IHRoaXMucGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxheSkpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byB1c2UgcmVwbGF5IG9uIHB1YmxpYyBjaGFubmVsICcke3RoaXMudG9waWN9Jy4gSXQgbXVzdCBiZSBhIHByaXZhdGUgY2hhbm5lbC5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgcmVnaXN0ZXJzIHlvdXIgY2xpZW50IHdpdGggdGhlIHNlcnZlciAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaywgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogeyBicm9hZGNhc3QsIHByZXNlbmNlLCBwcml2YXRlOiBpc1ByaXZhdGUgfSwgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNfY2hhbmdlcyA9IChfYiA9IChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocikgPT4gci5maWx0ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlX2VuYWJsZWQgPSAoISF0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0ubGVuZ3RoID4gMCkgfHxcbiAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5wYXJhbXMuY29uZmlnLnByZXNlbmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW5hYmxlZCkgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3QsXG4gICAgICAgICAgICAgICAgcHJlc2VuY2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJlc2VuY2UpLCB7IGVuYWJsZWQ6IHByZXNlbmNlX2VuYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgcG9zdGdyZXNfY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoKGUpID0+IGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIGUpKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0xPU0VEKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKE9iamVjdC5hc3NpZ24oeyBjb25maWcgfSwgYWNjZXNzVG9rZW5QYXlsb2FkKSk7XG4gICAgICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5qb2luUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlZnJlc2ggYXV0aCBpZiB1c2luZyBjYWxsYmFjay1iYXNlZCB0b2tlbnNcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc29ja2V0Ll9pc01hbnVhbFRva2VuKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0QXV0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zdGdyZXNfY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlNVQlNDUklCRUQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID0gdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kaW5nc0xlbiA9IChfYSA9IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IG51bGwgfHwgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpZW50UG9zdGdyZXNCaW5kaW5ncy5sZW5ndGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc3RncmVzQmluZGluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5kaW5nc0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRQb3N0Z3Jlc0JpbmRpbmcgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWx0ZXI6IHsgZXZlbnQsIHNjaGVtYSwgdGFibGUsIGZpbHRlciB9LCB9ID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VydmVyUG9zdGdyZXNGaWx0ZXIgPSBwb3N0Z3Jlc19jaGFuZ2VzICYmIHBvc3RncmVzX2NoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmVyUG9zdGdyZXNGaWx0ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5ldmVudCA9PT0gZXZlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNGaWx0ZXJWYWx1ZUVxdWFsKHNlcnZlclBvc3RncmVzRmlsdGVyLnNjaGVtYSwgc2NoZW1hKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIudGFibGUsIHRhYmxlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyUG9zdGdyZXNGaWx0ZXIuZmlsdGVyLCBmaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3UG9zdGdyZXNCaW5kaW5ncy5wdXNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2xpZW50UG9zdGdyZXNCaW5kaW5nKSwgeyBpZDogc2VydmVyUG9zdGdyZXNGaWx0ZXIuaWQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIG5ldyBFcnJvcignbWlzbWF0Y2ggYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudCBiaW5kaW5ncyBmb3IgcG9zdGdyZXMgY2hhbmdlcycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5kaW5ncy5wb3N0Z3Jlc19jaGFuZ2VzID0gbmV3UG9zdGdyZXNCaW5kaW5ncztcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmVycm9yZWQ7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0hBTk5FTF9FUlJPUiwgbmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KE9iamVjdC52YWx1ZXMoZXJyb3IpLmpvaW4oJywgJykgfHwgJ2Vycm9yJykpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLlRJTUVEX09VVCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgcHJlc2VuY2Ugc3RhdGUgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKlxuICAgICAqIFRoZSBzaGFwZSBpcyBhIG1hcCBrZXllZCBieSBwcmVzZW5jZSBrZXkgKGZvciBleGFtcGxlIGEgdXNlciBpZCkgd2hlcmUgZWFjaCBlbnRyeSBjb250YWlucyB0aGVcbiAgICAgKiB0cmFja2VkIG1ldGFkYXRhIGZvciB0aGF0IHVzZXIuXG4gICAgICovXG4gICAgcHJlc2VuY2VTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc2VuY2Uuc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSBzdXBwbGllZCBwYXlsb2FkIHRvIHRoZSBwcmVzZW5jZSB0cmFja2VyIHNvIG90aGVyIHN1YnNjcmliZXJzIGNhbiBzZWUgdGhhdCB0aGlzXG4gICAgICogY2xpZW50IGlzIG9ubGluZS4gVXNlIGB1bnRyYWNrYCB0byBzdG9wIGJyb2FkY2FzdGluZyBwcmVzZW5jZSBmb3IgdGhlIHNhbWUga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIHRyYWNrKHBheWxvYWQsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgICAgICBldmVudDogJ3RyYWNrJyxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgIH0sIG9wdHMudGltZW91dCB8fCB0aGlzLnRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBjdXJyZW50IHByZXNlbmNlIHN0YXRlIGZvciB0aGlzIGNsaWVudC5cbiAgICAgKi9cbiAgICBhc3luYyB1bnRyYWNrKG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIHR5cGU6ICdwcmVzZW5jZScsXG4gICAgICAgICAgICBldmVudDogJ3VudHJhY2snLFxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG4gICAgb24odHlwZSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmVkICYmIHR5cGUgPT09IFJFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRSkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHJlc3Vic2NyaWJlIHRvICR7dGhpcy50b3BpY30gZHVlIHRvIGNoYW5nZSBpbiBwcmVzZW5jZSBjYWxsYmFja3Mgb24gam9pbmVkIGNoYW5uZWxgKTtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKS50aGVuKGFzeW5jICgpID0+IGF3YWl0IHRoaXMuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBicm9hZGNhc3QgbWVzc2FnZSBleHBsaWNpdGx5IHZpYSBSRVNUIEFQSS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsd2F5cyB1c2VzIHRoZSBSRVNUIEFQSSBlbmRwb2ludCByZWdhcmRsZXNzIG9mIFdlYlNvY2tldCBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAqIFVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIGd1YXJhbnRlZSBSRVNUIGRlbGl2ZXJ5IG9yIHdoZW4gZ3JhZHVhbGx5IG1pZ3JhdGluZyBmcm9tIGltcGxpY2l0IFJFU1QgZmFsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGJyb2FkY2FzdCBldmVudFxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudCAocmVxdWlyZWQpXG4gICAgICogQHBhcmFtIG9wdHMgT3B0aW9ucyBpbmNsdWRpbmcgdGltZW91dFxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIG9iamVjdCB3aXRoIHN1Y2Nlc3Mgc3RhdHVzLCBhbmQgZXJyb3IgZGV0YWlscyBpZiBmYWlsZWRcbiAgICAgKi9cbiAgICBhc3luYyBodHRwU2VuZChldmVudCwgcGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHBheWxvYWQgPT09IHVuZGVmaW5lZCB8fCBwYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1BheWxvYWQgaXMgcmVxdWlyZWQgZm9yIGh0dHBTZW5kKCknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yQm9keS5lcnJvciB8fCBlcnJvckJvZHkubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGludG8gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBzZW5kXG4gICAgICogQHBhcmFtIGFyZ3MuZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGJlaW5nIHNlbnRcbiAgICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgdG8gYmUgdXNlZCBkdXJpbmcgdGhlIHNlbmQgcHJvY2Vzc1xuICAgICAqL1xuICAgIGFzeW5jIHNlbmQoYXJncywgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVhbHRpbWUgc2VuZCgpIGlzIGF1dG9tYXRpY2FsbHkgZmFsbGluZyBiYWNrIHRvIFJFU1QgQVBJLiAnICtcbiAgICAgICAgICAgICAgICAnVGhpcyBiZWhhdmlvciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4gJyArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSB1c2UgaHR0cFNlbmQoKSBleHBsaWNpdGx5IGZvciBSRVNUIGRlbGl2ZXJ5LicpO1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgYXBpa2V5OiB0aGlzLnNvY2tldC5hcGlLZXkgPyB0aGlzLnNvY2tldC5hcGlLZXkgOiAnJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke3RoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWV9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9mZXRjaFdpdGhUaW1lb3V0KHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwsIG9wdGlvbnMsIChfYSA9IG9wdHMudGltZW91dCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBhd2FpdCAoKF9iID0gcmVzcG9uc2UuYm9keSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbmNlbCgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyAnb2snIDogJ2Vycm9yJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd0aW1lZCBvdXQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdlcnJvcic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgY29uc3QgcHVzaCA9IHRoaXMuX3B1c2goYXJncy50eXBlLCBhcmdzLCBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoYXJncy50eXBlID09PSAnYnJvYWRjYXN0JyAmJiAhKChfYyA9IChfYiA9IChfYSA9IHRoaXMucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYnJvYWRjYXN0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ29rJywgKCkgPT4gcmVzb2x2ZSgnb2snKSk7XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHJlc29sdmUoJ2Vycm9yJykpO1xuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHJlc29sdmUoJ3RpbWVkIG91dCcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBheWxvYWQgdGhhdCB3aWxsIGJlIHNlbnQgdGhlIG5leHQgdGltZSB0aGUgY2hhbm5lbCBqb2lucyAocmVjb25uZWN0cykuXG4gICAgICogVXNlZnVsIGZvciByb3RhdGluZyBhY2Nlc3MgdG9rZW5zIG9yIHVwZGF0aW5nIGNvbmZpZyB3aXRob3V0IHJlLWNyZWF0aW5nIHRoZSBjaGFubmVsLlxuICAgICAqL1xuICAgIHVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5qb2luUHVzaC51cGRhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBzZXJ2ZXIgZXZlbnRzLCBhbmQgaW5zdHJ1Y3RzIGNoYW5uZWwgdG8gdGVybWluYXRlIG9uIHNlcnZlci5cbiAgICAgKiBUcmlnZ2VycyBvbkNsb3NlKCkgaG9va3MuXG4gICAgICpcbiAgICAgKiBUbyByZWNlaXZlIGxlYXZlIGFja25vd2xlZGdlbWVudHMsIHVzZSB0aGUgYSBgcmVjZWl2ZWAgaG9vayB0byBiaW5kIHRvIHRoZSBzZXJ2ZXIgYWNrLCBpZTpcbiAgICAgKiBjaGFubmVsLnVuc3Vic2NyaWJlKCkucmVjZWl2ZShcIm9rXCIsICgpID0+IGFsZXJ0KFwibGVmdCFcIikgKVxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgbGVhdmUgJHt0aGlzLnRvcGljfWApO1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5jbG9zZSwgJ2xlYXZlJywgdGhpcy5fam9pblJlZigpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5qb2luUHVzaC5kZXN0cm95KCk7XG4gICAgICAgIGxldCBsZWF2ZVB1c2ggPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGxlYXZlUHVzaCA9IG5ldyBQdXNoKHRoaXMsIENIQU5ORUxfRVZFTlRTLmxlYXZlLCB7fSwgdGltZW91dCk7XG4gICAgICAgICAgICBsZWF2ZVB1c2hcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoJ29rJyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCd0aW1lZCBvdXQnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoJ2Vycm9yJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxlYXZlUHVzaC5zZW5kKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NhblB1c2goKSkge1xuICAgICAgICAgICAgICAgIGxlYXZlUHVzaC50cmlnZ2VyKCdvaycsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBsZWF2ZVB1c2ggPT09IG51bGwgfHwgbGVhdmVQdXNoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWF2ZVB1c2guZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVhcmRvd24gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBEZXN0cm95cyBhbmQgc3RvcHMgcmVsYXRlZCB0aW1lcnMuXG4gICAgICovXG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlci5mb3JFYWNoKChwdXNoKSA9PiBwdXNoLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuam9pblB1c2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBhc3luYyBfZmV0Y2hXaXRoVGltZW91dCh1cmwsIG9wdGlvbnMsIHRpbWVvdXQpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zb2NrZXQuZmV0Y2godXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwgfSkpO1xuICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcHVzaChldmVudCwgcGF5bG9hZCwgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICBpZiAoIXRoaXMuam9pbmVkT25jZSkge1xuICAgICAgICAgICAgdGhyb3cgYHRyaWVkIHRvIHB1c2ggJyR7ZXZlbnR9JyB0byAnJHt0aGlzLnRvcGljfScgYmVmb3JlIGpvaW5pbmcuIFVzZSBjaGFubmVsLnN1YnNjcmliZSgpIGJlZm9yZSBwdXNoaW5nIGV2ZW50c2A7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHB1c2hFdmVudCA9IG5ldyBQdXNoKHRoaXMsIGV2ZW50LCBwYXlsb2FkLCB0aW1lb3V0KTtcbiAgICAgICAgaWYgKHRoaXMuX2NhblB1c2goKSkge1xuICAgICAgICAgICAgcHVzaEV2ZW50LnNlbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUHVzaEJ1ZmZlcihwdXNoRXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwdXNoRXZlbnQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYWRkVG9QdXNoQnVmZmVyKHB1c2hFdmVudCkge1xuICAgICAgICBwdXNoRXZlbnQuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlci5wdXNoKHB1c2hFdmVudCk7XG4gICAgICAgIC8vIEVuZm9yY2UgYnVmZmVyIHNpemUgbGltaXRcbiAgICAgICAgaWYgKHRoaXMucHVzaEJ1ZmZlci5sZW5ndGggPiBNQVhfUFVTSF9CVUZGRVJfU0laRSkge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFB1c2ggPSB0aGlzLnB1c2hCdWZmZXIuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkUHVzaCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRQdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZGlzY2FyZGVkIHB1c2ggZHVlIHRvIGJ1ZmZlciBvdmVyZmxvdzogJHtyZW1vdmVkUHVzaC5ldmVudH1gLCByZW1vdmVkUHVzaC5wYXlsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkYWJsZSBtZXNzYWdlIGhvb2tcbiAgICAgKlxuICAgICAqIFJlY2VpdmVzIGFsbCBldmVudHMgZm9yIHNwZWNpYWxpemVkIG1lc3NhZ2UgaGFuZGxpbmcgYmVmb3JlIGRpc3BhdGNoaW5nIHRvIHRoZSBjaGFubmVsIGNhbGxiYWNrcy5cbiAgICAgKiBNdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9vbk1lc3NhZ2UoX2V2ZW50LCBwYXlsb2FkLCBfcmVmKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzTWVtYmVyKHRvcGljKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcGljID09PSB0b3BpYztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9qb2luUmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qb2luUHVzaC5yZWY7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdHJpZ2dlcih0eXBlLCBwYXlsb2FkLCByZWYpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB7IGNsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW4gfSA9IENIQU5ORUxfRVZFTlRTO1xuICAgICAgICBjb25zdCBldmVudHMgPSBbY2xvc2UsIGVycm9yLCBsZWF2ZSwgam9pbl07XG4gICAgICAgIGlmIChyZWYgJiYgZXZlbnRzLmluZGV4T2YodHlwZUxvd2VyKSA+PSAwICYmIHJlZiAhPT0gdGhpcy5fam9pblJlZigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZWRQYXlsb2FkID0gdGhpcy5fb25NZXNzYWdlKHR5cGVMb3dlciwgcGF5bG9hZCwgcmVmKTtcbiAgICAgICAgaWYgKHBheWxvYWQgJiYgIWhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICB0aHJvdyAnY2hhbm5lbCBvbk1lc3NhZ2UgY2FsbGJhY2tzIG11c3QgcmV0dXJuIHRoZSBwYXlsb2FkLCBtb2RpZmllZCBvciB1bm1vZGlmaWVkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoWydpbnNlcnQnLCAndXBkYXRlJywgJ2RlbGV0ZSddLmluY2x1ZGVzKHR5cGVMb3dlcikpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudCkgPT09ICcqJyB8fCAoKF9jID0gKF9iID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ldmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSB0eXBlTG93ZXI7XG4gICAgICAgICAgICB9KS5tYXAoKGJpbmQpID0+IGJpbmQuY2FsbGJhY2soaGFuZGxlZFBheWxvYWQsIHJlZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKF9iID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgaWYgKFsnYnJvYWRjYXN0JywgJ3ByZXNlbmNlJywgJ3Bvc3RncmVzX2NoYW5nZXMnXS5pbmNsdWRlcyh0eXBlTG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgnaWQnIGluIGJpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRJZCA9IGJpbmQuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kRXZlbnQgPSAoX2EgPSBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChiaW5kSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9iID0gcGF5bG9hZC5pZHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbmNsdWRlcyhiaW5kSWQpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChiaW5kRXZlbnQgPT09ICcqJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSBudWxsIHx8IGJpbmRFdmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmluZEV2ZW50LnRvTG9jYWxlTG93ZXJDYXNlKCkpID09PSAoKF9jID0gcGF5bG9hZC5kYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9lID0gKF9kID0gYmluZCA9PT0gbnVsbCB8fCBiaW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiaW5kLmZpbHRlcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmV2ZW50KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kRXZlbnQgPT09ICcqJyB8fCBiaW5kRXZlbnQgPT09ICgoX2YgPSBwYXlsb2FkID09PSBudWxsIHx8IHBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBheWxvYWQuZXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpbmQudHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpID09PSB0eXBlTG93ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkubWFwKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBoYW5kbGVkUGF5bG9hZCA9PT0gJ29iamVjdCcgJiYgJ2lkcycgaW4gaGFuZGxlZFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNDaGFuZ2VzID0gaGFuZGxlZFBheWxvYWQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEsIHRhYmxlLCBjb21taXRfdGltZXN0YW1wLCB0eXBlLCBlcnJvcnMgfSA9IHBvc3RncmVzQ2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5yaWNoZWRQYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJsZTogdGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21taXRfdGltZXN0YW1wOiBjb21taXRfdGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3OiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZFBheWxvYWQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVucmljaGVkUGF5bG9hZCksIHRoaXMuX2dldFBheWxvYWRSZWNvcmRzKHBvc3RncmVzQ2hhbmdlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0pvaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmpvaW5lZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0pvaW5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luaW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2lzTGVhdmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IENIQU5ORUxfU1RBVEVTLmxlYXZpbmc7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVwbHlFdmVudE5hbWUocmVmKSB7XG4gICAgICAgIHJldHVybiBgY2hhbl9yZXBseV8ke3JlZn1gO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZUxvd2VyLFxuICAgICAgICAgICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0pIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXS5wdXNoKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gW2JpbmRpbmddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29mZih0eXBlLCBmaWx0ZXIpIHtcbiAgICAgICAgY29uc3QgdHlwZUxvd2VyID0gdHlwZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0gPSB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0uZmlsdGVyKChiaW5kKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAhKCgoX2EgPSBiaW5kLnR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gdHlwZUxvd2VyICYmXG4gICAgICAgICAgICAgICAgICAgIFJlYWx0aW1lQ2hhbm5lbC5pc0VxdWFsKGJpbmQuZmlsdGVyLCBmaWx0ZXIpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGlzRXF1YWwob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqMSkubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gb2JqMSkge1xuICAgICAgICAgICAgaWYgKG9iajFba10gIT09IG9iajJba10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byBvcHRpb25hbCBmaWx0ZXIgdmFsdWVzIGZvciBlcXVhbGl0eS5cbiAgICAgKiBUcmVhdHMgdW5kZWZpbmVkLCBudWxsLCBhbmQgZW1wdHkgc3RyaW5nIGFzIGVxdWl2YWxlbnQgZW1wdHkgdmFsdWVzLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBpc0ZpbHRlclZhbHVlRXF1YWwoc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTZXJ2ZXIgPSBzZXJ2ZXJWYWx1ZSAhPT0gbnVsbCAmJiBzZXJ2ZXJWYWx1ZSAhPT0gdm9pZCAwID8gc2VydmVyVmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRDbGllbnQgPSBjbGllbnRWYWx1ZSAhPT0gbnVsbCAmJiBjbGllbnRWYWx1ZSAhPT0gdm9pZCAwID8gY2xpZW50VmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkU2VydmVyID09PSBub3JtYWxpemVkQ2xpZW50O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uKSA9PiBjYWxsYmFjayhyZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jYW5QdXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQucmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQub2xkX3JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6WyJDSEFOTkVMX0VWRU5UUyIsIkNIQU5ORUxfU1RBVEVTIiwiTUFYX1BVU0hfQlVGRkVSX1NJWkUiLCJQdXNoIiwiVGltZXIiLCJSZWFsdGltZVByZXNlbmNlIiwiVHJhbnNmb3JtZXJzIiwiaHR0cEVuZHBvaW50VVJMIiwiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCJSRUFMVElNRV9MSVNURU5fVFlQRVMiLCJSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIiwiUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMiLCJSZWFsdGltZUNoYW5uZWwiLCJjb25zdHJ1Y3RvciIsInRvcGljIiwicGFyYW1zIiwiY29uZmlnIiwic29ja2V0IiwiX2EiLCJfYiIsImJpbmRpbmdzIiwic3RhdGUiLCJjbG9zZWQiLCJqb2luZWRPbmNlIiwicHVzaEJ1ZmZlciIsInN1YlRvcGljIiwicmVwbGFjZSIsIk9iamVjdCIsImFzc2lnbiIsImJyb2FkY2FzdCIsImFjayIsInNlbGYiLCJwcmVzZW5jZSIsImtleSIsImVuYWJsZWQiLCJwcml2YXRlIiwidGltZW91dCIsImpvaW5QdXNoIiwiam9pbiIsInJlam9pblRpbWVyIiwiX3Jlam9pblVudGlsQ29ubmVjdGVkIiwicmVjb25uZWN0QWZ0ZXJNcyIsInJlY2VpdmUiLCJqb2luZWQiLCJyZXNldCIsImZvckVhY2giLCJwdXNoRXZlbnQiLCJzZW5kIiwiX29uQ2xvc2UiLCJsb2ciLCJfam9pblJlZiIsIl9yZW1vdmUiLCJfb25FcnJvciIsInJlYXNvbiIsIl9pc0xlYXZpbmciLCJfaXNDbG9zZWQiLCJlcnJvcmVkIiwic2NoZWR1bGVUaW1lb3V0IiwiX2lzSm9pbmluZyIsIl9vbiIsInJlcGx5IiwicGF5bG9hZCIsInJlZiIsIl90cmlnZ2VyIiwiX3JlcGx5RXZlbnROYW1lIiwiYnJvYWRjYXN0RW5kcG9pbnRVUkwiLCJlbmRQb2ludCIsInJlcGxheSIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwiX2MiLCJpc0Nvbm5lY3RlZCIsImNvbm5lY3QiLCJpc1ByaXZhdGUiLCJwb3N0Z3Jlc19jaGFuZ2VzIiwibWFwIiwiciIsImZpbHRlciIsInByZXNlbmNlX2VuYWJsZWQiLCJQUkVTRU5DRSIsImxlbmd0aCIsImFjY2Vzc1Rva2VuUGF5bG9hZCIsImFjY2Vzc1Rva2VuVmFsdWUiLCJhY2Nlc3NfdG9rZW4iLCJlIiwiQ0hBTk5FTF9FUlJPUiIsIkNMT1NFRCIsInVwZGF0ZUpvaW5QYXlsb2FkIiwiX3Jlam9pbiIsIl9pc01hbnVhbFRva2VuIiwic2V0QXV0aCIsInVuZGVmaW5lZCIsIlNVQlNDUklCRUQiLCJjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzIiwiYmluZGluZ3NMZW4iLCJuZXdQb3N0Z3Jlc0JpbmRpbmdzIiwiaSIsImNsaWVudFBvc3RncmVzQmluZGluZyIsImV2ZW50Iiwic2NoZW1hIiwidGFibGUiLCJzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlciIsImlzRmlsdGVyVmFsdWVFcXVhbCIsInB1c2giLCJpZCIsInVuc3Vic2NyaWJlIiwiRXJyb3IiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2YWx1ZXMiLCJUSU1FRF9PVVQiLCJwcmVzZW5jZVN0YXRlIiwidHJhY2siLCJvcHRzIiwidHlwZSIsInVudHJhY2siLCJvbiIsInRoZW4iLCJodHRwU2VuZCIsIlByb21pc2UiLCJyZWplY3QiLCJoZWFkZXJzIiwiYXBpa2V5IiwiYXBpS2V5Iiwib3B0aW9ucyIsIm1ldGhvZCIsImJvZHkiLCJtZXNzYWdlcyIsInJlc3BvbnNlIiwiX2ZldGNoV2l0aFRpbWVvdXQiLCJzdGF0dXMiLCJzdWNjZXNzIiwiZXJyb3JNZXNzYWdlIiwic3RhdHVzVGV4dCIsImVycm9yQm9keSIsImpzb24iLCJtZXNzYWdlIiwiYXJncyIsIl9jYW5QdXNoIiwiY29uc29sZSIsIndhcm4iLCJlbmRwb2ludF9wYXlsb2FkIiwiY2FuY2VsIiwib2siLCJuYW1lIiwicmVzb2x2ZSIsIl9wdXNoIiwidXBkYXRlUGF5bG9hZCIsImxlYXZpbmciLCJvbkNsb3NlIiwiY2xvc2UiLCJkZXN0cm95IiwibGVhdmVQdXNoIiwibGVhdmUiLCJ0cmlnZ2VyIiwiZmluYWxseSIsInRlYXJkb3duIiwidXJsIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsImZldGNoIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0IiwiX2FkZFRvUHVzaEJ1ZmZlciIsInN0YXJ0VGltZW91dCIsInJlbW92ZWRQdXNoIiwic2hpZnQiLCJfb25NZXNzYWdlIiwiX2V2ZW50IiwiX3JlZiIsIl9pc01lbWJlciIsInR5cGVMb3dlciIsInRvTG9jYWxlTG93ZXJDYXNlIiwiZXZlbnRzIiwiaW5kZXhPZiIsImhhbmRsZWRQYXlsb2FkIiwiaW5jbHVkZXMiLCJiaW5kIiwiX2QiLCJfZSIsIl9mIiwiYmluZElkIiwiYmluZEV2ZW50IiwiaWRzIiwiZGF0YSIsInBvc3RncmVzQ2hhbmdlcyIsImNvbW1pdF90aW1lc3RhbXAiLCJlcnJvcnMiLCJlbnJpY2hlZFBheWxvYWQiLCJldmVudFR5cGUiLCJuZXciLCJvbGQiLCJfZ2V0UGF5bG9hZFJlY29yZHMiLCJfaXNKb2luZWQiLCJqb2luaW5nIiwiYmluZGluZyIsIl9vZmYiLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJrZXlzIiwiayIsInNlcnZlclZhbHVlIiwiY2xpZW50VmFsdWUiLCJub3JtYWxpemVkU2VydmVyIiwibm9ybWFsaXplZENsaWVudCIsIl9sZWF2ZU9wZW5Ub3BpYyIsInJlc2VuZCIsInJlY29yZHMiLCJjb252ZXJ0Q2hhbmdlRGF0YSIsImNvbHVtbnMiLCJyZWNvcmQiLCJvbGRfcmVjb3JkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RealtimeClient)\n/* harmony export */ });\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/serializer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\n\nconst noop = ()=>{};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [\n    1000,\n    2000,\n    5000,\n    10000\n];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status and latency.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     * @example\n     * ```ts\n     * import RealtimeClient from '@supabase/realtime-js'\n     *\n     * const client = new RealtimeClient('https://xyzcompany.supabase.co/realtime/v1', {\n     *   params: { apikey: 'public-anon-key' },\n     * })\n     * client.connect()\n     * ```\n     */ constructor(endPoint, options){\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this._manuallySetToken = false;\n        this.channels = new Array();\n        this.endPoint = \"\";\n        this.httpEndpoint = \"\";\n        /** @deprecated headers cannot be set on websocket connections */ this.headers = {};\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.vsn = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VSN;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.accessToken = null;\n        this._connectionState = \"disconnected\";\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        this._heartbeatSentAt = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */ this._resolveFetch = (customFetch)=>{\n            if (customFetch) {\n                return (...args)=>customFetch(...args);\n            }\n            return (...args)=>fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error(\"API key is required to connect to Realtime\");\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n            return;\n        }\n        this._setConnectionState(\"connecting\");\n        // Trigger auth if needed and not already in progress\n        // This ensures auth is called for standalone RealtimeClient usage\n        // while avoiding race conditions with SupabaseClient's immediate setAuth call\n        if (this.accessToken && !this._authPromise) {\n            this._setAuthSafely(\"connect\");\n        }\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        } else {\n            // Try to use native WebSocket\n            try {\n                this.conn = _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createWebSocket(this.endpointURL());\n            } catch (error) {\n                this._setConnectionState(\"disconnected\");\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes(\"Node.js\")) {\n                    throw new Error(`${errorMessage}\\n\\n` + \"To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n\" + \"Option 1: Use Node.js 22+ which has native WebSocket support\\n\" + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + \"  npm install ws\\n\\n\" + '  import ws from \"ws\"\\n' + \"  const client = new RealtimeClient(url, {\\n\" + \"    ...options,\\n\" + \"    transport: ws\\n\" + \"  })\");\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */ endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: this.vsn\n        }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState(\"disconnecting\", true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(()=>{\n                this._setConnectionState(\"disconnected\");\n            }, 100);\n            this.conn.onclose = ()=>{\n                clearTimeout(fallbackTimer);\n                this._setConnectionState(\"disconnected\");\n            };\n            // Close the WebSocket connection if close method exists\n            if (typeof this.conn.close === \"function\") {\n                if (code) {\n                    this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n                } else {\n                    this.conn.close();\n                }\n            }\n            this._teardownConnection();\n        } else {\n            this._setConnectionState(\"disconnected\");\n        }\n    }\n    /**\n     * Returns all created channels\n     */ getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */ async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */ async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */ isConnecting() {\n        return this._connectionState === \"connecting\";\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */ isDisconnecting() {\n        return this._connectionState === \"disconnecting\";\n    }\n    /**\n     * Creates (or reuses) a {@link RealtimeChannel} for the provided topic.\n     *\n     * Topics are automatically prefixed with `realtime:` to match the Realtime service.\n     * If a channel with the same topic already exists it will be returned instead of creating\n     * a duplicate connection.\n     */ channel(topic, params = {\n        config: {}\n    }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c)=>c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__[\"default\"](`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        } else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        } else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * When a token is explicitly provided, it will be preserved across channel operations\n     * (including removeChannel and resubscribe). The `accessToken` callback will not be\n     * invoked until `setAuth()` is called without arguments.\n     *\n     * @param token A JWT string to override the token set on the client.\n     *\n     * @example\n     * // Use a manual token (preserved across resubscribes, ignores accessToken callback)\n     * client.realtime.setAuth('my-custom-jwt')\n     *\n     * // Switch back to using the accessToken callback\n     * client.realtime.setAuth()\n     */ async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        } finally{\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Returns true if the current access token was explicitly set via setAuth(token),\n     * false if it was obtained via the accessToken callback.\n     * @internal\n     */ _isManualToken() {\n        return this._manuallySetToken;\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */ async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback(\"disconnected\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this._heartbeatSentAt = null;\n            this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n            try {\n                this.heartbeatCallback(\"timeout\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CLOSE_NORMAL, \"heartbeat timeout\");\n            setTimeout(()=>{\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this._heartbeatSentAt = Date.now();\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        try {\n            this.heartbeatCallback(\"sent\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n        this._setAuthSafely(\"heartbeat\");\n    }\n    /**\n     * Sets a callback that receives lifecycle events for internal heartbeat messages.\n     * Useful for instrumenting connection health (e.g. sent/ok/timeout/disconnected).\n     */ onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */ flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */ _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        } else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */ _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */ _remove(channel) {\n        this.channels = this.channels.filter((c)=>c.topic !== channel.topic);\n    }\n    /** @internal */ _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            // Handle heartbeat responses\n            if (msg.topic === \"phoenix\" && msg.event === \"phx_reply\" && msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                const latency = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : undefined;\n                try {\n                    this.heartbeatCallback(msg.payload.status === \"ok\" ? \"ok\" : \"error\", latency);\n                } catch (e) {\n                    this.log(\"error\", \"error in heartbeat callback\", e);\n                }\n                this._heartbeatSentAt = null;\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : \"\";\n            const status = payload.status || \"\";\n            this.log(\"receive\", `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks(\"message\", msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */ _clearTimer(timer) {\n        var _a;\n        if (timer === \"heartbeat\" && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        } else if (timer === \"reconnect\") {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */ _clearAllTimers() {\n        this._clearTimer(\"heartbeat\");\n        this._clearTimer(\"reconnect\");\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */ _setupConnectionHandlers() {\n        if (!this.conn) return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if (\"binaryType\" in this.conn) {\n            ;\n            this.conn.binaryType = \"arraybuffer\";\n        }\n        this.conn.onopen = ()=>this._onConnOpen();\n        this.conn.onerror = (error)=>this._onConnError(error);\n        this.conn.onmessage = (event)=>this._onConnMessage(event);\n        this.conn.onclose = (event)=>this._onConnClose(event);\n        if (this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open) {\n            this._onConnOpen();\n        }\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */ _teardownConnection() {\n        if (this.conn) {\n            if (this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open || this.conn.readyState === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting) {\n                try {\n                    this.conn.close();\n                } catch (e) {\n                    this.log(\"error\", \"Error closing connection\", e);\n                }\n            }\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this._terminateWorker();\n        this.channels.forEach((channel)=>channel.teardown());\n    }\n    /** @internal */ _onConnOpen() {\n        this._setConnectionState(\"connected\");\n        this.log(\"transport\", `connected to ${this.endpointURL()}`);\n        // Wait for any pending auth operations before flushing send buffer\n        // This ensures channel join messages include the correct access token\n        const authPromise = this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve());\n        authPromise.then(()=>{\n            this.flushSendBuffer();\n        }).catch((e)=>{\n            this.log(\"error\", \"error waiting for auth on connect\", e);\n            // Proceed anyway to avoid hanging connections\n            this.flushSendBuffer();\n        });\n        this._clearTimer(\"reconnect\");\n        if (!this.worker) {\n            this._startHeartbeat();\n        } else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks(\"open\");\n    }\n    /** @internal */ _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */ _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log(\"worker\", `starting worker for from ${this.workerUrl}`);\n        } else {\n            this.log(\"worker\", `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error)=>{\n            this.log(\"worker\", \"worker error\", error.message);\n            this._terminateWorker();\n        };\n        this.workerRef.onmessage = (event)=>{\n            if (event.data.event === \"keepAlive\") {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: \"start\",\n            interval: this.heartbeatIntervalMs\n        });\n    }\n    /**\n     * Terminate the Web Worker and clear the reference\n     * @internal\n     */ _terminateWorker() {\n        if (this.workerRef) {\n            this.log(\"worker\", \"terminating worker\");\n            this.workerRef.terminate();\n            this.workerRef = undefined;\n        }\n    }\n    /** @internal */ _onConnClose(event) {\n        var _a;\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", \"close\", event);\n        this._triggerChanError();\n        this._clearTimer(\"heartbeat\");\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks(\"close\", event);\n    }\n    /** @internal */ _onConnError(error) {\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks(\"error\", error);\n    }\n    /** @internal */ _triggerChanError() {\n        this.channels.forEach((channel)=>channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */ _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        } else {\n            const blob = new Blob([\n                WORKER_SCRIPT\n            ], {\n                type: \"application/javascript\"\n            });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */ _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === \"connecting\") {\n            this._wasManualDisconnect = false;\n        } else if (state === \"disconnecting\") {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */ async _performAuth(token = null) {\n        let tokenToSend;\n        let isManualToken = false;\n        if (token) {\n            tokenToSend = token;\n            // Track if this is a manually-provided token\n            isManualToken = true;\n        } else if (this.accessToken) {\n            // Call the accessToken callback to get fresh token\n            try {\n                tokenToSend = await this.accessToken();\n            } catch (e) {\n                this.log(\"error\", \"Error fetching access token from callback\", e);\n                // Fall back to cached value if callback fails\n                tokenToSend = this.accessTokenValue;\n            }\n        } else {\n            tokenToSend = this.accessTokenValue;\n        }\n        // Track whether this token was manually set or fetched via callback\n        if (isManualToken) {\n            this._manuallySetToken = true;\n        } else if (this.accessToken) {\n            // If we used the callback, clear the manual flag\n            this._manuallySetToken = false;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel)=>{\n                const payload = {\n                    access_token: tokenToSend,\n                    version: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VERSION\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */ async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */ _setAuthSafely(context = \"general\") {\n        // Only refresh auth if using callback-based tokens\n        if (!this._isManualToken()) {\n            this.setAuth().catch((e)=>{\n                this.log(\"error\", `Error setting auth in ${context}`, e);\n            });\n        }\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */ _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback)=>{\n                try {\n                    callback(data);\n                } catch (e) {\n                    this.log(\"error\", `error in ${event} callback`, e);\n                }\n            });\n        } catch (e) {\n            this.log(\"error\", `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */ _setupReconnectionTimer() {\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](async ()=>{\n            setTimeout(async ()=>{\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */ _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        this.vsn = (_g = options === null || options === void 0 ? void 0 : options.vsn) !== null && _g !== void 0 ? _g : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VSN;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), {\n                log_level: this.logLevel\n            });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs = (_h = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _h !== void 0 ? _h : (tries)=>{\n            return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n        };\n        switch(this.vsn){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN_1_0_0:\n                this.encode = (_j = options === null || options === void 0 ? void 0 : options.encode) !== null && _j !== void 0 ? _j : (payload, callback)=>{\n                    return callback(JSON.stringify(payload));\n                };\n                this.decode = (_k = options === null || options === void 0 ? void 0 : options.decode) !== null && _k !== void 0 ? _k : (payload, callback)=>{\n                    return callback(JSON.parse(payload));\n                };\n                break;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN_2_0_0:\n                this.encode = (_l = options === null || options === void 0 ? void 0 : options.encode) !== null && _l !== void 0 ? _l : this.serializer.encode.bind(this.serializer);\n                this.decode = (_m = options === null || options === void 0 ? void 0 : options.decode) !== null && _m !== void 0 ? _m : this.serializer.decode.bind(this.serializer);\n                break;\n            default:\n                throw new Error(`Unsupported serializer version: ${this.vsn}`);\n        }\n        // Handle worker setup\n        if (this.worker) {\n            if (false) {}\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n} //# sourceMappingURL=RealtimeClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUQ7QUFDOEg7QUFDM0k7QUFDVjtBQUNxQjtBQUNMO0FBQ2hELE1BQU1lLE9BQU8sS0FBUTtBQUNyQiwrQkFBK0I7QUFDL0IsTUFBTUMsc0JBQXNCO0lBQ3hCQyxvQkFBb0I7SUFDcEJDLGlCQUFpQjtJQUNqQkMsNEJBQTRCO0FBQ2hDO0FBQ0EsTUFBTUMsc0JBQXNCO0lBQUM7SUFBTTtJQUFNO0lBQU07Q0FBTTtBQUNyRCxNQUFNQyw2QkFBNkI7QUFDbkMsTUFBTUMsZ0JBQWdCLENBQUM7Ozs7O0tBS2xCLENBQUM7QUFDUyxNQUFNQztJQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBMkJDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLElBQUlDO1FBQ0osSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSUM7UUFDcEIsSUFBSSxDQUFDUCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDUSxZQUFZLEdBQUc7UUFDcEIsK0RBQStELEdBQy9ELElBQUksQ0FBQ0MsT0FBTyxHQUFHLENBQUM7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUcsQ0FBQztRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHaEMsMkRBQWVBO1FBQzlCLElBQUksQ0FBQ2lDLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLG1CQUFtQixHQUFHdEIsb0JBQW9CQyxrQkFBa0I7UUFDakUsSUFBSSxDQUFDc0IsY0FBYyxHQUFHQztRQUN0QixJQUFJLENBQUNDLG1CQUFtQixHQUFHO1FBQzNCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUczQjtRQUN6QixJ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R0FBRzNKLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRMkosU0FBUztRQUN4RjtJQUNKO0FBQ0osRUFDQSwwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVDbGllbnQuanM/NmI2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgV2ViU29ja2V0RmFjdG9yeSBmcm9tICcuL2xpYi93ZWJzb2NrZXQtZmFjdG9yeSc7XG5pbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ09OTkVDVElPTl9TVEFURSwgREVGQVVMVF9WRVJTSU9OLCBERUZBVUxUX1RJTUVPVVQsIFNPQ0tFVF9TVEFURVMsIFRSQU5TUE9SVFMsIERFRkFVTFRfVlNOLCBWU05fMV8wXzAsIFZTTl8yXzBfMCwgV1NfQ0xPU0VfTk9STUFMLCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgU2VyaWFsaXplciBmcm9tICcuL2xpYi9zZXJpYWxpemVyJztcbmltcG9ydCBUaW1lciBmcm9tICcuL2xpYi90aW1lcic7XG5pbXBvcnQgeyBodHRwRW5kcG9pbnRVUkwgfSBmcm9tICcuL2xpYi90cmFuc2Zvcm1lcnMnO1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCc7XG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuLy8gQ29ubmVjdGlvbi1yZWxhdGVkIGNvbnN0YW50c1xuY29uc3QgQ09OTkVDVElPTl9USU1FT1VUUyA9IHtcbiAgICBIRUFSVEJFQVRfSU5URVJWQUw6IDI1MDAwLFxuICAgIFJFQ09OTkVDVF9ERUxBWTogMTAsXG4gICAgSEVBUlRCRUFUX1RJTUVPVVRfRkFMTEJBQ0s6IDEwMCxcbn07XG5jb25zdCBSRUNPTk5FQ1RfSU5URVJWQUxTID0gWzEwMDAsIDIwMDAsIDUwMDAsIDEwMDAwXTtcbmNvbnN0IERFRkFVTFRfUkVDT05ORUNUX0ZBTExCQUNLID0gMTAwMDA7XG5jb25zdCBXT1JLRVJfU0NSSVBUID0gYFxuICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSkgPT4ge1xuICAgIGlmIChlLmRhdGEuZXZlbnQgPT09IFwic3RhcnRcIikge1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4gcG9zdE1lc3NhZ2UoeyBldmVudDogXCJrZWVwQWxpdmVcIiB9KSwgZS5kYXRhLmludGVydmFsKTtcbiAgICB9XG4gIH0pO2A7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmRQb2ludCBUaGUgc3RyaW5nIFdlYlNvY2tldCBlbmRwb2ludCwgaWUsIFwid3M6Ly9leGFtcGxlLmNvbS9zb2NrZXRcIiwgXCJ3c3M6Ly9leGFtcGxlLmNvbVwiLCBcIi9zb2NrZXRcIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0gaHR0cEVuZHBvaW50IFRoZSBzdHJpbmcgSFRUUCBlbmRwb2ludCwgaWUsIFwiaHR0cHM6Ly9leGFtcGxlLmNvbVwiLCBcIi9cIiAoaW5oZXJpdGVkIGhvc3QgJiBwcm90b2NvbClcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc3BvcnQgVGhlIFdlYnNvY2tldCBUcmFuc3BvcnQsIGZvciBleGFtcGxlIFdlYlNvY2tldC4gVGhpcyBjYW4gYmUgYSBjdXN0b20gaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IFRoZSBkZWZhdWx0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIHRyaWdnZXIgcHVzaCB0aW1lb3V0cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYXJhbXMgVGhlIG9wdGlvbmFsIHBhcmFtcyB0byBwYXNzIHdoZW4gY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIERlcHJlY2F0ZWQ6IGhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgYW5kIHRoaXMgb3B0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMgVGhlIG1pbGxpc2VjIGludGVydmFsIHRvIHNlbmQgYSBoZWFydGJlYXQgbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFydGJlYXRDYWxsYmFjayBUaGUgb3B0aW9uYWwgZnVuY3Rpb24gdG8gaGFuZGxlIGhlYXJ0YmVhdCBzdGF0dXMgYW5kIGxhdGVuY3kuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIFRoZSBvcHRpb25hbCBmdW5jdGlvbiBmb3Igc3BlY2lhbGl6ZWQgbG9nZ2luZywgaWU6IGxvZ2dlcjogKGtpbmQsIG1zZywgZGF0YSkgPT4geyBjb25zb2xlLmxvZyhgJHtraW5kfTogJHttc2d9YCwgZGF0YSkgfVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxvZ0xldmVsIFNldHMgdGhlIGxvZyBsZXZlbCBmb3IgUmVhbHRpbWVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5lbmNvZGUgVGhlIGZ1bmN0aW9uIHRvIGVuY29kZSBvdXRnb2luZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gSlNPTjogKHBheWxvYWQsIGNhbGxiYWNrKSA9PiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZWNvZGUgVGhlIGZ1bmN0aW9uIHRvIGRlY29kZSBpbmNvbWluZyBtZXNzYWdlcy4gRGVmYXVsdHMgdG8gU2VyaWFsaXplcidzIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zIGhlIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbWlsbHNlYyByZWNvbm5lY3QgaW50ZXJ2YWwuIERlZmF1bHRzIHRvIHN0ZXBwZWQgYmFja29mZiBvZmYuXG4gICAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyIFVzZSBXZWIgV29ya2VyIHRvIHNldCBhIHNpZGUgZmxvdy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMud29ya2VyVXJsIFRoZSBVUkwgb2YgdGhlIHdvcmtlciBzY3JpcHQuIERlZmF1bHRzIHRvIGh0dHBzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY29tL3dvcmtlci5qcyB0aGF0IGluY2x1ZGVzIGEgaGVhcnRiZWF0IGV2ZW50IGNhbGwgdG8ga2VlcCB0aGUgY29ubmVjdGlvbiBhbGl2ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJ0BzdXBhYmFzZS9yZWFsdGltZS1qcydcbiAgICAgKlxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBSZWFsdGltZUNsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3JlYWx0aW1lL3YxJywge1xuICAgICAqICAgcGFyYW1zOiB7IGFwaWtleTogJ3B1YmxpYy1hbm9uLWtleScgfSxcbiAgICAgKiB9KVxuICAgICAqIGNsaWVudC5jb25uZWN0KClcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbmRQb2ludCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFudWFsbHlTZXRUb2tlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSAnJztcbiAgICAgICAgdGhpcy5odHRwRW5kcG9pbnQgPSAnJztcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgKi9cbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMudnNuID0gREVGQVVMVF9WU047XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbm9vcDtcbiAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvcGVuOiBbXSxcbiAgICAgICAgICAgIGNsb3NlOiBbXSxcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXV0aFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRTZW50QXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiBjdXN0b21GZXRjaCguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFZhbGlkYXRlIHJlcXVpcmVkIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKCEoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwaWtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVBJIGtleSBpcyByZXF1aXJlZCB0byBjb25uZWN0IHRvIFJlYWx0aW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcGlLZXkgPSBvcHRpb25zLnBhcmFtcy5hcGlrZXk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZW5kcG9pbnQgVVJMc1xuICAgICAgICB0aGlzLmVuZFBvaW50ID0gYCR7ZW5kUG9pbnR9LyR7VFJBTlNQT1JUUy53ZWJzb2NrZXR9YDtcbiAgICAgICAgdGhpcy5odHRwRW5kcG9pbnQgPSBodHRwRW5kcG9pbnRVUkwoZW5kUG9pbnQpO1xuICAgICAgICB0aGlzLl9pbml0aWFsaXplT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc2V0dXBSZWNvbm5lY3Rpb25UaW1lcigpO1xuICAgICAgICB0aGlzLmZldGNoID0gdGhpcy5fcmVzb2x2ZUZldGNoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIHRoZSBzb2NrZXQsIHVubGVzcyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICAvLyBTa2lwIGlmIGFscmVhZHkgY29ubmVjdGluZywgZGlzY29ubmVjdGluZywgb3IgY29ubmVjdGVkXG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZygpIHx8XG4gICAgICAgICAgICB0aGlzLmlzRGlzY29ubmVjdGluZygpIHx8XG4gICAgICAgICAgICAodGhpcy5jb25uICE9PSBudWxsICYmIHRoaXMuaXNDb25uZWN0ZWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgLy8gVHJpZ2dlciBhdXRoIGlmIG5lZWRlZCBhbmQgbm90IGFscmVhZHkgaW4gcHJvZ3Jlc3NcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGF1dGggaXMgY2FsbGVkIGZvciBzdGFuZGFsb25lIFJlYWx0aW1lQ2xpZW50IHVzYWdlXG4gICAgICAgIC8vIHdoaWxlIGF2b2lkaW5nIHJhY2UgY29uZGl0aW9ucyB3aXRoIFN1cGFiYXNlQ2xpZW50J3MgaW1tZWRpYXRlIHNldEF1dGggY2FsbFxuICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlbiAmJiAhdGhpcy5fYXV0aFByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEF1dGhTYWZlbHkoJ2Nvbm5lY3QnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAvLyBVc2UgY3VzdG9tIHRyYW5zcG9ydCBpZiBwcm92aWRlZFxuICAgICAgICAgICAgdGhpcy5jb25uID0gbmV3IHRoaXMudHJhbnNwb3J0KHRoaXMuZW5kcG9pbnRVUkwoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gdXNlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uID0gV2ViU29ja2V0RmFjdG9yeS5jcmVhdGVXZWJTb2NrZXQodGhpcy5lbmRwb2ludFVSTCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAvLyBQcm92aWRlIGhlbHBmdWwgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBlbnZpcm9ubWVudFxuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ05vZGUuanMnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNZXNzYWdlfVxcblxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1RvIHVzZSBSZWFsdGltZSBpbiBOb2RlLmpzLCB5b3UgbmVlZCB0byBwcm92aWRlIGEgV2ViU29ja2V0IGltcGxlbWVudGF0aW9uOlxcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ09wdGlvbiAxOiBVc2UgTm9kZS5qcyAyMisgd2hpY2ggaGFzIG5hdGl2ZSBXZWJTb2NrZXQgc3VwcG9ydFxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ09wdGlvbiAyOiBJbnN0YWxsIGFuZCBwcm92aWRlIHRoZSBcIndzXCIgcGFja2FnZTpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIG5wbSBpbnN0YWxsIHdzXFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIGNvbnN0IGNsaWVudCA9IG5ldyBSZWFsdGltZUNsaWVudCh1cmwsIHtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICAgLi4ub3B0aW9ucyxcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICAgdHJhbnNwb3J0OiB3c1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgfSknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXZWJTb2NrZXQgbm90IGF2YWlsYWJsZTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICogQHJldHVybnMgc3RyaW5nIFRoZSBVUkwgb2YgdGhlIHdlYnNvY2tldC5cbiAgICAgKi9cbiAgICBlbmRwb2ludFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcGVuZFBhcmFtcyh0aGlzLmVuZFBvaW50LCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnBhcmFtcywgeyB2c246IHRoaXMudnNuIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2RlIEEgbnVtZXJpYyBzdGF0dXMgY29kZSB0byBzZW5kIG9uIGRpc2Nvbm5lY3QuXG4gICAgICogQHBhcmFtIHJlYXNvbiBBIGN1c3RvbSByZWFzb24gZm9yIHRoZSBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY29kZSwgcmVhc29uKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzY29ubmVjdGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0aW5nJywgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIC8vIFNldHVwIGZhbGxiYWNrIHRpbWVyIHRvIHByZXZlbnQgaGFuZ2luZyBpbiBkaXNjb25uZWN0aW5nIHN0YXRlXG4gICAgICAgICAgICBjb25zdCBmYWxsYmFja1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZmFsbGJhY2tUaW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaWYgY2xvc2UgbWV0aG9kIGV4aXN0c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbm4uY2xvc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGVhcmRvd25Db25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGNyZWF0ZWQgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhIHNpbmdsZSBjaGFubmVsXG4gICAgICogQHBhcmFtIGNoYW5uZWwgQSBSZWFsdGltZUNoYW5uZWwgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVDaGFubmVsKGNoYW5uZWwpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgY2hhbm5lbC51bnN1YnNjcmliZSgpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgY2hhbm5lbHNcbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVBbGxDaGFubmVscygpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzXzEgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNoYW5uZWxzLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC51bnN1YnNjcmliZSgpKSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB2YWx1ZXNfMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9ncyB0aGUgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEZvciBjdXN0b21pemVkIGxvZ2dpbmcsIGB0aGlzLmxvZ2dlcmAgY2FuIGJlIG92ZXJyaWRkZW4uXG4gICAgICovXG4gICAgbG9nKGtpbmQsIG1zZywgZGF0YSkge1xuICAgICAgICB0aGlzLmxvZ2dlcihraW5kLCBtc2csIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzb2NrZXQuXG4gICAgICovXG4gICAgY29ubmVjdGlvblN0YXRlKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY29ubiAmJiB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLmNvbm5lY3Rpbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuQ29ubmVjdGluZztcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5vcGVuOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLk9wZW47XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY2xvc2luZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zaW5nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5DbG9zZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaXMgdGhlIGNvbm5lY3Rpb24gaXMgb3Blbi5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblN0YXRlKCkgPT09IENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGNvbm5lY3RpbmcuXG4gICAgICovXG4gICAgaXNDb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGluZyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIGlzIGN1cnJlbnRseSBkaXNjb25uZWN0aW5nLlxuICAgICAqL1xuICAgIGlzRGlzY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RpbmcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIChvciByZXVzZXMpIGEge0BsaW5rIFJlYWx0aW1lQ2hhbm5lbH0gZm9yIHRoZSBwcm92aWRlZCB0b3BpYy5cbiAgICAgKlxuICAgICAqIFRvcGljcyBhcmUgYXV0b21hdGljYWxseSBwcmVmaXhlZCB3aXRoIGByZWFsdGltZTpgIHRvIG1hdGNoIHRoZSBSZWFsdGltZSBzZXJ2aWNlLlxuICAgICAqIElmIGEgY2hhbm5lbCB3aXRoIHRoZSBzYW1lIHRvcGljIGFscmVhZHkgZXhpc3RzIGl0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBjcmVhdGluZ1xuICAgICAqIGEgZHVwbGljYXRlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgY2hhbm5lbCh0b3BpYywgcGFyYW1zID0geyBjb25maWc6IHt9IH0pIHtcbiAgICAgICAgY29uc3QgcmVhbHRpbWVUb3BpYyA9IGByZWFsdGltZToke3RvcGljfWA7XG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHRoaXMuZ2V0Q2hhbm5lbHMoKS5maW5kKChjKSA9PiBjLnRvcGljID09PSByZWFsdGltZVRvcGljKTtcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW4gPSBuZXcgUmVhbHRpbWVDaGFubmVsKGByZWFsdGltZToke3RvcGljfWAsIHBhcmFtcywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLnB1c2goY2hhbik7XG4gICAgICAgICAgICByZXR1cm4gY2hhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVzaCBvdXQgYSBtZXNzYWdlIGlmIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkLlxuICAgICAqXG4gICAgICogSWYgdGhlIHNvY2tldCBpcyBub3QgY29ubmVjdGVkLCB0aGUgbWVzc2FnZSBnZXRzIGVucXVldWVkIHdpdGhpbiBhIGxvY2FsIGJ1ZmZlciwgYW5kIHNlbnQgb3V0IHdoZW4gYSBjb25uZWN0aW9uIGlzIG5leHQgZXN0YWJsaXNoZWQuXG4gICAgICovXG4gICAgcHVzaChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdG9waWMsIGV2ZW50LCBwYXlsb2FkLCByZWYgfSA9IGRhdGE7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmNvZGUoZGF0YSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNvbm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2coJ3B1c2gnLCBgJHt0b3BpY30gJHtldmVudH0gKCR7cmVmfSlgLCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBKV1QgYWNjZXNzIHRva2VuIHVzZWQgZm9yIGNoYW5uZWwgc3Vic2NyaXB0aW9uIGF1dGhvcml6YXRpb24gYW5kIFJlYWx0aW1lIFJMUy5cbiAgICAgKlxuICAgICAqIElmIHBhcmFtIGlzIG51bGwgaXQgd2lsbCB1c2UgdGhlIGBhY2Nlc3NUb2tlbmAgY2FsbGJhY2sgZnVuY3Rpb24gb3IgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogT24gY2FsbGJhY2sgdXNlZCwgaXQgd2lsbCBzZXQgdGhlIHZhbHVlIG9mIHRoZSB0b2tlbiBpbnRlcm5hbCB0byB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogV2hlbiBhIHRva2VuIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQsIGl0IHdpbGwgYmUgcHJlc2VydmVkIGFjcm9zcyBjaGFubmVsIG9wZXJhdGlvbnNcbiAgICAgKiAoaW5jbHVkaW5nIHJlbW92ZUNoYW5uZWwgYW5kIHJlc3Vic2NyaWJlKS4gVGhlIGBhY2Nlc3NUb2tlbmAgY2FsbGJhY2sgd2lsbCBub3QgYmVcbiAgICAgKiBpbnZva2VkIHVudGlsIGBzZXRBdXRoKClgIGlzIGNhbGxlZCB3aXRob3V0IGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBVc2UgYSBtYW51YWwgdG9rZW4gKHByZXNlcnZlZCBhY3Jvc3MgcmVzdWJzY3JpYmVzLCBpZ25vcmVzIGFjY2Vzc1Rva2VuIGNhbGxiYWNrKVxuICAgICAqIGNsaWVudC5yZWFsdGltZS5zZXRBdXRoKCdteS1jdXN0b20tand0JylcbiAgICAgKlxuICAgICAqIC8vIFN3aXRjaCBiYWNrIHRvIHVzaW5nIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFja1xuICAgICAqIGNsaWVudC5yZWFsdGltZS5zZXRBdXRoKClcbiAgICAgKi9cbiAgICBhc3luYyBzZXRBdXRoKHRva2VuID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IHRoaXMuX3BlcmZvcm1BdXRoKHRva2VuKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1dGhQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aFByb21pc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBhY2Nlc3MgdG9rZW4gd2FzIGV4cGxpY2l0bHkgc2V0IHZpYSBzZXRBdXRoKHRva2VuKSxcbiAgICAgKiBmYWxzZSBpZiBpdCB3YXMgb2J0YWluZWQgdmlhIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFjay5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaXNNYW51YWxUb2tlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hbnVhbGx5U2V0VG9rZW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgaGVhcnRiZWF0IG1lc3NhZ2UgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgc2VuZEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBoZWFydGJlYXQgdGltZW91dCBhbmQgZm9yY2UgcmVjb25uZWN0aW9uIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGVhcnRiZWF0U2VudEF0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCAnaGVhcnRiZWF0IHRpbWVvdXQuIEF0dGVtcHRpbmcgdG8gcmUtZXN0YWJsaXNoIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjaygndGltZW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3JjZSByZWNvbm5lY3Rpb24gYWZ0ZXIgaGVhcnRiZWF0IHRpbWVvdXRcbiAgICAgICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY29ubikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKFdTX0NMT1NFX05PUk1BTCwgJ2hlYXJ0YmVhdCB0aW1lb3V0Jyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5yZWNvbm5lY3RUaW1lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIENPTk5FQ1RJT05fVElNRU9VVFMuSEVBUlRCRUFUX1RJTUVPVVRfRkFMTEJBQ0spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlbmQgaGVhcnRiZWF0IG1lc3NhZ2UgdG8gc2VydmVyXG4gICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IHRoaXMuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIHRvcGljOiAncGhvZW5peCcsXG4gICAgICAgICAgICBldmVudDogJ2hlYXJ0YmVhdCcsXG4gICAgICAgICAgICBwYXlsb2FkOiB7fSxcbiAgICAgICAgICAgIHJlZjogdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ3NlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEF1dGhTYWZlbHkoJ2hlYXJ0YmVhdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyBsaWZlY3ljbGUgZXZlbnRzIGZvciBpbnRlcm5hbCBoZWFydGJlYXQgbWVzc2FnZXMuXG4gICAgICogVXNlZnVsIGZvciBpbnN0cnVtZW50aW5nIGNvbm5lY3Rpb24gaGVhbHRoIChlLmcuIHNlbnQvb2svdGltZW91dC9kaXNjb25uZWN0ZWQpLlxuICAgICAqL1xuICAgIG9uSGVhcnRiZWF0KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2hlcyBzZW5kIGJ1ZmZlclxuICAgICAqL1xuICAgIGZsdXNoU2VuZEJ1ZmZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmV4dCBtZXNzYWdlIHJlZiwgYWNjb3VudGluZyBmb3Igb3ZlcmZsb3dzXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfbWFrZVJlZigpIHtcbiAgICAgICAgbGV0IG5ld1JlZiA9IHRoaXMucmVmICsgMTtcbiAgICAgICAgaWYgKG5ld1JlZiA9PT0gdGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmID0gbmV3UmVmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZi50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGNoYW5uZWxzIHdpdGggdGhlIHNwZWNpZmllZCB0b3BpYy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9sZWF2ZU9wZW5Ub3BpYyh0b3BpYykge1xuICAgICAgICBsZXQgZHVwQ2hhbm5lbCA9IHRoaXMuY2hhbm5lbHMuZmluZCgoYykgPT4gYy50b3BpYyA9PT0gdG9waWMgJiYgKGMuX2lzSm9pbmVkKCkgfHwgYy5faXNKb2luaW5nKCkpKTtcbiAgICAgICAgaWYgKGR1cENoYW5uZWwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgbGVhdmluZyBkdXBsaWNhdGUgdG9waWMgXCIke3RvcGljfVwiYCk7XG4gICAgICAgICAgICBkdXBDaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHN1YnNjcmlwdGlvbiBmcm9tIHRoZSBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBBbiBvcGVuIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9yZW1vdmUoY2hhbm5lbCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gdGhpcy5jaGFubmVscy5maWx0ZXIoKGMpID0+IGMudG9waWMgIT09IGNoYW5uZWwudG9waWMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubk1lc3NhZ2UocmF3TWVzc2FnZSkge1xuICAgICAgICB0aGlzLmRlY29kZShyYXdNZXNzYWdlLmRhdGEsIChtc2cpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBoZWFydGJlYXQgcmVzcG9uc2VzXG4gICAgICAgICAgICBpZiAobXNnLnRvcGljID09PSAncGhvZW5peCcgJiZcbiAgICAgICAgICAgICAgICBtc2cuZXZlbnQgPT09ICdwaHhfcmVwbHknICYmXG4gICAgICAgICAgICAgICAgbXNnLnJlZiAmJlxuICAgICAgICAgICAgICAgIG1zZy5yZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVuY3kgPSB0aGlzLl9oZWFydGJlYXRTZW50QXQgPyBEYXRlLm5vdygpIC0gdGhpcy5faGVhcnRiZWF0U2VudEF0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2sobXNnLnBheWxvYWQuc3RhdHVzID09PSAnb2snID8gJ29rJyA6ICdlcnJvcicsIGxhdGVuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdFNlbnRBdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvZyBpbmNvbWluZyBtZXNzYWdlXG4gICAgICAgICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBtc2c7XG4gICAgICAgICAgICBjb25zdCByZWZTdHJpbmcgPSByZWYgPyBgKCR7cmVmfSlgIDogJyc7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBwYXlsb2FkLnN0YXR1cyB8fCAnJztcbiAgICAgICAgICAgIHRoaXMubG9nKCdyZWNlaXZlJywgYCR7c3RhdHVzfSAke3RvcGljfSAke2V2ZW50fSAke3JlZlN0cmluZ31gLnRyaW0oKSwgcGF5bG9hZCk7XG4gICAgICAgICAgICAvLyBSb3V0ZSBtZXNzYWdlIHRvIGFwcHJvcHJpYXRlIGNoYW5uZWxzXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoY2hhbm5lbCkgPT4gY2hhbm5lbC5faXNNZW1iZXIodG9waWMpKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKChjaGFubmVsKSA9PiBjaGFubmVsLl90cmlnZ2VyKGV2ZW50LCBwYXlsb2FkLCByZWYpKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBzcGVjaWZpYyB0aW1lclxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jbGVhclRpbWVyKHRpbWVyKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRpbWVyID09PSAnaGVhcnRiZWF0JyAmJiB0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aW1lciA9PT0gJ3JlY29ubmVjdCcpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCB0aW1lcnNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2xlYXJBbGxUaW1lcnMoKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZXIoJ2hlYXJ0YmVhdCcpO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdyZWNvbm5lY3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgY29ubmVjdGlvbiBoYW5kbGVycyBmb3IgV2ViU29ja2V0IGV2ZW50c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXR1cENvbm5lY3Rpb25IYW5kbGVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNldCBiaW5hcnkgdHlwZSBpZiBzdXBwb3J0ZWQgKGJyb3dzZXJzIGFuZCBtb3N0IFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbnMpXG4gICAgICAgIGlmICgnYmluYXJ5VHlwZScgaW4gdGhpcy5jb25uKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aGlzLmNvbm4uYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLm9ub3BlbiA9ICgpID0+IHRoaXMuX29uQ29ubk9wZW4oKTtcbiAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSAoZXJyb3IpID0+IHRoaXMuX29uQ29ubkVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uTWVzc2FnZShldmVudCk7XG4gICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKGV2ZW50KSA9PiB0aGlzLl9vbkNvbm5DbG9zZShldmVudCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm4ucmVhZHlTdGF0ZSA9PT0gU09DS0VUX1NUQVRFUy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNvbm5PcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVhcmRvd24gY29ubmVjdGlvbiBhbmQgY2xlYW51cCByZXNvdXJjZXNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdGVhcmRvd25Db25uZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uLnJlYWR5U3RhdGUgPT09IFNPQ0tFVF9TVEFURVMub3BlbiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY29ubi5yZWFkeVN0YXRlID09PSBTT0NLRVRfU1RBVEVTLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ0Vycm9yIGNsb3NpbmcgY29ubmVjdGlvbicsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyQWxsVGltZXJzKCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVdvcmtlcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwudGVhcmRvd24oKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uT3BlbigpIHtcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBjb25uZWN0ZWQgdG8gJHt0aGlzLmVuZHBvaW50VVJMKCl9YCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFueSBwZW5kaW5nIGF1dGggb3BlcmF0aW9ucyBiZWZvcmUgZmx1c2hpbmcgc2VuZCBidWZmZXJcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGNoYW5uZWwgam9pbiBtZXNzYWdlcyBpbmNsdWRlIHRoZSBjb3JyZWN0IGFjY2VzcyB0b2tlblxuICAgICAgICBjb25zdCBhdXRoUHJvbWlzZSA9IHRoaXMuX2F1dGhQcm9taXNlIHx8XG4gICAgICAgICAgICAodGhpcy5hY2Nlc3NUb2tlbiAmJiAhdGhpcy5hY2Nlc3NUb2tlblZhbHVlID8gdGhpcy5zZXRBdXRoKCkgOiBQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgIGF1dGhQcm9taXNlXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3Igd2FpdGluZyBmb3IgYXV0aCBvbiBjb25uZWN0JywgZSk7XG4gICAgICAgICAgICAvLyBQcm9jZWVkIGFueXdheSB0byBhdm9pZCBoYW5naW5nIGNvbm5lY3Rpb25zXG4gICAgICAgICAgICB0aGlzLmZsdXNoU2VuZEJ1ZmZlcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0SGVhcnRiZWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud29ya2VyUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRXb3JrZXJIZWFydGJlYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zdGFydEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3RhcnRXb3JrZXJIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgZGVmYXVsdCB3b3JrZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl93b3JrZXJPYmplY3RVcmwodGhpcy53b3JrZXJVcmwpO1xuICAgICAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd3b3JrZXIgZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMuX3Rlcm1pbmF0ZVdvcmtlcigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXJtaW5hdGUgdGhlIFdlYiBXb3JrZXIgYW5kIGNsZWFyIHRoZSByZWZlcmVuY2VcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdGVybWluYXRlV29ya2VyKCkge1xuICAgICAgICBpZiAodGhpcy53b3JrZXJSZWYpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCAndGVybWluYXRpbmcgd29ya2VyJyk7XG4gICAgICAgICAgICB0aGlzLndvcmtlclJlZi50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uQ2xvc2UoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2Nsb3NlJywgZXZlbnQpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbkVycm9yKCk7XG4gICAgICAgIHRoaXMuX2NsZWFyVGltZXIoJ2hlYXJ0YmVhdCcpO1xuICAgICAgICAvLyBPbmx5IHNjaGVkdWxlIHJlY29ubmVjdGlvbiBpZiBpdCB3YXNuJ3QgYSBtYW51YWwgZGlzY29ubmVjdFxuICAgICAgICBpZiAoIXRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QpIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ2Nsb3NlJywgZXZlbnQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkVycm9yKGVycm9yKSB7XG4gICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIHRoaXMubG9nKCd0cmFuc3BvcnQnLCBgJHtlcnJvcn1gKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ2Vycm9yJywgZXJyb3IpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RyaWdnZXJDaGFuRXJyb3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5fdHJpZ2dlcihDSEFOTkVMX0VWRU5UUy5lcnJvcikpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FwcGVuZFBhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlZml4ID0gdXJsLm1hdGNoKC9cXD8vKSA/ICcmJyA6ICc/JztcbiAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBgJHt1cmx9JHtwcmVmaXh9JHtxdWVyeX1gO1xuICAgIH1cbiAgICBfd29ya2VyT2JqZWN0VXJsKHVybCkge1xuICAgICAgICBsZXQgcmVzdWx0X3VybDtcbiAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgcmVzdWx0X3VybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbV09SS0VSX1NDUklQVF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pO1xuICAgICAgICAgICAgcmVzdWx0X3VybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdF91cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBjb25uZWN0aW9uIHN0YXRlIHdpdGggcHJvcGVyIHN0YXRlIG1hbmFnZW1lbnRcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0Q29ubmVjdGlvblN0YXRlKHN0YXRlLCBtYW51YWwgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gbWFudWFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBhdXRoIG9wZXJhdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIF9wZXJmb3JtQXV0aCh0b2tlbiA9IG51bGwpIHtcbiAgICAgICAgbGV0IHRva2VuVG9TZW5kO1xuICAgICAgICBsZXQgaXNNYW51YWxUb2tlbiA9IGZhbHNlO1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuVG9TZW5kID0gdG9rZW47XG4gICAgICAgICAgICAvLyBUcmFjayBpZiB0aGlzIGlzIGEgbWFudWFsbHktcHJvdmlkZWQgdG9rZW5cbiAgICAgICAgICAgIGlzTWFudWFsVG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIENhbGwgdGhlIGFjY2Vzc1Rva2VuIGNhbGxiYWNrIHRvIGdldCBmcmVzaCB0b2tlblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCA9IGF3YWl0IHRoaXMuYWNjZXNzVG9rZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ0Vycm9yIGZldGNoaW5nIGFjY2VzcyB0b2tlbiBmcm9tIGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGNhY2hlZCB2YWx1ZSBpZiBjYWxsYmFjayBmYWlsc1xuICAgICAgICAgICAgICAgIHRva2VuVG9TZW5kID0gdGhpcy5hY2Nlc3NUb2tlblZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSB0aGlzLmFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJhY2sgd2hldGhlciB0aGlzIHRva2VuIHdhcyBtYW51YWxseSBzZXQgb3IgZmV0Y2hlZCB2aWEgY2FsbGJhY2tcbiAgICAgICAgaWYgKGlzTWFudWFsVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX21hbnVhbGx5U2V0VG9rZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHVzZWQgdGhlIGNhbGxiYWNrLCBjbGVhciB0aGUgbWFudWFsIGZsYWdcbiAgICAgICAgICAgIHRoaXMuX21hbnVhbGx5U2V0VG9rZW4gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2Nlc3NUb2tlblZhbHVlICE9IHRva2VuVG9TZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuVmFsdWUgPSB0b2tlblRvU2VuZDtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogdG9rZW5Ub1NlbmQsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IERFRkFVTFRfVkVSU0lPTixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRva2VuVG9TZW5kICYmIGNoYW5uZWwudXBkYXRlSm9pblBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwuam9pbmVkT25jZSAmJiBjaGFubmVsLl9pc0pvaW5lZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWwuX3B1c2goQ0hBTk5FTF9FVkVOVFMuYWNjZXNzX3Rva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0IGZvciBhbnkgaW4tZmxpZ2h0IGF1dGggb3BlcmF0aW9ucyB0byBjb21wbGV0ZVxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGFzeW5jIF93YWl0Rm9yQXV0aElmTmVlZGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fYXV0aFByb21pc2UpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2F1dGhQcm9taXNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhZmVseSBjYWxsIHNldEF1dGggd2l0aCBzdGFuZGFyZGl6ZWQgZXJyb3IgaGFuZGxpbmdcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0QXV0aFNhZmVseShjb250ZXh0ID0gJ2dlbmVyYWwnKSB7XG4gICAgICAgIC8vIE9ubHkgcmVmcmVzaCBhdXRoIGlmIHVzaW5nIGNhbGxiYWNrLWJhc2VkIHRva2Vuc1xuICAgICAgICBpZiAoIXRoaXMuX2lzTWFudWFsVG9rZW4oKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdXRoKCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgRXJyb3Igc2V0dGluZyBhdXRoIGluICR7Y29udGV4dH1gLCBlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgc3RhdGUgY2hhbmdlIGNhbGxiYWNrcyB3aXRoIHByb3BlciBlcnJvciBoYW5kbGluZ1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF90cmlnZ2VyU3RhdGVDYWxsYmFja3MoZXZlbnQsIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3NbZXZlbnRdLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsIGBlcnJvciBpbiAke2V2ZW50fSBjYWxsYmFja2AsIGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgZXJyb3IgdHJpZ2dlcmluZyAke2V2ZW50fSBjYWxsYmFja3NgLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCByZWNvbm5lY3Rpb24gdGltZXIgd2l0aCBwcm9wZXIgY29uZmlndXJhdGlvblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXR1cFJlY29ubmVjdGlvblRpbWVyKCkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbmV3IFRpbWVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3dhaXRGb3JBdXRoSWZOZWVkZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBDT05ORUNUSU9OX1RJTUVPVVRTLlJFQ09OTkVDVF9ERUxBWSk7XG4gICAgICAgIH0sIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgY2xpZW50IG9wdGlvbnMgd2l0aCBkZWZhdWx0c1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tO1xuICAgICAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNwb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGltZW91dCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9USU1FT1VUO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPVxuICAgICAgICAgICAgKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYXJ0YmVhdEludGVydmFsTXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IENPTk5FQ1RJT05fVElNRU9VVFMuSEVBUlRCRUFUX0lOVEVSVkFMO1xuICAgICAgICB0aGlzLndvcmtlciA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGZhbHNlO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFjY2Vzc1Rva2VuKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBudWxsO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYXJ0YmVhdENhbGxiYWNrKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBub29wO1xuICAgICAgICB0aGlzLnZzbiA9IChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52c24pICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IERFRkFVTFRfVlNOO1xuICAgICAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlc1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBhcmFtcylcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nZ2VyKVxuICAgICAgICAgICAgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlcjtcbiAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nTGV2ZWwpIHx8IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nX2xldmVsKSkge1xuICAgICAgICAgICAgdGhpcy5sb2dMZXZlbCA9IG9wdGlvbnMubG9nTGV2ZWwgfHwgb3B0aW9ucy5sb2dfbGV2ZWw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMpLCB7IGxvZ19sZXZlbDogdGhpcy5sb2dMZXZlbCB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdXAgZnVuY3Rpb25zIHdpdGggZGVmYXVsdHNcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RBZnRlck1zID1cbiAgICAgICAgICAgIChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWNvbm5lY3RBZnRlck1zKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiAoKHRyaWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJFQ09OTkVDVF9JTlRFUlZBTFNbdHJpZXMgLSAxXSB8fCBERUZBVUxUX1JFQ09OTkVDVF9GQUxMQkFDSztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudnNuKSB7XG4gICAgICAgICAgICBjYXNlIFZTTl8xXzBfMDpcbiAgICAgICAgICAgICAgICB0aGlzLmVuY29kZSA9XG4gICAgICAgICAgICAgICAgICAgIChfaiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbmNvZGUpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6ICgocGF5bG9hZCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlID1cbiAgICAgICAgICAgICAgICAgICAgKF9rID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlY29kZSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogKChwYXlsb2FkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04ucGFyc2UocGF5bG9hZCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVlNOXzJfMF8wOlxuICAgICAgICAgICAgICAgIHRoaXMuZW5jb2RlID0gKF9sID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogdGhpcy5zZXJpYWxpemVyLmVuY29kZS5iaW5kKHRoaXMuc2VyaWFsaXplcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGUgPSAoX20gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiB0aGlzLnNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzZXJpYWxpemVyIHZlcnNpb246ICR7dGhpcy52c259YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHdvcmtlciBzZXR1cFxuICAgICAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViIFdvcmtlciBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndvcmtlclVybCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXJVcmw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiV2ViU29ja2V0RmFjdG9yeSIsIkNIQU5ORUxfRVZFTlRTIiwiQ09OTkVDVElPTl9TVEFURSIsIkRFRkFVTFRfVkVSU0lPTiIsIkRFRkFVTFRfVElNRU9VVCIsIlNPQ0tFVF9TVEFURVMiLCJUUkFOU1BPUlRTIiwiREVGQVVMVF9WU04iLCJWU05fMV8wXzAiLCJWU05fMl8wXzAiLCJXU19DTE9TRV9OT1JNQUwiLCJTZXJpYWxpemVyIiwiVGltZXIiLCJodHRwRW5kcG9pbnRVUkwiLCJSZWFsdGltZUNoYW5uZWwiLCJub29wIiwiQ09OTkVDVElPTl9USU1FT1VUUyIsIkhFQVJUQkVBVF9JTlRFUlZBTCIsIlJFQ09OTkVDVF9ERUxBWSIsIkhFQVJUQkVBVF9USU1FT1VUX0ZBTExCQUNLIiwiUkVDT05ORUNUX0lOVEVSVkFMUyIsIkRFRkFVTFRfUkVDT05ORUNUX0ZBTExCQUNLIiwiV09SS0VSX1NDUklQVCIsIlJlYWx0aW1lQ2xpZW50IiwiY29uc3RydWN0b3IiLCJlbmRQb2ludCIsIm9wdGlvbnMiLCJfYSIsImFjY2Vzc1Rva2VuVmFsdWUiLCJhcGlLZXkiLCJfbWFudWFsbHlTZXRUb2tlbiIsImNoYW5uZWxzIiwiQXJyYXkiLCJodHRwRW5kcG9pbnQiLCJoZWFkZXJzIiwicGFyYW1zIiwidGltZW91dCIsInRyYW5zcG9ydCIsImhlYXJ0YmVhdEludGVydmFsTXMiLCJoZWFydGJlYXRUaW1lciIsInVuZGVmaW5lZCIsInBlbmRpbmdIZWFydGJlYXRSZWYiLCJoZWFydGJlYXRDYWxsYmFjayIsInJlZiIsInJlY29ubmVjdFRpbWVyIiwidnNuIiwibG9nZ2VyIiwiY29ubiIsInNlbmRCdWZmZXIiLCJzZXJpYWxpemVyIiwic3RhdGVDaGFuZ2VDYWxsYmFja3MiLCJvcGVuIiwiY2xvc2UiLCJlcnJvciIsIm1lc3NhZ2UiLCJhY2Nlc3NUb2tlbiIsIl9jb25uZWN0aW9uU3RhdGUiLCJfd2FzTWFudWFsRGlzY29ubmVjdCIsIl9hdXRoUHJvbWlzZSIsIl9oZWFydGJlYXRTZW50QXQiLCJfcmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJhcmdzIiwiZmV0Y2giLCJhcGlrZXkiLCJFcnJvciIsIndlYnNvY2tldCIsIl9pbml0aWFsaXplT3B0aW9ucyIsIl9zZXR1cFJlY29ubmVjdGlvblRpbWVyIiwiY29ubmVjdCIsImlzQ29ubmVjdGluZyIsImlzRGlzY29ubmVjdGluZyIsImlzQ29ubmVjdGVkIiwiX3NldENvbm5lY3Rpb25TdGF0ZSIsIl9zZXRBdXRoU2FmZWx5IiwiZW5kcG9pbnRVUkwiLCJjcmVhdGVXZWJTb2NrZXQiLCJlcnJvck1lc3NhZ2UiLCJpbmNsdWRlcyIsIl9zZXR1cENvbm5lY3Rpb25IYW5kbGVycyIsIl9hcHBlbmRQYXJhbXMiLCJPYmplY3QiLCJhc3NpZ24iLCJkaXNjb25uZWN0IiwiY29kZSIsInJlYXNvbiIsImZhbGxiYWNrVGltZXIiLCJzZXRUaW1lb3V0Iiwib25jbG9zZSIsImNsZWFyVGltZW91dCIsIl90ZWFyZG93bkNvbm5lY3Rpb24iLCJnZXRDaGFubmVscyIsInJlbW92ZUNoYW5uZWwiLCJjaGFubmVsIiwic3RhdHVzIiwidW5zdWJzY3JpYmUiLCJsZW5ndGgiLCJyZW1vdmVBbGxDaGFubmVscyIsInZhbHVlc18xIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImxvZyIsImtpbmQiLCJtc2ciLCJkYXRhIiwiY29ubmVjdGlvblN0YXRlIiwicmVhZHlTdGF0ZSIsImNvbm5lY3RpbmciLCJDb25uZWN0aW5nIiwiT3BlbiIsImNsb3NpbmciLCJDbG9zaW5nIiwiQ2xvc2VkIiwidG9waWMiLCJjb25maWciLCJyZWFsdGltZVRvcGljIiwiZXhpc3RzIiwiZmluZCIsImMiLCJjaGFuIiwicHVzaCIsImV2ZW50IiwicGF5bG9hZCIsImNhbGxiYWNrIiwiZW5jb2RlIiwicmVzdWx0Iiwic2VuZCIsInNldEF1dGgiLCJ0b2tlbiIsIl9wZXJmb3JtQXV0aCIsIl9pc01hbnVhbFRva2VuIiwic2VuZEhlYXJ0YmVhdCIsImUiLCJzY2hlZHVsZVRpbWVvdXQiLCJEYXRlIiwibm93IiwiX21ha2VSZWYiLCJvbkhlYXJ0YmVhdCIsImZsdXNoU2VuZEJ1ZmZlciIsImZvckVhY2giLCJuZXdSZWYiLCJ0b1N0cmluZyIsIl9sZWF2ZU9wZW5Ub3BpYyIsImR1cENoYW5uZWwiLCJfaXNKb2luZWQiLCJfaXNKb2luaW5nIiwiX3JlbW92ZSIsImZpbHRlciIsIl9vbkNvbm5NZXNzYWdlIiwicmF3TWVzc2FnZSIsImRlY29kZSIsImxhdGVuY3kiLCJyZWZTdHJpbmciLCJ0cmltIiwiX2lzTWVtYmVyIiwiX3RyaWdnZXIiLCJfdHJpZ2dlclN0YXRlQ2FsbGJhY2tzIiwiX2NsZWFyVGltZXIiLCJ0aW1lciIsImNsZWFySW50ZXJ2YWwiLCJyZXNldCIsIl9jbGVhckFsbFRpbWVycyIsImJpbmFyeVR5cGUiLCJvbm9wZW4iLCJfb25Db25uT3BlbiIsIm9uZXJyb3IiLCJfb25Db25uRXJyb3IiLCJvbm1lc3NhZ2UiLCJfb25Db25uQ2xvc2UiLCJfdGVybWluYXRlV29ya2VyIiwidGVhcmRvd24iLCJhdXRoUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiY2F0Y2giLCJ3b3JrZXIiLCJfc3RhcnRIZWFydGJlYXQiLCJ3b3JrZXJSZWYiLCJfc3RhcnRXb3JrZXJIZWFydGJlYXQiLCJzZXRJbnRlcnZhbCIsIndvcmtlclVybCIsIm9iamVjdFVybCIsIl93b3JrZXJPYmplY3RVcmwiLCJXb3JrZXIiLCJwb3N0TWVzc2FnZSIsImludGVydmFsIiwidGVybWluYXRlIiwiX3RyaWdnZXJDaGFuRXJyb3IiLCJ1cmwiLCJrZXlzIiwicHJlZml4IiwibWF0Y2giLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsInJlc3VsdF91cmwiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJzdGF0ZSIsIm1hbnVhbCIsInRva2VuVG9TZW5kIiwiaXNNYW51YWxUb2tlbiIsImFjY2Vzc190b2tlbiIsInZlcnNpb24iLCJ1cGRhdGVKb2luUGF5bG9hZCIsImpvaW5lZE9uY2UiLCJfcHVzaCIsIl93YWl0Rm9yQXV0aElmTmVlZGVkIiwiY29udGV4dCIsInJlY29ubmVjdEFmdGVyTXMiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJfbCIsIl9tIiwibG9nTGV2ZWwiLCJsb2dfbGV2ZWwiLCJ0cmllcyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsImJpbmQiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   \"default\": () => (/* binding */ RealtimePresence)\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/ var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Creates a Presence helper that keeps the local presence state in sync with the server.\n     *\n     * @param channel - The realtime channel to bind to.\n     * @param opts - Optional custom event names, e.g. `{ events: { state: 'state', diff: 'diff' } }`.\n     *\n     * @example\n     * ```ts\n     * const presence = new RealtimePresence(channel)\n     *\n     * channel.on('presence', ({ event, key }) => {\n     *   console.log(`Presence ${event} on ${key}`)\n     * })\n     * ```\n     */ constructor(channel, opts){\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.enabled = false;\n        this.caller = {\n            onJoin: ()=>{},\n            onLeave: ()=>{},\n            onSync: ()=>{}\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: \"presence_state\",\n            diff: \"presence_diff\"\n        };\n        this.channel._on(events.state, {}, (newState)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff)=>{\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            } else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"join\",\n                key,\n                currentPresences,\n                newPresences\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"leave\",\n                key,\n                currentPresences,\n                leftPresences\n            });\n        });\n        this.onSync(()=>{\n            this.channel._trigger(\"presence\", {\n                event: \"sync\"\n            });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */ static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences)=>{\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences)=>{\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);\n                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            } else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, {\n            joins,\n            leaves\n        }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */ static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves)\n        };\n        if (!onJoin) {\n            onJoin = ()=>{};\n        }\n        if (!onLeave) {\n            onLeave = ()=>{};\n        }\n        this.map(joins, (key, newPresences)=>{\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);\n                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences)=>{\n            let currentPresences = state[key];\n            if (!currentPresences) return;\n            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);\n            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0) delete state[key];\n        });\n        return state;\n    }\n    /** @internal */ static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */ static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{\n            const presences = state[key];\n            if (\"metas\" in presences) {\n                newState[key] = presences.metas.map((presence)=>{\n                    presence[\"presence_ref\"] = presence[\"phx_ref\"];\n                    delete presence[\"phx_ref\"];\n                    delete presence[\"phx_ref_prev\"];\n                    return presence;\n                });\n            } else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */ static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */ onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */ onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */ onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */ inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n} //# sourceMappingURL=RealtimePresence.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0FBR0EsR0FDTyxJQUFJQSxnQ0FBZ0M7QUFDMUMsVUFBVUEsK0JBQStCO0lBQ3RDQSwrQkFBK0IsQ0FBQyxPQUFPLEdBQUc7SUFDMUNBLCtCQUErQixDQUFDLE9BQU8sR0FBRztJQUMxQ0EsK0JBQStCLENBQUMsUUFBUSxHQUFHO0FBQy9DLEdBQUdBLG1DQUFvQ0EsQ0FBQUEsa0NBQWtDLENBQUM7QUFDM0QsTUFBTUM7SUFDakI7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxJQUFJLENBQUU7UUFDdkIsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDRSxLQUFLLEdBQUcsQ0FBQztRQUNkLElBQUksQ0FBQ0MsWUFBWSxHQUFHLEVBQUU7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHO1lBQ1ZDLFFBQVEsS0FBUTtZQUNoQkMsU0FBUyxLQUFRO1lBQ2pCQyxRQUFRLEtBQVE7UUFDcEI7UUFDQSxNQUFNQyxTQUFTLENBQUNULFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLUyxNQUFNLEtBQUs7WUFDeEVSLE9BQU87WUFDUFMsTUFBTTtRQUNWO1FBQ0EsSUFBSSxDQUFDWCxPQUFPLENBQUNZLEdBQUcsQ0FBQ0YsT0FBT1IsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDVztZQUNoQyxNQUFNLEVBQUVOLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUNILE1BQU07WUFDL0MsSUFBSSxDQUFDRixPQUFPLEdBQUcsSUFBSSxDQUFDSixPQUFPLENBQUNjLFFBQVE7WUFDcEMsSUFBSSxDQUFDWixLQUFL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QyxVQUFVO29CQUMxQixPQUFPQSxRQUFRLENBQUMsZUFBZTtvQkFDL0IsT0FBT0E7Z0JBQ1g7WUFDSixPQUNLO2dCQUNEeEMsUUFBUSxDQUFDTyxJQUFJLEdBQUdhO1lBQ3BCO1lBQ0EsT0FBT3BCO1FBQ1gsR0FBRyxDQUFDO0lBQ1I7SUFDQSxjQUFjLEdBQ2QsT0FBT2MsVUFBVW9CLEdBQUcsRUFBRTtRQUNsQixPQUFPTyxLQUFLQyxLQUFLLENBQUNELEtBQUtFLFNBQVMsQ0FBQ1Q7SUFDckM7SUFDQSxjQUFjLEdBQ2R4QyxPQUFPa0QsUUFBUSxFQUFFO1FBQ2IsSUFBSSxDQUFDbkQsTUFBTSxDQUFDQyxNQUFNLEdBQUdrRDtJQUN6QjtJQUNBLGNBQWMsR0FDZGpELFFBQVFpRCxRQUFRLEVBQUU7UUFDZCxJQUFJLENBQUNuRCxNQUFNLENBQUNFLE9BQU8sR0FBR2lEO0lBQzFCO0lBQ0EsY0FBYyxHQUNkaEQsT0FBT2dELFFBQVEsRUFBRTtRQUNiLElBQUksQ0FBQ25ELE1BQU0sQ0FBQ0csTUFBTSxHQUFHZ0Q7SUFDekI7SUFDQSxjQUFjLEdBQ2R2QyxxQkFBcUI7UUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQ2QsT0FBTyxJQUFJLElBQUksQ0FBQ0EsT0FBTyxLQUFLLElBQUksQ0FBQ0osT0FBTyxDQUFDYyxRQUFRO0lBQ2xFO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvUmVhbHRpbWVQcmVzZW5jZS5qcz9jZWMzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFRoaXMgZmlsZSBkcmF3cyBoZWF2aWx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvYXNzZXRzL2pzL3Bob2VuaXgvcHJlc2VuY2UuanNcbiAgTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob2VuaXhmcmFtZXdvcmsvcGhvZW5peC9ibG9iL2QzNDRlYzBhNzMyYWI0ZWUyMDQyMTViMzFkZTY5Y2Y0YmU3MmUzYmYvTElDRU5TRS5tZFxuKi9cbmV4cG9ydCB2YXIgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUztcbihmdW5jdGlvbiAoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUykge1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJTWU5DXCJdID0gXCJzeW5jXCI7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIkpPSU5cIl0gPSBcImpvaW5cIjtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiTEVBVkVcIl0gPSBcImxlYXZlXCI7XG59KShSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIHx8IChSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTID0ge30pKTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lUHJlc2VuY2Uge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQcmVzZW5jZSBoZWxwZXIgdGhhdCBrZWVwcyB0aGUgbG9jYWwgcHJlc2VuY2Ugc3RhdGUgaW4gc3luYyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSByZWFsdGltZSBjaGFubmVsIHRvIGJpbmQgdG8uXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBjdXN0b20gZXZlbnQgbmFtZXMsIGUuZy4gYHsgZXZlbnRzOiB7IHN0YXRlOiAnc3RhdGUnLCBkaWZmOiAnZGlmZicgfSB9YC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBwcmVzZW5jZSA9IG5ldyBSZWFsdGltZVByZXNlbmNlKGNoYW5uZWwpXG4gICAgICpcbiAgICAgKiBjaGFubmVsLm9uKCdwcmVzZW5jZScsICh7IGV2ZW50LCBrZXkgfSkgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYFByZXNlbmNlICR7ZXZlbnR9IG9uICR7a2V5fWApXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgICAgdGhpcy5qb2luUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgICAgICAgb25Kb2luOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvbkxlYXZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvblN5bmM6ICgpID0+IHsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5ldmVudHMpIHx8IHtcbiAgICAgICAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICAgICAgb25TeW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICAgICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgICAqIGNsaWVudCdzIHN0YXRlLlxuICAgICAqXG4gICAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGpvaW5zID0ge307XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VzID0gbmV3UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBuZXdQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkUHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgICAqXG4gICAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICAgKiBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCB7IGpvaW5zLCBsZWF2ZXMgfSA9IHtcbiAgICAgICAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgICAgICAgbGVhdmVzOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYubGVhdmVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgICAgICAgIG9uSm9pbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTGVhdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlcyA9IChfYSA9IHN0YXRlW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXM7XG4gICAgICAgICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAgYWJjMTIzOiBbXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgICAqICBhYmMxMjM6IHtcbiAgICAgKiAgICBtZXRhczogW1xuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgICBdXG4gICAgICogIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGNsb25lRGVlcChvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkpvaW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkxlYXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uU3luYyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGluUGVuZGluZ1N5bmNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZVByZXNlbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIiwiUmVhbHRpbWVQcmVzZW5jZSIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsIm9wdHMiLCJzdGF0ZSIsInBlbmRpbmdEaWZmcyIsImpvaW5SZWYiLCJlbmFibGVkIiwiY2FsbGVyIiwib25Kb2luIiwib25MZWF2ZSIsIm9uU3luYyIsImV2ZW50cyIsImRpZmYiLCJfb24iLCJuZXdTdGF0ZSIsIl9qb2luUmVmIiwic3luY1N0YXRlIiwiZm9yRWFjaCIsInN5bmNEaWZmIiwiaW5QZW5kaW5nU3luY1N0YXRlIiwicHVzaCIsImtleSIsImN1cnJlbnRQcmVzZW5jZXMiLCJuZXdQcmVzZW5jZXMiLCJfdHJpZ2dlciIsImV2ZW50IiwibGVmdFByZXNlbmNlcyIsImN1cnJlbnRTdGF0ZSIsImNsb25lRGVlcCIsInRyYW5zZm9ybWVkU3RhdGUiLCJ0cmFuc2Zvcm1TdGF0ZSIsImpvaW5zIiwibGVhdmVzIiwibWFwIiwicHJlc2VuY2VzIiwibmV3UHJlc2VuY2VSZWZzIiwibSIsInByZXNlbmNlX3JlZiIsImN1clByZXNlbmNlUmVmcyIsImpvaW5lZFByZXNlbmNlcyIsImZpbHRlciIsImluZGV4T2YiLCJsZW5ndGgiLCJfYSIsImpvaW5lZFByZXNlbmNlUmVmcyIsImN1clByZXNlbmNlcyIsInVuc2hpZnQiLCJwcmVzZW5jZVJlZnNUb1JlbW92ZSIsIm9iaiIsImZ1bmMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVkdWNlIiwibWV0YXMiLCJwcmVzZW5jZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDMEg7QUFDaEY7QUFDakM7QUFDNkssQ0FDcE8saUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzPzU1NWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJy4vUmVhbHRpbWVDbGllbnQnO1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCwgeyBSRUFMVElNRV9MSVNURU5fVFlQRVMsIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULCBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUywgfSBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCc7XG5pbXBvcnQgUmVhbHRpbWVQcmVzZW5jZSwgeyBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLCB9IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgV2ViU29ja2V0RmFjdG9yeSBmcm9tICcuL2xpYi93ZWJzb2NrZXQtZmFjdG9yeSc7XG5leHBvcnQgeyBSZWFsdGltZVByZXNlbmNlLCBSZWFsdGltZUNoYW5uZWwsIFJlYWx0aW1lQ2xpZW50LCBSRUFMVElNRV9MSVNURU5fVFlQRVMsIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULCBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLCBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUywgV2ViU29ja2V0RmFjdG9yeSwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJSZWFsdGltZUNsaWVudCIsIlJlYWx0aW1lQ2hhbm5lbCIsIlJFQUxUSU1FX0xJU1RFTl9UWVBFUyIsIlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIiwiUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyIsIlJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTIiwiUmVhbHRpbWVQcmVzZW5jZSIsIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCJXZWJTb2NrZXRGYWN0b3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),\n/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),\n/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   DEFAULT_VERSION: () => (/* binding */ DEFAULT_VERSION),\n/* harmony export */   DEFAULT_VSN: () => (/* binding */ DEFAULT_VSN),\n/* harmony export */   MAX_PUSH_BUFFER_SIZE: () => (/* binding */ MAX_PUSH_BUFFER_SIZE),\n/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),\n/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   VSN_1_0_0: () => (/* binding */ VSN_1_0_0),\n/* harmony export */   VSN_2_0_0: () => (/* binding */ VSN_2_0_0),\n/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_VERSION = `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`;\nconst VSN_1_0_0 = \"1.0.0\";\nconst VSN_2_0_0 = \"2.0.0\";\nconst DEFAULT_VSN = VSN_1_0_0;\nconst VERSION = _version__WEBPACK_IMPORTED_MODULE_0__.version;\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst MAX_PUSH_BUFFER_SIZE = 100;\nvar SOCKET_STATES;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDN0IsTUFBTUMsa0JBQWtCLENBQUMsWUFBWSxFQUFFRCw2Q0FBT0EsQ0FBQyxDQUFDLENBQUM7QUFDakQsTUFBTUUsWUFBWSxRQUFRO0FBQzFCLE1BQU1DLFlBQVksUUFBUTtBQUMxQixNQUFNQyxjQUFjRixVQUFVO0FBQzlCLE1BQU1HLFVBQVVMLDZDQUFPQSxDQUFDO0FBQ3hCLE1BQU1NLGtCQUFrQixNQUFNO0FBQzlCLE1BQU1DLGtCQUFrQixLQUFLO0FBQzdCLE1BQU1DLHVCQUF1QixJQUFJO0FBQ2pDLElBQUlDLGNBQWM7QUFDeEIsVUFBVUEsYUFBYTtJQUNwQkEsYUFBYSxDQUFDQSxhQUFhLENBQUMsYUFBYSxHQUFHLEVBQUUsR0FBRztJQUNqREEsYUFBYSxDQUFDQSxhQUFhLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUMzQ0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsVUFBVSxHQUFHLEVBQUUsR0FBRztJQUM5Q0EsYUFBYSxDQUFDQSxhQUFhLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztBQUNqRCxHQUFHQSxpQkFBa0JBLENBQUFBLGdCQUFnQixDQUFDO0FBQy9CLElBQUlDLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFNBQVMsR0FBRztJQUMzQkEsY0FBYyxDQUFDLFVBQVUsR0FBRztJQUM1QkEsY0FBYyxDQUFDLFVBQVUsR0FBRztBQUNoQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ2pDLElBQUlDLGVBQWU7QUFDekIsVUFBVUEsY0FBYztJQUNyQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLE9BQU8sR0FBRztJQUN6QkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLFFBQVEsR0FBRztJQUMxQkEsY0FBYyxDQUFDLGVBQWUsR0FBRztBQUNyQyxHQUFHQSxrQkFBbUJBLENBQUFBLGlCQUFpQixDQUFDO0FBQ2pDLElBQUlDLFdBQVc7QUFDckIsVUFBVUEsVUFBVTtJQUNqQkEsVUFBVSxDQUFDLFlBQVksR0FBRztBQUM5QixHQUFHQSxjQUFlQSxDQUFBQSxhQUFhLENBQUM7QUFDekIsSUFBSUMsaUJBQWlCO0FBQzNCLFVBQVVBLGdCQUFnQjtJQUN2QkEsZ0JBQWdCLENBQUMsYUFBYSxHQUFHO0lBQ2pDQSxnQkFBZ0IsQ0FBQyxPQUFPLEdBQUc7SUFDM0JBLGdCQUFnQixDQUFDLFVBQVUsR0FBRztJQUM5QkEsZ0JBQWdCLENBQUMsU0FBUyxHQUFHO0FBQ2pDLEdBQUdBLG9CQUFxQkEsQ0FBQUEsbUJBQW1CLENBQUMsS0FDNUMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanM/YWMxMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1ZFUlNJT04gPSBgcmVhbHRpbWUtanMvJHt2ZXJzaW9ufWA7XG5leHBvcnQgY29uc3QgVlNOXzFfMF8wID0gJzEuMC4wJztcbmV4cG9ydCBjb25zdCBWU05fMl8wXzAgPSAnMi4wLjAnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVlNOID0gVlNOXzFfMF8wO1xuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSB2ZXJzaW9uO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfVElNRU9VVCA9IDEwMDAwO1xuZXhwb3J0IGNvbnN0IFdTX0NMT1NFX05PUk1BTCA9IDEwMDA7XG5leHBvcnQgY29uc3QgTUFYX1BVU0hfQlVGRkVSX1NJWkUgPSAxMDA7XG5leHBvcnQgdmFyIFNPQ0tFVF9TVEFURVM7XG4oZnVuY3Rpb24gKFNPQ0tFVF9TVEFURVMpIHtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjb25uZWN0aW5nXCJdID0gMF0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJvcGVuXCJdID0gMV0gPSBcIm9wZW5cIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zaW5nXCJdID0gMl0gPSBcImNsb3NpbmdcIjtcbiAgICBTT0NLRVRfU1RBVEVTW1NPQ0tFVF9TVEFURVNbXCJjbG9zZWRcIl0gPSAzXSA9IFwiY2xvc2VkXCI7XG59KShTT0NLRVRfU1RBVEVTIHx8IChTT0NLRVRfU1RBVEVTID0ge30pKTtcbmV4cG9ydCB2YXIgQ0hBTk5FTF9TVEFURVM7XG4oZnVuY3Rpb24gKENIQU5ORUxfU1RBVEVTKSB7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJjbG9zZWRcIl0gPSBcImNsb3NlZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiZXJyb3JlZFwiXSA9IFwiZXJyb3JlZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmVkXCJdID0gXCJqb2luZWRcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImpvaW5pbmdcIl0gPSBcImpvaW5pbmdcIjtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImxlYXZpbmdcIl0gPSBcImxlYXZpbmdcIjtcbn0pKENIQU5ORUxfU1RBVEVTIHx8IChDSEFOTkVMX1NUQVRFUyA9IHt9KSk7XG5leHBvcnQgdmFyIENIQU5ORUxfRVZFTlRTO1xuKGZ1bmN0aW9uIChDSEFOTkVMX0VWRU5UUykge1xuICAgIENIQU5ORUxfRVZFTlRTW1wiY2xvc2VcIl0gPSBcInBoeF9jbG9zZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiZXJyb3JcIl0gPSBcInBoeF9lcnJvclwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiam9pblwiXSA9IFwicGh4X2pvaW5cIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcInJlcGx5XCJdID0gXCJwaHhfcmVwbHlcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImxlYXZlXCJdID0gXCJwaHhfbGVhdmVcIjtcbiAgICBDSEFOTkVMX0VWRU5UU1tcImFjY2Vzc190b2tlblwiXSA9IFwiYWNjZXNzX3Rva2VuXCI7XG59KShDSEFOTkVMX0VWRU5UUyB8fCAoQ0hBTk5FTF9FVkVOVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBUUkFOU1BPUlRTO1xuKGZ1bmN0aW9uIChUUkFOU1BPUlRTKSB7XG4gICAgVFJBTlNQT1JUU1tcIndlYnNvY2tldFwiXSA9IFwid2Vic29ja2V0XCI7XG59KShUUkFOU1BPUlRTIHx8IChUUkFOU1BPUlRTID0ge30pKTtcbmV4cG9ydCB2YXIgQ09OTkVDVElPTl9TVEFURTtcbihmdW5jdGlvbiAoQ09OTkVDVElPTl9TVEFURSkge1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDb25uZWN0aW5nXCJdID0gXCJjb25uZWN0aW5nXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIk9wZW5cIl0gPSBcIm9wZW5cIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiQ2xvc2luZ1wiXSA9IFwiY2xvc2luZ1wiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDbG9zZWRcIl0gPSBcImNsb3NlZFwiO1xufSkoQ09OTkVDVElPTl9TVEFURSB8fCAoQ09OTkVDVElPTl9TVEFURSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJERUZBVUxUX1ZFUlNJT04iLCJWU05fMV8wXzAiLCJWU05fMl8wXzAiLCJERUZBVUxUX1ZTTiIsIlZFUlNJT04iLCJERUZBVUxUX1RJTUVPVVQiLCJXU19DTE9TRV9OT1JNQUwiLCJNQVhfUFVTSF9CVUZGRVJfU0laRSIsIlNPQ0tFVF9TVEFURVMiLCJDSEFOTkVMX1NUQVRFUyIsIkNIQU5ORUxfRVZFTlRTIiwiVFJBTlNQT1JUUyIsIkNPTk5FQ1RJT05fU1RBVEUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Push)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = \"\";\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = \"\";\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived(\"timeout\")) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({\n            status,\n            callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger(\"timeout\", {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel._trigger(this.refEvent, {\n            status,\n            response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response }) {\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n} //# sourceMappingURL=push.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9wdXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBQ3BDLE1BQU1DO0lBQ2pCOzs7Ozs7O0tBT0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFVBQVVOLDJEQUFlLENBQUU7UUFDakUsSUFBSSxDQUFDRyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFlBQVksR0FBR0M7UUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0FDLE9BQU9SLE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ1MsZUFBZTtRQUNwQixJQUFJLENBQUNMLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0csUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0YsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUyxJQUFJO0lBQ2I7SUFDQUEsT0FBTztRQUNILElBQUksSUFBSSxDQUFDQyxZQUFZLENBQUMsWUFBWTtZQUM5QjtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxZQUFZO1FBQ2pCLElBQUksQ0FBQ1gsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSixPQUFPLENBQUNnQixNQUFNLENBQUNDLElBQUksQ0FBQztZQUNyQkMsT0FBTyxJQUFJLENBQUNsQixPQUFPLENBQUNrQixLQUFLO1lBQ3pCakIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCSyxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiWSxVQUFVLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ29CLFFBQVE7UUFDbkM7SUFDSjtJQUNBQyxjQUFjbkIsT0FBTyxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHb0IsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3JCLE9BQU8sR0FBR0E7SUFDbEU7SUFDQXNCLFFBQVFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQ3RCLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNiLFlBQVksQ0FBQ1csU0FBUztZQUMzQkMsU0FBUyxDQUFDQyxLQUFLLElBQUksQ0FBQ25CLFlBQVksTUFBTSxRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHQyxRQUFRO1FBQ3RGO1FBQ0EsSUFBSSxDQUFDbkIsUUFBUSxDQUFDUSxJQUFJLENBQUM7WUFBRVE7WUFBUUM7UUFBUztRQUN0QyxPQUFPLElBQUk7SUFDZjtJQUNBWCxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNWLFlBQVksRUFBRTtZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNnQixNQUFNLENBQUNhLFFBQVE7UUFDdkMsSUFBSSxDQUFDbkIsUUFBUSxHQUFHLElBQUksQ0FBQ1YsT0FBTyxDQUFDOEIsZUFBZSxDQUFDLElBQUksQ0FBQ3ZCLEdBQUc7UUFDckQsTUFBTW1CLFdBQVcsQ0FBQ3hCO1lBQ2QsSUFBSSxDQUFDVSxlQUFlO1lBQ3BCLElBQUksQ0FBQ21CLGNBQWM7WUFDbkIsSUFBSSxDQUFDdkIsWUFBWSxHQUFHTjtZQUNwQixJQUFJLENBQUM4QixhQUFhLENBQUM5QjtRQUN2QjtRQUNBLElBQUksQ0FBQ0YsT0FBTyxDQUFDaUMsR0FBRyxDQUFDLElBQUksQ0FBQ3ZCLFFBQVEsRUFBRSxDQUFDLEdBQUdnQjtRQUNwQyxJQUFJLENBQUNyQixZQUFZLEdBQUc2QixXQUFXO1lBQzNCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUM3QixHQUFHLElBQUksQ0FBQ2hDLE9BQU87SUFDbkI7SUFDQWdDLFFBQVFWLE1BQU0sRUFBRUcsUUFBUSxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDbEIsUUFBUSxFQUNiLElBQUksQ0FBQ1YsT0FBTyxDQUFDb0MsUUFBUSxDQUFDLElBQUksQ0FBQzFCLFFBQVEsRUFBRTtZQUFFZTtZQUFRRztRQUFTO0lBQ2hFO0lBQ0FTLFVBQVU7UUFDTixJQUFJLENBQUN6QixlQUFlO1FBQ3BCLElBQUksQ0FBQ21CLGNBQWM7SUFDdkI7SUFDQW5CLGtCQUFrQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNGLFFBQVEsRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDVixPQUFPLENBQUNzQyxJQUFJLENBQUMsSUFBSSxDQUFDNUIsUUFBUSxFQUFFLENBQUM7SUFDdEM7SUFDQXFCLGlCQUFpQjtRQUNiUSxhQUFhLElBQUksQ0FBQ2xDLFlBQVk7UUFDOUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdDO0lBQ3hCO0lBQ0EwQixjQUFjLEVBQUVQLE1BQU0sRUFBRUcsUUFBUSxFQUFFLEVBQUU7UUFDaEMsSUFBSSxDQUFDbkIsUUFBUSxDQUFDK0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVoQixNQUFNLEtBQUtBLFFBQVFpQixPQUFPLENBQUMsQ0FBQ0QsSUFBTUEsRUFBRWYsUUFBUSxDQUFDRTtJQUMvRTtJQUNBZCxhQUFhVyxNQUFNLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUNqQixZQUFZLElBQUksSUFBSSxDQUFDQSxZQUFZLENBQUNpQixNQUFNLEtBQUtBO0lBQzdEO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanM/NDQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX1RJTUVPVVQgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkID0ge30sIHRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVmID0gJyc7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNIb29rcyA9IFtdO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcmVzZW5kKHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoJ3RpbWVvdXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5fam9pblJlZigpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXlsb2FkKSwgcGF5bG9hZCk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygoX2EgPSB0aGlzLnJlY2VpdmVkUmVzcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5fcmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkO1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKHRoaXMucmVmRXZlbnQsIHt9LCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSk7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5yZWZFdmVudClcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7IHN0YXR1cywgcmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKTtcbiAgICB9XG4gICAgX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWwuX29mZih0aGlzLnJlZkV2ZW50LCB7fSk7XG4gICAgfVxuICAgIF9jYW5jZWxUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX21hdGNoUmVjZWl2ZSh7IHN0YXR1cywgcmVzcG9uc2UgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBfaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJERUZBVUxUX1RJTUVPVVQiLCJQdXNoIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwiZXZlbnQiLCJwYXlsb2FkIiwidGltZW91dCIsInNlbnQiLCJ0aW1lb3V0VGltZXIiLCJ1bmRlZmluZWQiLCJyZWYiLCJyZWNlaXZlZFJlc3AiLCJyZWNIb29rcyIsInJlZkV2ZW50IiwicmVzZW5kIiwiX2NhbmNlbFJlZkV2ZW50Iiwic2VuZCIsIl9oYXNSZWNlaXZlZCIsInN0YXJ0VGltZW91dCIsInNvY2tldCIsInB1c2giLCJ0b3BpYyIsImpvaW5fcmVmIiwiX2pvaW5SZWYiLCJ1cGRhdGVQYXlsb2FkIiwiT2JqZWN0IiwiYXNzaWduIiwicmVjZWl2ZSIsInN0YXR1cyIsImNhbGxiYWNrIiwiX2EiLCJyZXNwb25zZSIsIl9tYWtlUmVmIiwiX3JlcGx5RXZlbnROYW1lIiwiX2NhbmNlbFRpbWVvdXQiLCJfbWF0Y2hSZWNlaXZlIiwiX29uIiwic2V0VGltZW91dCIsInRyaWdnZXIiLCJfdHJpZ2dlciIsImRlc3Ryb3kiLCJfb2ZmIiwiY2xlYXJUaW1lb3V0IiwiZmlsdGVyIiwiaCIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Serializer)\n/* harmony export */ });\nclass Serializer {\n    constructor(allowedMetadataKeys){\n        this.HEADER_LENGTH = 1;\n        this.USER_BROADCAST_PUSH_META_LENGTH = 6;\n        this.KINDS = {\n            userBroadcastPush: 3,\n            userBroadcast: 4\n        };\n        this.BINARY_ENCODING = 0;\n        this.JSON_ENCODING = 1;\n        this.BROADCAST_EVENT = \"broadcast\";\n        this.allowedMetadataKeys = [];\n        this.allowedMetadataKeys = allowedMetadataKeys !== null && allowedMetadataKeys !== void 0 ? allowedMetadataKeys : [];\n    }\n    encode(msg, callback) {\n        if (msg.event === this.BROADCAST_EVENT && !(msg.payload instanceof ArrayBuffer) && typeof msg.payload.event === \"string\") {\n            return callback(this._binaryEncodeUserBroadcastPush(msg));\n        }\n        let payload = [\n            msg.join_ref,\n            msg.ref,\n            msg.topic,\n            msg.event,\n            msg.payload\n        ];\n        return callback(JSON.stringify(payload));\n    }\n    _binaryEncodeUserBroadcastPush(message) {\n        var _a;\n        if (this._isArrayBuffer((_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload)) {\n            return this._encodeBinaryUserBroadcastPush(message);\n        } else {\n            return this._encodeJsonUserBroadcastPush(message);\n        }\n    }\n    _encodeBinaryUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : new ArrayBuffer(0);\n        return this._encodeUserBroadcastPush(message, this.BINARY_ENCODING, userPayload);\n    }\n    _encodeJsonUserBroadcastPush(message) {\n        var _a, _b;\n        const userPayload = (_b = (_a = message.payload) === null || _a === void 0 ? void 0 : _a.payload) !== null && _b !== void 0 ? _b : {};\n        const encoder = new TextEncoder();\n        const encodedUserPayload = encoder.encode(JSON.stringify(userPayload)).buffer;\n        return this._encodeUserBroadcastPush(message, this.JSON_ENCODING, encodedUserPayload);\n    }\n    _encodeUserBroadcastPush(message, encodingType, encodedPayload) {\n        var _a, _b;\n        const topic = message.topic;\n        const ref = (_a = message.ref) !== null && _a !== void 0 ? _a : \"\";\n        const joinRef = (_b = message.join_ref) !== null && _b !== void 0 ? _b : \"\";\n        const userEvent = message.payload.event;\n        // Filter metadata based on allowed keys\n        const rest = this.allowedMetadataKeys ? this._pick(message.payload, this.allowedMetadataKeys) : {};\n        const metadata = Object.keys(rest).length === 0 ? \"\" : JSON.stringify(rest);\n        // Validate lengths don't exceed uint8 max value (255)\n        if (joinRef.length > 255) {\n            throw new Error(`joinRef length ${joinRef.length} exceeds maximum of 255`);\n        }\n        if (ref.length > 255) {\n            throw new Error(`ref length ${ref.length} exceeds maximum of 255`);\n        }\n        if (topic.length > 255) {\n            throw new Error(`topic length ${topic.length} exceeds maximum of 255`);\n        }\n        if (userEvent.length > 255) {\n            throw new Error(`userEvent length ${userEvent.length} exceeds maximum of 255`);\n        }\n        if (metadata.length > 255) {\n            throw new Error(`metadata length ${metadata.length} exceeds maximum of 255`);\n        }\n        const metaLength = this.USER_BROADCAST_PUSH_META_LENGTH + joinRef.length + ref.length + topic.length + userEvent.length + metadata.length;\n        const header = new ArrayBuffer(this.HEADER_LENGTH + metaLength);\n        let view = new DataView(header);\n        let offset = 0;\n        view.setUint8(offset++, this.KINDS.userBroadcastPush); // kind\n        view.setUint8(offset++, joinRef.length);\n        view.setUint8(offset++, ref.length);\n        view.setUint8(offset++, topic.length);\n        view.setUint8(offset++, userEvent.length);\n        view.setUint8(offset++, metadata.length);\n        view.setUint8(offset++, encodingType);\n        Array.from(joinRef, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(ref, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(topic, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(userEvent, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        Array.from(metadata, (char)=>view.setUint8(offset++, char.charCodeAt(0)));\n        var combined = new Uint8Array(header.byteLength + encodedPayload.byteLength);\n        combined.set(new Uint8Array(header), 0);\n        combined.set(new Uint8Array(encodedPayload), header.byteLength);\n        return combined.buffer;\n    }\n    decode(rawPayload, callback) {\n        if (this._isArrayBuffer(rawPayload)) {\n            let result = this._binaryDecode(rawPayload);\n            return callback(result);\n        }\n        if (typeof rawPayload === \"string\") {\n            const jsonPayload = JSON.parse(rawPayload);\n            const [join_ref, ref, topic, event, payload] = jsonPayload;\n            return callback({\n                join_ref,\n                ref,\n                topic,\n                event,\n                payload\n            });\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const kind = view.getUint8(0);\n        const decoder = new TextDecoder();\n        switch(kind){\n            case this.KINDS.userBroadcast:\n                return this._decodeUserBroadcast(buffer, view, decoder);\n        }\n    }\n    _decodeUserBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const userEventSize = view.getUint8(2);\n        const metadataSize = view.getUint8(3);\n        const payloadEncoding = view.getUint8(4);\n        let offset = this.HEADER_LENGTH + 4;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const userEvent = decoder.decode(buffer.slice(offset, offset + userEventSize));\n        offset = offset + userEventSize;\n        const metadata = decoder.decode(buffer.slice(offset, offset + metadataSize));\n        offset = offset + metadataSize;\n        const payload = buffer.slice(offset, buffer.byteLength);\n        const parsedPayload = payloadEncoding === this.JSON_ENCODING ? JSON.parse(decoder.decode(payload)) : payload;\n        const data = {\n            type: this.BROADCAST_EVENT,\n            event: userEvent,\n            payload: parsedPayload\n        };\n        // Metadata is optional and always JSON encoded\n        if (metadataSize > 0) {\n            data[\"meta\"] = JSON.parse(metadata);\n        }\n        return {\n            join_ref: null,\n            ref: null,\n            topic: topic,\n            event: this.BROADCAST_EVENT,\n            payload: data\n        };\n    }\n    _isArrayBuffer(buffer) {\n        var _a;\n        return buffer instanceof ArrayBuffer || ((_a = buffer === null || buffer === void 0 ? void 0 : buffer.constructor) === null || _a === void 0 ? void 0 : _a.name) === \"ArrayBuffer\";\n    }\n    _pick(obj, keys) {\n        if (!obj || typeof obj !== \"object\") {\n            return {};\n        }\n        return Object.fromEntries(Object.entries(obj).filter(([key])=>keys.includes(key)));\n    }\n} //# sourceMappingURL=serializer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZSxNQUFNQTtJQUNqQkMsWUFBWUMsbUJBQW1CLENBQUU7UUFDN0IsSUFBSSxDQUFDQyxhQUFhLEdBQUc7UUFDckIsSUFBSSxDQUFDQywrQkFBK0IsR0FBRztRQUN2QyxJQUFJLENBQUNDLEtBQUssR0FBRztZQUFFQyxtQkFBbUI7WUFBR0MsZUFBZTtRQUFFO1FBQ3RELElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ1IsbUJBQW1CLEdBQUcsRUFBRTtRQUM3QixJQUFJLENBQUNBLG1CQUFtQixHQUFHQSx3QkFBd0IsUUFBUUEsd0JBQXdCLEtBQUssSUFBSUEsc0JBQXNCLEVBQUU7SUFDeEg7SUFDQVMsT0FBT0MsR0FBRyxFQUFFQyxRQUFRLEVBQUU7UUFDbEIsSUFBSUQsSUFBSUUsS0FBSyxLQUFLLElBQUksQ0FBQ0osZUFBZSxJQUNsQyxDQUFFRSxDQUFBQSxJQUFJRyxPQUFPLFlBQVlDLFdBQVUsS0FDbkMsT0FBT0osSUFBSUcsT0FBTyxDQUFDRCxLQUFLLEtBQUssVUFBVTtZQUN2QyxPQUFPRCxTQUFTLElBQUksQ0FBQ0ksOEJBQThCLENBQUNMO1FBQ3hEO1FBQ0EsSUFBSUcsVUFBVTtZQUFDSCxJQUFJTSxRQUFRO1lBQUVOLElBQUlPLEdBQUc7WUFBRVAsSUFBSVEsS0FBSztZQUFFUixJQUFJRSxLQUFLO1lBQUVGLElBQUlHLE9BQU87U0FBQztRQUN4RSxPQUFPRixTQUFTUSxLQUFLQyxTQUFTLENBQUNQO0lBQ25DO0lBQ0FFLCtCQUErQk0sT0FBTyxFQUFFO1FBQ3BDLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQyxDQUFDRCxLQUFLRCxRQUFRUixPQUFPLE1B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QVcsTUFBTSxRQUFRdUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHdUQsSUFBSSxNQUFNO0lBQ3pLO0lBQ0F2QyxNQUFNd0MsR0FBRyxFQUFFckMsSUFBSSxFQUFFO1FBQ2IsSUFBSSxDQUFDcUMsT0FBTyxPQUFPQSxRQUFRLFVBQVU7WUFDakMsT0FBTyxDQUFDO1FBQ1o7UUFDQSxPQUFPdEMsT0FBT3VDLFdBQVcsQ0FBQ3ZDLE9BQU93QyxPQUFPLENBQUNGLEtBQUtHLE1BQU0sQ0FBQyxDQUFDLENBQUNDLElBQUksR0FBS3pDLEtBQUswQyxRQUFRLENBQUNEO0lBQ2xGO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3NlcmlhbGl6ZXIuanM/ODFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihhbGxvd2VkTWV0YWRhdGFLZXlzKSB7XG4gICAgICAgIHRoaXMuSEVBREVSX0xFTkdUSCA9IDE7XG4gICAgICAgIHRoaXMuVVNFUl9CUk9BRENBU1RfUFVTSF9NRVRBX0xFTkdUSCA9IDY7XG4gICAgICAgIHRoaXMuS0lORFMgPSB7IHVzZXJCcm9hZGNhc3RQdXNoOiAzLCB1c2VyQnJvYWRjYXN0OiA0IH07XG4gICAgICAgIHRoaXMuQklOQVJZX0VOQ09ESU5HID0gMDtcbiAgICAgICAgdGhpcy5KU09OX0VOQ09ESU5HID0gMTtcbiAgICAgICAgdGhpcy5CUk9BRENBU1RfRVZFTlQgPSAnYnJvYWRjYXN0JztcbiAgICAgICAgdGhpcy5hbGxvd2VkTWV0YWRhdGFLZXlzID0gW107XG4gICAgICAgIHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5cyA9IGFsbG93ZWRNZXRhZGF0YUtleXMgIT09IG51bGwgJiYgYWxsb3dlZE1ldGFkYXRhS2V5cyAhPT0gdm9pZCAwID8gYWxsb3dlZE1ldGFkYXRhS2V5cyA6IFtdO1xuICAgIH1cbiAgICBlbmNvZGUobXNnLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAobXNnLmV2ZW50ID09PSB0aGlzLkJST0FEQ0FTVF9FVkVOVCAmJlxuICAgICAgICAgICAgIShtc2cucGF5bG9hZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSAmJlxuICAgICAgICAgICAgdHlwZW9mIG1zZy5wYXlsb2FkLmV2ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2JpbmFyeUVuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1zZykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXlsb2FkID0gW21zZy5qb2luX3JlZiwgbXNnLnJlZiwgbXNnLnRvcGljLCBtc2cuZXZlbnQsIG1zZy5wYXlsb2FkXTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgICB9XG4gICAgX2JpbmFyeUVuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5faXNBcnJheUJ1ZmZlcigoX2EgPSBtZXNzYWdlLnBheWxvYWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXlsb2FkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUJpbmFyeVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZUpzb25Vc2VyQnJvYWRjYXN0UHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZW5jb2RlQmluYXJ5VXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB1c2VyUGF5bG9hZCA9IChfYiA9IChfYSA9IG1lc3NhZ2UucGF5bG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBheWxvYWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVVzZXJCcm9hZGNhc3RQdXNoKG1lc3NhZ2UsIHRoaXMuQklOQVJZX0VOQ09ESU5HLCB1c2VyUGF5bG9hZCk7XG4gICAgfVxuICAgIF9lbmNvZGVKc29uVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB1c2VyUGF5bG9hZCA9IChfYiA9IChfYSA9IG1lc3NhZ2UucGF5bG9hZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBheWxvYWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGVuY29kZWRVc2VyUGF5bG9hZCA9IGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHVzZXJQYXlsb2FkKSkuYnVmZmVyO1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSwgdGhpcy5KU09OX0VOQ09ESU5HLCBlbmNvZGVkVXNlclBheWxvYWQpO1xuICAgIH1cbiAgICBfZW5jb2RlVXNlckJyb2FkY2FzdFB1c2gobWVzc2FnZSwgZW5jb2RpbmdUeXBlLCBlbmNvZGVkUGF5bG9hZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG1lc3NhZ2UudG9waWM7XG4gICAgICAgIGNvbnN0IHJlZiA9IChfYSA9IG1lc3NhZ2UucmVmKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3Qgam9pblJlZiA9IChfYiA9IG1lc3NhZ2Uuam9pbl9yZWYpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgICAgICBjb25zdCB1c2VyRXZlbnQgPSBtZXNzYWdlLnBheWxvYWQuZXZlbnQ7XG4gICAgICAgIC8vIEZpbHRlciBtZXRhZGF0YSBiYXNlZCBvbiBhbGxvd2VkIGtleXNcbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuYWxsb3dlZE1ldGFkYXRhS2V5c1xuICAgICAgICAgICAgPyB0aGlzLl9waWNrKG1lc3NhZ2UucGF5bG9hZCwgdGhpcy5hbGxvd2VkTWV0YWRhdGFLZXlzKVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBPYmplY3Qua2V5cyhyZXN0KS5sZW5ndGggPT09IDAgPyAnJyA6IEpTT04uc3RyaW5naWZ5KHJlc3QpO1xuICAgICAgICAvLyBWYWxpZGF0ZSBsZW5ndGhzIGRvbid0IGV4Y2VlZCB1aW50OCBtYXggdmFsdWUgKDI1NSlcbiAgICAgICAgaWYgKGpvaW5SZWYubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGpvaW5SZWYgbGVuZ3RoICR7am9pblJlZi5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmLmxlbmd0aCA+IDI1NSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWYgbGVuZ3RoICR7cmVmLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpYy5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdG9waWMgbGVuZ3RoICR7dG9waWMubGVuZ3RofSBleGNlZWRzIG1heGltdW0gb2YgMjU1YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJFdmVudC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdXNlckV2ZW50IGxlbmd0aCAke3VzZXJFdmVudC5sZW5ndGh9IGV4Y2VlZHMgbWF4aW11bSBvZiAyNTVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGEubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1ldGFkYXRhIGxlbmd0aCAke21ldGFkYXRhLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIG9mIDI1NWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFMZW5ndGggPSB0aGlzLlVTRVJfQlJPQURDQVNUX1BVU0hfTUVUQV9MRU5HVEggK1xuICAgICAgICAgICAgam9pblJlZi5sZW5ndGggK1xuICAgICAgICAgICAgcmVmLmxlbmd0aCArXG4gICAgICAgICAgICB0b3BpYy5sZW5ndGggK1xuICAgICAgICAgICAgdXNlckV2ZW50Lmxlbmd0aCArXG4gICAgICAgICAgICBtZXRhZGF0YS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLkhFQURFUl9MRU5HVEggKyBtZXRhTGVuZ3RoKTtcbiAgICAgICAgbGV0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRoaXMuS0lORFMudXNlckJyb2FkY2FzdFB1c2gpOyAvLyBraW5kXG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGpvaW5SZWYubGVuZ3RoKTtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgcmVmLmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHRvcGljLmxlbmd0aCk7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssIHVzZXJFdmVudC5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBtZXRhZGF0YS5sZW5ndGgpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBlbmNvZGluZ1R5cGUpO1xuICAgICAgICBBcnJheS5mcm9tKGpvaW5SZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgQXJyYXkuZnJvbShyZWYsIChjaGFyKSA9PiB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjaGFyLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgQXJyYXkuZnJvbSh0b3BpYywgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICBBcnJheS5mcm9tKHVzZXJFdmVudCwgKGNoYXIpID0+IHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNoYXIuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICBBcnJheS5mcm9tKG1ldGFkYXRhLCAoY2hhcikgPT4gdmlldy5zZXRVaW50OChvZmZzZXQrKywgY2hhci5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHZhciBjb21iaW5lZCA9IG5ldyBVaW50OEFycmF5KGhlYWRlci5ieXRlTGVuZ3RoICsgZW5jb2RlZFBheWxvYWQuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbWJpbmVkLnNldChuZXcgVWludDhBcnJheShoZWFkZXIpLCAwKTtcbiAgICAgICAgY29tYmluZWQuc2V0KG5ldyBVaW50OEFycmF5KGVuY29kZWRQYXlsb2FkKSwgaGVhZGVyLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29tYmluZWQuYnVmZmVyO1xuICAgIH1cbiAgICBkZWNvZGUocmF3UGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXJyYXlCdWZmZXIocmF3UGF5bG9hZCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl9iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJhd1BheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBqc29uUGF5bG9hZCA9IEpTT04ucGFyc2UocmF3UGF5bG9hZCk7XG4gICAgICAgICAgICBjb25zdCBbam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkXSA9IGpzb25QYXlsb2FkO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHsgam9pbl9yZWYsIHJlZiwgdG9waWMsIGV2ZW50LCBwYXlsb2FkIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh7fSk7XG4gICAgfVxuICAgIF9iaW5hcnlEZWNvZGUoYnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICAgICAgY29uc3Qga2luZCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlIHRoaXMuS0lORFMudXNlckJyb2FkY2FzdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlVXNlckJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kZWNvZGVVc2VyQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgICBjb25zdCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICBjb25zdCB1c2VyRXZlbnRTaXplID0gdmlldy5nZXRVaW50OCgyKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGFTaXplID0gdmlldy5nZXRVaW50OCgzKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZEVuY29kaW5nID0gdmlldy5nZXRVaW50OCg0KTtcbiAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMuSEVBREVSX0xFTkdUSCArIDQ7XG4gICAgICAgIGNvbnN0IHRvcGljID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdG9waWNTaXplKSk7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIHRvcGljU2l6ZTtcbiAgICAgICAgY29uc3QgdXNlckV2ZW50ID0gZGVjb2Rlci5kZWNvZGUoYnVmZmVyLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdXNlckV2ZW50U2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyB1c2VyRXZlbnRTaXplO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIG1ldGFkYXRhU2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBtZXRhZGF0YVNpemU7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBidWZmZXIuc2xpY2Uob2Zmc2V0LCBidWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHBhcnNlZFBheWxvYWQgPSBwYXlsb2FkRW5jb2RpbmcgPT09IHRoaXMuSlNPTl9FTkNPRElORyA/IEpTT04ucGFyc2UoZGVjb2Rlci5kZWNvZGUocGF5bG9hZCkpIDogcGF5bG9hZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuQlJPQURDQVNUX0VWRU5ULFxuICAgICAgICAgICAgZXZlbnQ6IHVzZXJFdmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBhcnNlZFBheWxvYWQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE1ldGFkYXRhIGlzIG9wdGlvbmFsIGFuZCBhbHdheXMgSlNPTiBlbmNvZGVkXG4gICAgICAgIGlmIChtZXRhZGF0YVNpemUgPiAwKSB7XG4gICAgICAgICAgICBkYXRhWydtZXRhJ10gPSBKU09OLnBhcnNlKG1ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBqb2luX3JlZjogbnVsbCwgcmVmOiBudWxsLCB0b3BpYzogdG9waWMsIGV2ZW50OiB0aGlzLkJST0FEQ0FTVF9FVkVOVCwgcGF5bG9hZDogZGF0YSB9O1xuICAgIH1cbiAgICBfaXNBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgKChfYSA9IGJ1ZmZlciA9PT0gbnVsbCB8fCBidWZmZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1ZmZlci5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUpID09PSAnQXJyYXlCdWZmZXInO1xuICAgIH1cbiAgICBfcGljayhvYmosIGtleXMpIHtcbiAgICAgICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKG9iaikuZmlsdGVyKChba2V5XSkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplci5qcy5tYXAiXSwibmFtZXMiOlsiU2VyaWFsaXplciIsImNvbnN0cnVjdG9yIiwiYWxsb3dlZE1ldGFkYXRhS2V5cyIsIkhFQURFUl9MRU5HVEgiLCJVU0VSX0JST0FEQ0FTVF9QVVNIX01FVEFfTEVOR1RIIiwiS0lORFMiLCJ1c2VyQnJvYWRjYXN0UHVzaCIsInVzZXJCcm9hZGNhc3QiLCJCSU5BUllfRU5DT0RJTkciLCJKU09OX0VOQ09ESU5HIiwiQlJPQURDQVNUX0VWRU5UIiwiZW5jb2RlIiwibXNnIiwiY2FsbGJhY2siLCJldmVudCIsInBheWxvYWQiLCJBcnJheUJ1ZmZlciIsIl9iaW5hcnlFbmNvZGVVc2VyQnJvYWRjYXN0UHVzaCIsImpvaW5fcmVmIiwicmVmIiwidG9waWMiLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZSIsIl9hIiwiX2lzQXJyYXlCdWZmZXIiLCJfZW5jb2RlQmluYXJ5VXNlckJyb2FkY2FzdFB1c2giLCJfZW5jb2RlSnNvblVzZXJCcm9hZGNhc3RQdXNoIiwiX2IiLCJ1c2VyUGF5bG9hZCIsIl9lbmNvZGVVc2VyQnJvYWRjYXN0UHVzaCIsImVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZWRVc2VyUGF5bG9hZCIsImJ1ZmZlciIsImVuY29kaW5nVHlwZSIsImVuY29kZWRQYXlsb2FkIiwiam9pblJlZiIsInVzZXJFdmVudCIsInJlc3QiLCJfcGljayIsIm1ldGFkYXRhIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsIkVycm9yIiwibWV0YUxlbmd0aCIsImhlYWRlciIsInZpZXciLCJEYXRhVmlldyIsIm9mZnNldCIsInNldFVpbnQ4IiwiQXJyYXkiLCJmcm9tIiwiY2hhciIsImNoYXJDb2RlQXQiLCJjb21iaW5lZCIsIlVpbnQ4QXJyYXkiLCJieXRlTGVuZ3RoIiwic2V0IiwiZGVjb2RlIiwicmF3UGF5bG9hZCIsInJlc3VsdCIsIl9iaW5hcnlEZWNvZGUiLCJqc29uUGF5bG9hZCIsInBhcnNlIiwia2luZCIsImdldFVpbnQ4IiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiX2RlY29kZVVzZXJCcm9hZGNhc3QiLCJ0b3BpY1NpemUiLCJ1c2VyRXZlbnRTaXplIiwibWV0YWRhdGFTaXplIiwicGF5bG9hZEVuY29kaW5nIiwic2xpY2UiLCJwYXJzZWRQYXlsb2FkIiwiZGF0YSIsInR5cGUiLCJuYW1lIiwib2JqIiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiZmlsdGVyIiwia2V5IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class Timer {\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n} //# sourceMappingURL=timer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90aW1lci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDYyxNQUFNQTtJQUNqQkMsWUFBWUMsUUFBUSxFQUFFQyxTQUFTLENBQUU7UUFDN0IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLEtBQUssR0FBR0M7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0osUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDckI7SUFDQUksUUFBUTtRQUNKLElBQUksQ0FBQ0QsS0FBSyxHQUFHO1FBQ2JFLGFBQWEsSUFBSSxDQUFDSixLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQztJQUNqQjtJQUNBLDhEQUE4RDtJQUM5REksa0JBQWtCO1FBQ2RELGFBQWEsSUFBSSxDQUFDSixLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHTSxXQUFXO1lBQ3BCLElBQUksQ0FBQ0osS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHO1lBQzFCLElBQUksQ0FBQ0osUUFBUTtRQUNqQixHQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQ0csS0FBSyxHQUFHO0lBQ25DO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RpbWVyLmpzPzExNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybSBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogICAgfSlcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDE7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIl0sIm5hbWVzIjpbIlRpbWVyIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsInRpbWVyQ2FsYyIsInRpbWVyIiwidW5kZWZpbmVkIiwidHJpZXMiLCJyZXNldCIsImNsZWFyVGltZW91dCIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),\n/* harmony export */   convertCell: () => (/* binding */ convertCell),\n/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),\n/* harmony export */   convertColumn: () => (/* binding */ convertColumn),\n/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toJson: () => (/* binding */ toJson),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */ const convertChangeData = (columns, record, options = {})=>{\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */ const convertColumn = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */ const convertCell = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === \"_\") {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime:\n        case PostgresTypes.date:\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime:\n        case PostgresTypes.text:\n        case PostgresTypes.time:\n        case PostgresTypes.timestamptz:\n        case PostgresTypes.timetz:\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value)=>{\n    return value;\n};\nconst toBoolean = (value)=>{\n    switch(value){\n        case \"t\":\n            return true;\n        case \"f\":\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value)=>{\n    if (typeof value === \"string\") {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value)=>{\n    if (typeof value === \"string\") {\n        try {\n            return JSON.parse(value);\n        } catch (_a) {\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */ const toArray = (value, type)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === \"{\" && closeBrace === \"}\") {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse(\"[\" + valTrim + \"]\");\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(\",\") : [];\n        }\n        return arr.map((val)=>convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */ const toTimestampString = (value)=>{\n    if (typeof value === \"string\") {\n        return value.replace(\" \", \"T\");\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl)=>{\n    const wsUrl = new URL(socketUrl);\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, \"http\");\n    wsUrl.pathname = wsUrl.pathname.replace(/\\/+$/, \"\") // remove all trailing slashes\n    .replace(/\\/socket\\/websocket$/i, \"\") // remove the socket/websocket path\n    .replace(/\\/socket$/i, \"\") // remove the socket path\n    .replace(/\\/websocket$/i, \"\"); // remove the websocket path\n    if (wsUrl.pathname === \"\" || wsUrl.pathname === \"/\") {\n        wsUrl.pathname = \"/api/broadcast\";\n    } else {\n        wsUrl.pathname = wsUrl.pathname + \"/api/broadcast\";\n    }\n    return wsUrl.href;\n}; //# sourceMappingURL=transformers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0QsMEVBQTBFO0FBQzFFLHlGQUF5RjtBQUNsRixJQUFJQSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxNQUFNLEdBQUc7SUFDdkJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7QUFDakMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0Qzs7Ozs7Ozs7Ozs7Q0FXQyxH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QUMsS0FBSztJQUM5QjtJQUNBLE9BQU9wRDtBQUNYLEVBQUU7QUFDSyxNQUFNcUQsa0JBQWtCLENBQUNDO0lBQzVCLE1BQU1DLFFBQVEsSUFBSUMsSUFBSUY7SUFDdEJDLE1BQU1FLFFBQVEsR0FBR0YsTUFBTUUsUUFBUSxDQUFDTCxPQUFPLENBQUMsUUFBUTtJQUNoREcsTUFBTUcsUUFBUSxHQUFHSCxNQUFNRyxRQUFRLENBQzFCTixPQUFPLENBQUMsUUFBUSxJQUFJLDhCQUE4QjtLQUNsREEsT0FBTyxDQUFDLHlCQUF5QixJQUFJLG1DQUFtQztLQUN4RUEsT0FBTyxDQUFDLGNBQWMsSUFBSSx5QkFBeUI7S0FDbkRBLE9BQU8sQ0FBQyxpQkFBaUIsS0FBSyw0QkFBNEI7SUFDL0QsSUFBSUcsTUFBTUcsUUFBUSxLQUFLLE1BQU1ILE1BQU1HLFFBQVEsS0FBSyxLQUFLO1FBQ2pESCxNQUFNRyxRQUFRLEdBQUc7SUFDckIsT0FDSztRQUNESCxNQUFNRyxRQUFRLEdBQUdILE1BQU1HLFFBQVEsR0FBRztJQUN0QztJQUNBLE9BQU9ILE1BQU1JLElBQUk7QUFDckIsRUFBRSxDQUNGLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlZGRpbmctZ3Vlc3QtYXBwLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvdHJhbnNmb3JtZXJzLmpzPzNmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZWxwZXJzIHRvIGNvbnZlcnQgdGhlIGNoYW5nZSBQYXlsb2FkIGludG8gbmF0aXZlIEpTIHR5cGVzLlxuICovXG4vLyBBZGFwdGVkIGZyb20gZXBnc3FsIChzcmMvZXBnc3FsX2JpbmFyeS5lcmwpLCB0aGlzIG1vZHVsZSBsaWNlbnNlZCB1bmRlclxuLy8gMy1jbGF1c2UgQlNEIGZvdW5kIGhlcmU6IGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9lcGdzcWwvZXBnc3FsL2RldmVsL0xJQ0VOU0VcbmV4cG9ydCB2YXIgUG9zdGdyZXNUeXBlcztcbihmdW5jdGlvbiAoUG9zdGdyZXNUeXBlcykge1xuICAgIFBvc3RncmVzVHlwZXNbXCJhYnN0aW1lXCJdID0gXCJhYnN0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImJvb2xcIl0gPSBcImJvb2xcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiZGF0ZVwiXSA9IFwiZGF0ZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlcmFuZ2VcIl0gPSBcImRhdGVyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDRcIl0gPSBcImZsb2F0NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJmbG9hdDhcIl0gPSBcImZsb2F0OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQyXCJdID0gXCJpbnQyXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDRcIl0gPSBcImludDRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NHJhbmdlXCJdID0gXCJpbnQ0cmFuZ2VcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50OFwiXSA9IFwiaW50OFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4cmFuZ2VcIl0gPSBcImludDhyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJqc29uXCJdID0gXCJqc29uXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25iXCJdID0gXCJqc29uYlwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJtb25leVwiXSA9IFwibW9uZXlcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wibnVtZXJpY1wiXSA9IFwibnVtZXJpY1wiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJvaWRcIl0gPSBcIm9pZFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJyZWx0aW1lXCJdID0gXCJyZWx0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRleHRcIl0gPSBcInRleHRcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZVwiXSA9IFwidGltZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXBcIl0gPSBcInRpbWVzdGFtcFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lc3RhbXB0elwiXSA9IFwidGltZXN0YW1wdHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGltZXR6XCJdID0gXCJ0aW1ldHpcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widHNyYW5nZVwiXSA9IFwidHNyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3R6cmFuZ2VcIl0gPSBcInRzdHpyYW5nZVwiO1xufSkoUG9zdGdyZXNUeXBlcyB8fCAoUG9zdGdyZXNUeXBlcyA9IHt9KSk7XG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIGNvbHVtbnMgYW5kIGFuIG9iamVjdCBvZiBzdHJpbmcgdmFsdWVzIHRoZW4gY29udmVydHMgZWFjaCBzdHJpbmcgdmFsdWVcbiAqIHRvIGl0cyBtYXBwZWQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1uc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY29yZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG1hcCBvZiB2YXJpb3VzIG9wdGlvbnMgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0aGUgbWFwcGVyXG4gKiBAcGFyYW0ge0FycmF5fSBvcHRpb25zLnNraXBUeXBlcyBUaGUgYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDaGFuZ2VEYXRhKFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6JzMzJ30sIHt9KVxuICogLy89PnsgZmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6IDMzIH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDaGFuZ2VEYXRhID0gKGNvbHVtbnMsIHJlY29yZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNraXBUeXBlcyA9IChfYSA9IG9wdGlvbnMuc2tpcFR5cGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICBpZiAoIXJlY29yZCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZWNvcmQpLnJlZHVjZSgoYWNjLCByZWNfa2V5KSA9PiB7XG4gICAgICAgIGFjY1tyZWNfa2V5XSA9IGNvbnZlcnRDb2x1bW4ocmVjX2tleSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIHRoZSB2YWx1ZSBvZiBhbiBpbmRpdmlkdWFsIGNvbHVtbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uTmFtZSBUaGUgY29sdW1uIHRoYXQgeW91IHdhbnQgdG8gY29udmVydFxuICogQHBhcmFtIHt7bmFtZTogU3RyaW5nLCB0eXBlOiBTdHJpbmd9W119IGNvbHVtbnMgQWxsIG9mIHRoZSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkIFRoZSBtYXAgb2Ygc3RyaW5nIHZhbHVlc1xuICogQHBhcmFtIHtBcnJheX0gc2tpcFR5cGVzIEFuIGFycmF5IG9mIHR5cGVzIHRoYXQgc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWRcbiAqIEByZXR1cm4ge29iamVjdH0gVXNlbGVzcyBpbmZvcm1hdGlvblxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbXSlcbiAqIC8vPT4gMzNcbiAqIEBleGFtcGxlIGNvbnZlcnRDb2x1bW4oJ2FnZScsIFt7bmFtZTogJ2ZpcnN0X25hbWUnLCB0eXBlOiAndGV4dCd9LCB7bmFtZTogJ2FnZScsIHR5cGU6ICdpbnQ0J31dLCB7Zmlyc3RfbmFtZTogJ1BhdWwnLCBhZ2U6ICczMyd9LCBbJ2ludDQnXSlcbiAqIC8vPT4gXCIzM1wiXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q29sdW1uID0gKGNvbHVtbk5hbWUsIGNvbHVtbnMsIHJlY29yZCwgc2tpcFR5cGVzKSA9PiB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1ucy5maW5kKCh4KSA9PiB4Lm5hbWUgPT09IGNvbHVtbk5hbWUpO1xuICAgIGNvbnN0IGNvbFR5cGUgPSBjb2x1bW4gPT09IG51bGwgfHwgY29sdW1uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2x1bW4udHlwZTtcbiAgICBjb25zdCB2YWx1ZSA9IHJlY29yZFtjb2x1bW5OYW1lXTtcbiAgICBpZiAoY29sVHlwZSAmJiAhc2tpcFR5cGVzLmluY2x1ZGVzKGNvbFR5cGUpKSB7XG4gICAgICAgIHJldHVybiBjb252ZXJ0Q2VsbChjb2xUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBub29wKHZhbHVlKTtcbn07XG4vKipcbiAqIElmIHRoZSB2YWx1ZSBvZiB0aGUgY2VsbCBpcyBgbnVsbGAsIHJldHVybnMgbnVsbC5cbiAqIE90aGVyd2lzZSBjb252ZXJ0cyB0aGUgc3RyaW5nIHZhbHVlIHRvIHRoZSBjb3JyZWN0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHBvc3RncmVzIGNvbHVtbiB0eXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNlbGwgdmFsdWVcbiAqXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnYm9vbCcsICd0JylcbiAqIC8vPT4gdHJ1ZVxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ2ludDgnLCAnMTAnKVxuICogLy89PiAxMFxuICogQGV4YW1wbGUgY29udmVydENlbGwoJ19pbnQ0JywgJ3sxLDIsMyw0fScpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENlbGwgPSAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAvLyBpZiBkYXRhIHR5cGUgaXMgYW4gYXJyYXlcbiAgICBpZiAodHlwZS5jaGFyQXQoMCkgPT09ICdfJykge1xuICAgICAgICBjb25zdCBkYXRhVHlwZSA9IHR5cGUuc2xpY2UoMSwgdHlwZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdG9BcnJheSh2YWx1ZSwgZGF0YVR5cGUpO1xuICAgIH1cbiAgICAvLyBJZiBub3QgbnVsbCwgY29udmVydCB0byBjb3JyZWN0IHR5cGUuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5ib29sOlxuICAgICAgICAgICAgcmV0dXJuIHRvQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDQ6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5mbG9hdDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQyOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDg6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5udW1lcmljOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMub2lkOlxuICAgICAgICAgICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb246XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5qc29uYjpcbiAgICAgICAgICAgIHJldHVybiB0b0pzb24odmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wOlxuICAgICAgICAgICAgcmV0dXJuIHRvVGltZXN0YW1wU3RyaW5nKHZhbHVlKTsgLy8gRm9ybWF0IHRvIGJlIGNvbnNpc3RlbnQgd2l0aCBQb3N0Z1JFU1RcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmFic3RpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmRhdGVyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDRyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDhyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm1vbmV5OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMucmVsdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGV4dDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWU6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWVzdGFtcHR6OiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1ldHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzcmFuZ2U6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50c3R6cmFuZ2U6XG4gICAgICAgICAgICByZXR1cm4gbm9vcCh2YWx1ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciByZW1haW5pbmcgdHlwZXNcbiAgICAgICAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3Qgbm9vcCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgdG9Cb29sZWFuID0gKHZhbHVlKSA9PiB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCB0b0pzb24gPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgUG9zdGdyZXMgQXJyYXkgaW50byBhIG5hdGl2ZSBKUyBhcnJheVxuICpcbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3t9JywgJ2ludDQnKVxuICogLy89PiBbXVxuICogQGV4YW1wbGUgdG9BcnJheSgne1wiWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSlcIixcIigyMDIxLTAxLTAxLDIwMjEtMTItMzJdXCJ9JywgJ2RhdGVyYW5nZScpXG4gKiAvLz0+IFsnWzIwMjEtMDEtMDEsMjAyMS0xMi0zMSknLCAnKDIwMjEtMDEtMDEsMjAyMS0xMi0zMl0nXVxuICogQGV4YW1wbGUgdG9BcnJheShbMSwyLDMsNF0sICdpbnQ0JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gKHZhbHVlLCB0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0SWR4ID0gdmFsdWUubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjbG9zZUJyYWNlID0gdmFsdWVbbGFzdElkeF07XG4gICAgY29uc3Qgb3BlbkJyYWNlID0gdmFsdWVbMF07XG4gICAgLy8gQ29uZmlybSB2YWx1ZSBpcyBhIFBvc3RncmVzIGFycmF5IGJ5IGNoZWNraW5nIGN1cmx5IGJyYWNrZXRzXG4gICAgaWYgKG9wZW5CcmFjZSA9PT0gJ3snICYmIGNsb3NlQnJhY2UgPT09ICd9Jykge1xuICAgICAgICBsZXQgYXJyO1xuICAgICAgICBjb25zdCB2YWxUcmltID0gdmFsdWUuc2xpY2UoMSwgbGFzdElkeCk7XG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gdG8gc2VwYXJhdGUgUG9zdGdyZXMgYXJyYXkgZGF0YVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXJyID0gSlNPTi5wYXJzZSgnWycgKyB2YWxUcmltICsgJ10nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gV0FSTklORzogc3BsaXR0aW5nIG9uIGNvbW1hIGRvZXMgbm90IGNvdmVyIGFsbCBlZGdlIGNhc2VzXG4gICAgICAgICAgICBhcnIgPSB2YWxUcmltID8gdmFsVHJpbS5zcGxpdCgnLCcpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKHZhbCkgPT4gY29udmVydENlbGwodHlwZSwgdmFsKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG4vKipcbiAqIEZpeGVzIHRpbWVzdGFtcCB0byBiZSBJU08tODYwMS4gU3dhcHMgdGhlIHNwYWNlIGJldHdlZW4gdGhlIGRhdGUgYW5kIHRpbWUgZm9yIGEgJ1QnXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3N1cGFiYXNlL2lzc3Vlcy8xOFxuICpcbiAqIEBleGFtcGxlIHRvVGltZXN0YW1wU3RyaW5nKCcyMDE5LTA5LTEwIDAwOjAwOjAwJylcbiAqIC8vPT4gJzIwMTktMDktMTBUMDA6MDA6MDAnXG4gKi9cbmV4cG9ydCBjb25zdCB0b1RpbWVzdGFtcFN0cmluZyA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKCcgJywgJ1QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBodHRwRW5kcG9pbnRVUkwgPSAoc29ja2V0VXJsKSA9PiB7XG4gICAgY29uc3Qgd3NVcmwgPSBuZXcgVVJMKHNvY2tldFVybCk7XG4gICAgd3NVcmwucHJvdG9jb2wgPSB3c1VybC5wcm90b2NvbC5yZXBsYWNlKC9ed3MvaSwgJ2h0dHAnKTtcbiAgICB3c1VybC5wYXRobmFtZSA9IHdzVXJsLnBhdGhuYW1lXG4gICAgICAgIC5yZXBsYWNlKC9cXC8rJC8sICcnKSAvLyByZW1vdmUgYWxsIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoL1xcL3NvY2tldFxcL3dlYnNvY2tldCQvaSwgJycpIC8vIHJlbW92ZSB0aGUgc29ja2V0L3dlYnNvY2tldCBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9cXC9zb2NrZXQkL2ksICcnKSAvLyByZW1vdmUgdGhlIHNvY2tldCBwYXRoXG4gICAgICAgIC5yZXBsYWNlKC9cXC93ZWJzb2NrZXQkL2ksICcnKTsgLy8gcmVtb3ZlIHRoZSB3ZWJzb2NrZXQgcGF0aFxuICAgIGlmICh3c1VybC5wYXRobmFtZSA9PT0gJycgfHwgd3NVcmwucGF0aG5hbWUgPT09ICcvJykge1xuICAgICAgICB3c1VybC5wYXRobmFtZSA9ICcvYXBpL2Jyb2FkY2FzdCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3c1VybC5wYXRobmFtZSA9IHdzVXJsLnBhdGhuYW1lICsgJy9hcGkvYnJvYWRjYXN0JztcbiAgICB9XG4gICAgcmV0dXJuIHdzVXJsLmhyZWY7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJQb3N0Z3Jlc1R5cGVzIiwiY29udmVydENoYW5nZURhdGEiLCJjb2x1bW5zIiwicmVjb3JkIiwib3B0aW9ucyIsIl9hIiwic2tpcFR5cGVzIiwiT2JqZWN0Iiwia2V5cyIsInJlZHVjZSIsImFjYyIsInJlY19rZXkiLCJjb252ZXJ0Q29sdW1uIiwiY29sdW1uTmFtZSIsImNvbHVtbiIsImZpbmQiLCJ4IiwibmFtZSIsImNvbFR5cGUiLCJ0eXBlIiwidmFsdWUiLCJpbmNsdWRlcyIsImNvbnZlcnRDZWxsIiwibm9vcCIsImNoYXJBdCIsImRhdGFUeXBlIiwic2xpY2UiLCJsZW5ndGgiLCJ0b0FycmF5IiwiYm9vbCIsInRvQm9vbGVhbiIsImZsb2F0NCIsImZsb2F0OCIsImludDIiLCJpbnQ0IiwiaW50OCIsIm51bWVyaWMiLCJvaWQiLCJ0b051bWJlciIsImpzb24iLCJqc29uYiIsInRvSnNvbiIsInRpbWVzdGFtcCIsInRvVGltZXN0YW1wU3RyaW5nIiwiYWJzdGltZSIsImRhdGUiLCJkYXRlcmFuZ2UiLCJpbnQ0cmFuZ2UiLCJpbnQ4cmFuZ2UiLCJtb25leSIsInJlbHRpbWUiLCJ0ZXh0IiwidGltZSIsInRpbWVzdGFtcHR6IiwidGltZXR6IiwidHNyYW5nZSIsInRzdHpyYW5nZSIsInBhcnNlZFZhbHVlIiwicGFyc2VGbG9hdCIsIk51bWJlciIsImlzTmFOIiwiSlNPTiIsInBhcnNlIiwibGFzdElkeCIsImNsb3NlQnJhY2UiLCJvcGVuQnJhY2UiLCJhcnIiLCJ2YWxUcmltIiwiXyIsInNwbGl0IiwibWFwIiwidmFsIiwicmVwbGFjZSIsImh0dHBFbmRwb2ludFVSTCIsInNvY2tldFVybCIsIndzVXJsIiwiVVJMIiwicHJvdG9jb2wiLCJwYXRobmFtZSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.90.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2RUFBNkU7QUFDN0UsZ0VBQWdFO0FBQ2hFLHVFQUF1RTtBQUN2RSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUMxRCxNQUFNQSxVQUFVLFNBQVMsQ0FDaEMsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzPzFmZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi45MC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketFactory: () => (/* binding */ WebSocketFactory),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Utilities for creating WebSocket instances across runtimes.\n */ class WebSocketFactory {\n    /**\n     * Static-only utility  prevent instantiation.\n     */ constructor(){}\n    static detectEnvironment() {\n        var _a;\n        if (typeof WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: globalThis.WebSocket\n            };\n        }\n        if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: global.WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocketPair !== \"undefined\" && typeof globalThis.WebSocket === \"undefined\") {\n            return {\n                type: \"cloudflare\",\n                error: \"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.\",\n                workaround: \"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.\"\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.EdgeRuntime || typeof navigator !== \"undefined\" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes(\"Vercel-Edge\"))) {\n            return {\n                type: \"unsupported\",\n                error: \"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.\",\n                workaround: \"Use serverless functions or a different deployment target for WebSocket functionality.\"\n            };\n        }\n        // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n        const _process = globalThis[\"process\"];\n        if (_process) {\n            const processVersions = _process[\"versions\"];\n            if (processVersions && processVersions[\"node\"]) {\n                // Remove 'v' prefix if present and parse the major version\n                const versionString = processVersions[\"node\"];\n                const nodeVersion = parseInt(versionString.replace(/^v/, \"\").split(\".\")[0]);\n                // Node.js 22+ should have native WebSocket\n                if (nodeVersion >= 22) {\n                    // Check if native WebSocket is available (should be in Node.js 22+)\n                    if (typeof globalThis.WebSocket !== \"undefined\") {\n                        return {\n                            type: \"native\",\n                            constructor: globalThis.WebSocket\n                        };\n                    }\n                    // If not available, user needs to provide it\n                    return {\n                        type: \"unsupported\",\n                        error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,\n                        workaround: \"Provide a WebSocket implementation via the transport option.\"\n                    };\n                }\n                // Node.js < 22 doesn't have native WebSocket\n                return {\n                    type: \"unsupported\",\n                    error: `Node.js ${nodeVersion} detected without native WebSocket support.`,\n                    workaround: 'For Node.js < 22, install \"ws\" package and provide it via the transport option:\\n' + 'import ws from \"ws\"\\n' + \"new RealtimeClient(url, { transport: ws })\"\n                };\n            }\n        }\n        return {\n            type: \"unsupported\",\n            error: \"Unknown JavaScript runtime without WebSocket support.\",\n            workaround: \"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.\"\n        };\n    }\n    /**\n     * Returns the best available WebSocket constructor for the current runtime.\n     *\n     * @example\n     * ```ts\n     * const WS = WebSocketFactory.getWebSocketConstructor()\n     * const socket = new WS('wss://realtime.supabase.co/socket')\n     * ```\n     */ static getWebSocketConstructor() {\n        const env = this.detectEnvironment();\n        if (env.constructor) {\n            return env.constructor;\n        }\n        let errorMessage = env.error || \"WebSocket not supported in this environment.\";\n        if (env.workaround) {\n            errorMessage += `\\n\\nSuggested solution: ${env.workaround}`;\n        }\n        throw new Error(errorMessage);\n    }\n    /**\n     * Creates a WebSocket using the detected constructor.\n     *\n     * @example\n     * ```ts\n     * const socket = WebSocketFactory.createWebSocket('wss://realtime.supabase.co/socket')\n     * ```\n     */ static createWebSocket(url, protocols) {\n        const WS = this.getWebSocketConstructor();\n        return new WS(url, protocols);\n    }\n    /**\n     * Detects whether the runtime can establish WebSocket connections.\n     *\n     * @example\n     * ```ts\n     * if (!WebSocketFactory.isWebSocketSupported()) {\n     *   console.warn('Falling back to long polling')\n     * }\n     * ```\n     */ static isWebSocketSupported() {\n        try {\n            const env = this.detectEnvironment();\n            return env.type === \"native\" || env.type === \"ws\";\n        } catch (_a) {\n            return false;\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebSocketFactory); //# sourceMappingURL=websocket-factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWJzb2NrZXQtZmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOztDQUVDLEdBQ00sTUFBTUE7SUFDVDs7S0FFQyxHQUNEQyxhQUFjLENBQUU7SUFDaEIsT0FBT0Msb0JBQW9CO1FBQ3ZCLElBQUlDO1FBQ0osSUFBSSxPQUFPQyxjQUFjLGFBQWE7WUFDbEMsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUosYUFBYUc7WUFBVTtRQUNwRDtRQUNBLElBQUksT0FBT0UsZUFBZSxlQUFlLE9BQU9BLFdBQVdGLFNBQVMsS0FBSyxhQUFhO1lBQ2xGLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVKLGFBQWFLLFdBQVdGLFNBQVM7WUFBQztRQUMvRDtRQUNBLElBQUksT0FBT0csV0FBVyxlQUFlLE9BQU9BLE9BQU9ILFNBQVMsS0FBSyxhQUFhO1lBQzFFLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVKLGFBQWFNLE9BQU9ILFNBQVM7WUFBQztRQUMzRDtRQUNBLElBQUksT0FBT0UsZUFBZSxlQUN0QixPQUFPQSxXQUFXRSxhQUFhLEtBQUssZUFDcEMsT0FBT0YsV0FBV0YsU0FBUyxLQUFLLGFBQWE7WUFDN0MsT0FBTztnQkFDSEMsTUFBTTtnQkFDTkksT0FBTztnQkFDUEMsWUFBWTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxPQUFRSixlQUFlLGVBQWVBLFdBQVdLLFdBQVcsSUFDM0QsT0FBT0MsY0FBYyxlQUFnQixFQUFDVCxLQUFLUyxVQUFVQyxTQUFTLE1BQU0sUUFBUVYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVyxRQUFRLENBQUMsY0FBYSxHQUFLO1lBQ3BJLE9BQU87Z0JBQ0hULE1BQU07Z0JBQ05JLE9BQU87Z0JBQ1BDLFlBQVk7WUFDaEI7UUFDSjtRQUNBLHFGQUFxRjtRQUNyRixNQUFNSyxXQUFXVCxVQUFVLENBQUMsVUFBVTtRQUN0QyxJQUFJUyxVQUFVO1lBQ1YsTUFBTUMsa0JBQWtCRCxRQUFRLENBQUMsV0FBVztZQUM1QyxJQUFJQyxtQkFBbUJBLGVBQWUsQ0FBQyxPQUFPLEVBQUU7Z0JBQzVDLDJEQUEyRDtnQkFDM0QsTUFBTUMsZ0JBQWdCRCxlQUFlLENBQUMsT0FBTztnQkFDN0MsTUFBTUUsY0FBY0MsU0FBU0YsY0FBY0csT0FBTyxDQUFDLE1BQU0sSUFBSUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMxRSwyQ0FBMkM7Z0JBQzNDLElBQUlILGVBQWUsSUFBSTtvQkFDbkIsb0VBQW9FO29CQUNwRSxJQUFJLE9BQU9aLFdBQVdGLFNBQVMsS0FBSyxhQUFhO3dCQUM3QyxPQUFPOzRCQUFFQyxNQUFNOzRCQUFVSixhQUFhSyxXQUFXRixTQUFTO3dCQUFDO29CQUMvRDtvQkFDQSw2Q0FBNkM7b0JBQzdDLE9BQU87d0JBQ0hDLE1BQU07d0JBQ05JLE9BQU8sQ0FBQyxRQUFRLEVBQUVTLFlBQVkseUNBQXlDLENBQUM7d0JBQ3hFUixZQUFZO29CQUNoQjtnQkFDSjtnQkFDQSw2Q0FBNkM7Z0JBQzdDLE9BQU87b0JBQ0hMLE1BQU07b0JBQ05JLE9BQU8sQ0FBQyxRQUFRLEVBQUVTLFlBQVksMkNBQTJDLENBQUM7b0JBQzFFUixZQUFZLHNGQUNSLDBCQUNBO2dCQUNSO1lBQ0o7UUFDSjtRQUNBLE9BQU87WUFDSEwsTUFBTTtZQUNOSSxPQUFPO1lBQ1BDLFlBQVk7UUFDaEI7SUFDSjtJQUNBOzs7Ozs7OztLQVFDLEdBQ0QsT0FBT1ksMEJBQTBCO1FBQzdCLE1BQU1DLE1BQU0sSUFBSSxDQUFDckIsaUJBQWlCO1FBQ2xDLElBQUlxQixJQUFJdEIsV0FBVyxFQUFFO1lBQ2pCLE9BQU9zQixJQUFJdEIsV0FBVztRQUMxQjtRQUNBLElBQUl1QixlQUFlRCxJQUFJZCxLQUFLLElBQUk7UUFDaEMsSUFBSWMsSUFBSWIsVUFBVSxFQUFFO1lBQ2hCYyxnQkFBZ0IsQ0FBQyx3QkFBd0IsRUFBRUQsSUFBSWIsVUFBVSxDQUFDLENBQUM7UUFDL0Q7UUFDQSxNQUFNLElBQUllLE1BQU1EO0lBQ3BCO0lBQ0E7Ozs7Ozs7S0FPQyxHQUNELE9BQU9FLGdCQUFnQkMsR0FBRyxFQUFFQyxTQUFTLEVBQUU7UUFDbkMsTUFBTUMsS0FBSyxJQUFJLENBQUNQLHVCQUF1QjtRQUN2QyxPQUFPLElBQUlPLEdBQUdGLEtBQUtDO0lBQ3ZCO0lBQ0E7Ozs7Ozs7OztLQVNDLEdBQ0QsT0FBT0UsdUJBQXVCO1FBQzFCLElBQUk7WUFDQSxNQUFNUCxNQUFNLElBQUksQ0FBQ3JCLGlCQUFpQjtZQUNsQyxPQUFPcUIsSUFBSWxCLElBQUksS0FBSyxZQUFZa0IsSUFBSWxCLElBQUksS0FBSztRQUNqRCxFQUNBLE9BQU9GLElBQUk7WUFDUCxPQUFPO1FBQ1g7SUFDSjtBQUNKO0FBQ0EsaUVBQWVILGdCQUFnQkEsRUFBQyxDQUNoQyw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3dlYnNvY2tldC1mYWN0b3J5LmpzP2E1YWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGNyZWF0aW5nIFdlYlNvY2tldCBpbnN0YW5jZXMgYWNyb3NzIHJ1bnRpbWVzLlxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgLyoqXG4gICAgICogU3RhdGljLW9ubHkgdXRpbGl0eSDigJMgcHJldmVudCBpbnN0YW50aWF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgc3RhdGljIGRldGVjdEVudmlyb25tZW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBXZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5XZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IGdsb2JhbC5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXRQYWlyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xvdWRmbGFyZScsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdDbG91ZGZsYXJlIFdvcmtlcnMgZGV0ZWN0ZWQuIFdlYlNvY2tldCBjbGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIENsb3VkZmxhcmUgV29ya2Vycy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2UgQ2xvdWRmbGFyZSBXb3JrZXJzIFdlYlNvY2tldCBBUEkgZm9yIHNlcnZlci1zaWRlIFdlYlNvY2tldCBoYW5kbGluZywgb3IgZGVwbG95IHRvIGEgZGlmZmVyZW50IHJ1bnRpbWUuJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5FZGdlUnVudGltZSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdWZXJjZWwtRWRnZScpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0VkZ2UgcnVudGltZSBkZXRlY3RlZCAoVmVyY2VsIEVkZ2UvTmV0bGlmeSBFZGdlKS4gV2ViU29ja2V0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiBlZGdlIGZ1bmN0aW9ucy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2Ugc2VydmVybGVzcyBmdW5jdGlvbnMgb3IgYSBkaWZmZXJlbnQgZGVwbG95bWVudCB0YXJnZXQgZm9yIFdlYlNvY2tldCBmdW5jdGlvbmFsaXR5LicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSBkeW5hbWljIHByb3BlcnR5IGFjY2VzcyB0byBhdm9pZCBOZXh0LmpzIEVkZ2UgUnVudGltZSBzdGF0aWMgYW5hbHlzaXMgd2FybmluZ3NcbiAgICAgICAgY29uc3QgX3Byb2Nlc3MgPSBnbG9iYWxUaGlzWydwcm9jZXNzJ107XG4gICAgICAgIGlmIChfcHJvY2Vzcykge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc1ZlcnNpb25zID0gX3Byb2Nlc3NbJ3ZlcnNpb25zJ107XG4gICAgICAgICAgICBpZiAocHJvY2Vzc1ZlcnNpb25zICYmIHByb2Nlc3NWZXJzaW9uc1snbm9kZSddKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlICd2JyBwcmVmaXggaWYgcHJlc2VudCBhbmQgcGFyc2UgdGhlIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gcHJvY2Vzc1ZlcnNpb25zWydub2RlJ107XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uU3RyaW5nLnJlcGxhY2UoL152LywgJycpLnNwbGl0KCcuJylbMF0pO1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMjIrIHNob3VsZCBoYXZlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgICAgICAgICAgICBpZiAobm9kZVZlcnNpb24gPj0gMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmF0aXZlIFdlYlNvY2tldCBpcyBhdmFpbGFibGUgKHNob3VsZCBiZSBpbiBOb2RlLmpzIDIyKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYXZhaWxhYmxlLCB1c2VyIG5lZWRzIHRvIHByb3ZpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYE5vZGUuanMgJHtub2RlVmVyc2lvbn0gZGV0ZWN0ZWQgYnV0IG5hdGl2ZSBXZWJTb2NrZXQgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnUHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiB2aWEgdGhlIHRyYW5zcG9ydCBvcHRpb24uJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyA8IDIyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBOb2RlLmpzICR7bm9kZVZlcnNpb259IGRldGVjdGVkIHdpdGhvdXQgbmF0aXZlIFdlYlNvY2tldCBzdXBwb3J0LmAsXG4gICAgICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdGb3IgTm9kZS5qcyA8IDIyLCBpbnN0YWxsIFwid3NcIiBwYWNrYWdlIGFuZCBwcm92aWRlIGl0IHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7IHRyYW5zcG9ydDogd3MgfSknLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICBlcnJvcjogJ1Vua25vd24gSmF2YVNjcmlwdCBydW50aW1lIHdpdGhvdXQgV2ViU29ja2V0IHN1cHBvcnQuJyxcbiAgICAgICAgICAgIHdvcmthcm91bmQ6IFwiRW5zdXJlIHlvdSdyZSBydW5uaW5nIGluIGEgc3VwcG9ydGVkIGVudmlyb25tZW50IChicm93c2VyLCBOb2RlLmpzLCBEZW5vKSBvciBwcm92aWRlIGEgY3VzdG9tIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbi5cIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVzdCBhdmFpbGFibGUgV2ViU29ja2V0IGNvbnN0cnVjdG9yIGZvciB0aGUgY3VycmVudCBydW50aW1lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IFdTID0gV2ViU29ja2V0RmFjdG9yeS5nZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpXG4gICAgICogY29uc3Qgc29ja2V0ID0gbmV3IFdTKCd3c3M6Ly9yZWFsdGltZS5zdXBhYmFzZS5jby9zb2NrZXQnKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3QgZW52ID0gdGhpcy5kZXRlY3RFbnZpcm9ubWVudCgpO1xuICAgICAgICBpZiAoZW52LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZW52LmNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBlbnYuZXJyb3IgfHwgJ1dlYlNvY2tldCBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuJztcbiAgICAgICAgaWYgKGVudi53b3JrYXJvdW5kKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcblxcblN1Z2dlc3RlZCBzb2x1dGlvbjogJHtlbnYud29ya2Fyb3VuZH1gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgV2ViU29ja2V0IHVzaW5nIHRoZSBkZXRlY3RlZCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBXZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZVdlYlNvY2tldCgnd3NzOi8vcmVhbHRpbWUuc3VwYWJhc2UuY28vc29ja2V0JylcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlV2ViU29ja2V0KHVybCwgcHJvdG9jb2xzKSB7XG4gICAgICAgIGNvbnN0IFdTID0gdGhpcy5nZXRXZWJTb2NrZXRDb25zdHJ1Y3RvcigpO1xuICAgICAgICByZXR1cm4gbmV3IFdTKHVybCwgcHJvdG9jb2xzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBydW50aW1lIGNhbiBlc3RhYmxpc2ggV2ViU29ja2V0IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGlmICghV2ViU29ja2V0RmFjdG9yeS5pc1dlYlNvY2tldFN1cHBvcnRlZCgpKSB7XG4gICAgICogICBjb25zb2xlLndhcm4oJ0ZhbGxpbmcgYmFjayB0byBsb25nIHBvbGxpbmcnKVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNXZWJTb2NrZXRTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZW52LnR5cGUgPT09ICduYXRpdmUnIHx8IGVudi50eXBlID09PSAnd3MnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6WyJXZWJTb2NrZXRGYWN0b3J5IiwiY29uc3RydWN0b3IiLCJkZXRlY3RFbnZpcm9ubWVudCIsIl9hIiwiV2ViU29ja2V0IiwidHlwZSIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJXZWJTb2NrZXRQYWlyIiwiZXJyb3IiLCJ3b3JrYXJvdW5kIiwiRWRnZVJ1bnRpbWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsIl9wcm9jZXNzIiwicHJvY2Vzc1ZlcnNpb25zIiwidmVyc2lvblN0cmluZyIsIm5vZGVWZXJzaW9uIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwic3BsaXQiLCJnZXRXZWJTb2NrZXRDb25zdHJ1Y3RvciIsImVudiIsImVycm9yTWVzc2FnZSIsIkVycm9yIiwiY3JlYXRlV2ViU29ja2V0IiwidXJsIiwicHJvdG9jb2xzIiwiV1MiLCJpc1dlYlNvY2tldFN1cHBvcnRlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (/* binding */ src_default)\n/* harmony export */ });\n//#region src/PostgrestError.ts\n/**\n* Error format\n*\n* {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n*/ var PostgrestError = class extends Error {\n    /**\n\t* @example\n\t* ```ts\n\t* import PostgrestError from '@supabase/postgrest-js'\n\t*\n\t* throw new PostgrestError({\n\t*   message: 'Row level security prevented the request',\n\t*   details: 'RLS denied the insert',\n\t*   hint: 'Check your policies',\n\t*   code: 'PGRST301',\n\t* })\n\t* ```\n\t*/ constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n};\n//#endregion\n//#region src/PostgrestBuilder.ts\nvar PostgrestBuilder = class {\n    /**\n\t* Creates a builder configured for a specific PostgREST request.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const builder = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: new Headers({ apikey: 'public-anon-key' }) }\n\t* )\n\t* ```\n\t*/ constructor(builder){\n        var _builder$shouldThrowO, _builder$isMaybeSingl;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_builder$shouldThrowO = builder.shouldThrowOnError) !== null && _builder$shouldThrowO !== void 0 ? _builder$shouldThrowO : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_builder$isMaybeSingl = builder.isMaybeSingle) !== null && _builder$isMaybeSingl !== void 0 ? _builder$isMaybeSingl : false;\n        if (builder.fetch) this.fetch = builder.fetch;\n        else this.fetch = fetch;\n    }\n    /**\n\t* If there's an error with the query, throwOnError will reject the promise by\n\t* throwing the error instead of returning it as part of a successful response.\n\t*\n\t* {@link https://github.com/supabase/supabase-js/issues/92}\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Set an HTTP header for the request.\n\t*/ setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        var _this = this;\n        if (this.schema === void 0) {} else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) this.headers.set(\"Accept-Profile\", this.schema);\n        else this.headers.set(\"Content-Profile\", this.schema);\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") this.headers.set(\"Content-Type\", \"application/json\");\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res$1)=>{\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res$1.status;\n            let statusText = res$1.statusText;\n            if (res$1.ok) {\n                var _this$headers$get2, _res$headers$get;\n                if (_this.method !== \"HEAD\") {\n                    var _this$headers$get;\n                    const body = await res$1.text();\n                    if (body === \"\") {} else if (_this.headers.get(\"Accept\") === \"text/csv\") data = body;\n                    else if (_this.headers.get(\"Accept\") && ((_this$headers$get = _this.headers.get(\"Accept\")) === null || _this$headers$get === void 0 ? void 0 : _this$headers$get.includes(\"application/vnd.pgrst.plan+text\"))) data = body;\n                    else data = JSON.parse(body);\n                }\n                const countHeader = (_this$headers$get2 = _this.headers.get(\"Prefer\")) === null || _this$headers$get2 === void 0 ? void 0 : _this$headers$get2.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_res$headers$get = res$1.headers.get(\"content-range\")) === null || _res$headers$get === void 0 ? void 0 : _res$headers$get.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) count = parseInt(contentRange[1]);\n                if (_this.isMaybeSingle && _this.method === \"GET\" && Array.isArray(data)) if (data.length > 1) {\n                    error = {\n                        code: \"PGRST116\",\n                        details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                        hint: null,\n                        message: \"JSON object requested, multiple (or no) rows returned\"\n                    };\n                    data = null;\n                    count = null;\n                    status = 406;\n                    statusText = \"Not Acceptable\";\n                } else if (data.length === 1) data = data[0];\n                else data = null;\n            } else {\n                var _error$details;\n                const body = await res$1.text();\n                try {\n                    error = JSON.parse(body);\n                    if (Array.isArray(error) && res$1.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_unused) {\n                    if (res$1.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else error = {\n                        message: body\n                    };\n                }\n                if (error && _this.isMaybeSingle && (error === null || error === void 0 || (_error$details = error.details) === null || _error$details === void 0 ? void 0 : _error$details.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && _this.shouldThrowOnError) throw new PostgrestError(error);\n            }\n            return {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n        });\n        if (!this.shouldThrowOnError) res = res.catch((fetchError)=>{\n            var _fetchError$name2;\n            let errorDetails = \"\";\n            const cause = fetchError === null || fetchError === void 0 ? void 0 : fetchError.cause;\n            if (cause) {\n                var _cause$message, _cause$code, _fetchError$name, _cause$name;\n                const causeMessage = (_cause$message = cause === null || cause === void 0 ? void 0 : cause.message) !== null && _cause$message !== void 0 ? _cause$message : \"\";\n                const causeCode = (_cause$code = cause === null || cause === void 0 ? void 0 : cause.code) !== null && _cause$code !== void 0 ? _cause$code : \"\";\n                errorDetails = `${(_fetchError$name = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name !== void 0 ? _fetchError$name : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`;\n                errorDetails += `\\n\\nCaused by: ${(_cause$name = cause === null || cause === void 0 ? void 0 : cause.name) !== null && _cause$name !== void 0 ? _cause$name : \"Error\"}: ${causeMessage}`;\n                if (causeCode) errorDetails += ` (${causeCode})`;\n                if (cause === null || cause === void 0 ? void 0 : cause.stack) errorDetails += `\\n${cause.stack}`;\n            } else {\n                var _fetchError$stack;\n                errorDetails = (_fetchError$stack = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _fetchError$stack !== void 0 ? _fetchError$stack : \"\";\n            }\n            return {\n                error: {\n                    message: `${(_fetchError$name2 = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _fetchError$name2 !== void 0 ? _fetchError$name2 : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                    details: errorDetails,\n                    hint: \"\",\n                    code: \"\"\n                },\n                data: null,\n                count: null,\n                status: 0,\n                statusText: \"\"\n            };\n        });\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n\t* Override the type of the returned `data` field in the response.\n\t*\n\t* @typeParam NewResult - The new type to cast the response data to\n\t* @typeParam Options - Optional type configuration (defaults to { merge: true })\n\t* @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n\t* @example\n\t* ```typescript\n\t* // Merge with existing types (default behavior)\n\t* const query = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ custom_field: string }>()\n\t*\n\t* // Replace existing types completely\n\t* const replaceQuery = supabase\n\t*   .from('users')\n\t*   .select()\n\t*   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n\t* ```\n\t* @returns A PostgrestBuilder instance with the new type\n\t*/ overrideTypes() {\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestTransformBuilder.ts\nvar PostgrestTransformBuilder = class extends PostgrestBuilder {\n    /**\n\t* Perform a SELECT on the query result.\n\t*\n\t* By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n\t* return modified rows. By calling this method, modified rows are returned in\n\t* `data`.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas\n\t*/ select(columns) {\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        this.headers.append(\"Prefer\", \"return=representation\");\n        return this;\n    }\n    /**\n\t* Order the query result by `column`.\n\t*\n\t* You can call this method multiple times to order by multiple columns.\n\t*\n\t* You can order referenced tables, but it only affects the ordering of the\n\t* parent table if you use `!inner` in the query.\n\t*\n\t* @param column - The column to order by\n\t* @param options - Named parameters\n\t* @param options.ascending - If `true`, the result will be in ascending order\n\t* @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n\t* `null`s appear last.\n\t* @param options.referencedTable - Set this to order a referenced table by\n\t* its columns\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === void 0 ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by `count`.\n\t*\n\t* @param count - The maximum number of rows to return\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n\t* Limit the query result by starting at an offset `from` and ending at the offset `to`.\n\t* Only records within this range are returned.\n\t* This respects the query order and if there is no order clause the range could behave unexpectedly.\n\t* The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n\t* and fourth rows of the query.\n\t*\n\t* @param from - The starting index from which to limit the result\n\t* @param to - The last index to which to limit the result\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to limit rows of referenced\n\t* tables instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `options.referencedTable`\n\t* instead\n\t*/ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n\t* Set the AbortSignal for the fetch request.\n\t*\n\t* @param signal - The AbortSignal to use for the fetch request\n\t*/ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be one row (e.g. using `.limit(1)`), otherwise this\n\t* returns an error.\n\t*/ single() {\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as a single object instead of an array of objects.\n\t*\n\t* Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n\t* this returns an error.\n\t*/ maybeSingle() {\n        if (this.method === \"GET\") this.headers.set(\"Accept\", \"application/json\");\n        else this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n\t* Return `data` as a string in CSV format.\n\t*/ csv() {\n        this.headers.set(\"Accept\", \"text/csv\");\n        return this;\n    }\n    /**\n\t* Return `data` as an object in [GeoJSON](https://geojson.org) format.\n\t*/ geojson() {\n        this.headers.set(\"Accept\", \"application/geo+json\");\n        return this;\n    }\n    /**\n\t* Return `data` as the EXPLAIN plan for the query.\n\t*\n\t* You need to enable the\n\t* [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n\t* setting before using this method.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.analyze - If `true`, the query will be executed and the\n\t* actual run time will be returned\n\t*\n\t* @param options.verbose - If `true`, the query identifier will be returned\n\t* and `data` will include the output columns of the query\n\t*\n\t* @param options.settings - If `true`, include information on configuration\n\t* parameters that affect query planning\n\t*\n\t* @param options.buffers - If `true`, include information on buffer usage\n\t*\n\t* @param options.wal - If `true`, include information on WAL record generation\n\t*\n\t* @param options.format - The format of the output, can be `\"text\"` (default)\n\t* or `\"json\"`\n\t*/ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n        var _this$headers$get;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        const forMediatype = (_this$headers$get = this.headers.get(\"Accept\")) !== null && _this$headers$get !== void 0 ? _this$headers$get : \"application/json\";\n        this.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === \"json\") return this;\n        else return this;\n    }\n    /**\n\t* Rollback the query.\n\t*\n\t* `data` will still be returned, but the query is not committed.\n\t*/ rollback() {\n        this.headers.append(\"Prefer\", \"tx=rollback\");\n        return this;\n    }\n    /**\n\t* Override the type of the returned `data`.\n\t*\n\t* @typeParam NewResult - The new result type to override with\n\t* @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n\t*/ returns() {\n        return this;\n    }\n    /**\n\t* Set the maximum number of rows that can be affected by the query.\n\t* Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n\t*\n\t* @param value - The maximum number of rows that can be affected\n\t*/ maxAffected(value) {\n        this.headers.append(\"Prefer\", \"handling=strict\");\n        this.headers.append(\"Prefer\", `max-affected=${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestFilterBuilder.ts\nconst PostgrestReservedCharsRegexp = /* @__PURE__ */ new RegExp(\"[,()]\");\nvar PostgrestFilterBuilder = class extends PostgrestTransformBuilder {\n    /**\n\t* Match only rows where `column` is equal to `value`.\n\t*\n\t* To check if the value of `column` is NULL, you should use `.is()` instead.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is not equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is greater than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is less than or equal to `value`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-sensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches `pattern` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The pattern to match with\n\t*/ ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches all of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches any of `patterns` case-insensitively.\n\t*\n\t* @param column - The column to filter on\n\t* @param patterns - The patterns to match with\n\t*/ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-sensitively (using the `~` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexMatch(column, pattern) {\n        this.url.searchParams.append(column, `match.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` matches the PostgreSQL regex `pattern`\n\t* case-insensitively (using the `~*` operator).\n\t*\n\t* @param column - The column to filter on\n\t* @param pattern - The PostgreSQL regular expression pattern to match with\n\t*/ regexIMatch(column, pattern) {\n        this.url.searchParams.append(column, `imatch.${pattern}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS `value`.\n\t*\n\t* For non-boolean columns, this is only relevant for checking if the value of\n\t* `column` is NULL by setting `value` to `null`.\n\t*\n\t* For boolean columns, you can also set `value` to `true` or `false` and it\n\t* will behave the same way as `.eq()`.\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` IS DISTINCT FROM `value`.\n\t*\n\t* Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n\t* are considered equal (not distinct), and comparing `NULL` with any non-NULL\n\t* value returns true (distinct).\n\t*\n\t* @param column - The column to filter on\n\t* @param value - The value to filter with\n\t*/ isDistinct(column, value) {\n        this.url.searchParams.append(column, `isdistinct.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Match only rows where `column` is NOT included in the `values` array.\n\t*\n\t* @param column - The column to filter on\n\t* @param values - The values array to filter with\n\t*/ notIn(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `not.in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* `column` contains every element appearing in `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ contains(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cs.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for jsonb, array, and range columns. Match only rows where\n\t* every element appearing in `column` is contained by `value`.\n\t*\n\t* @param column - The jsonb, array, or range column to filter on\n\t* @param value - The jsonb, array, or range value to filter with\n\t*/ containedBy(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `cd.${value}`);\n        else if (Array.isArray(value)) this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n        else this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is greater than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or greater than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is less than any element in `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where every element in\n\t* `column` is either contained in `range` or less than any element in\n\t* `range`.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for range columns. Match only rows where `column` is\n\t* mutually exclusive to `range` and there can be no element between the two\n\t* ranges.\n\t*\n\t* @param column - The range column to filter on\n\t* @param range - The range to filter with\n\t*/ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n\t* Only relevant for array and range columns. Match only rows where\n\t* `column` and `value` have an element in common.\n\t*\n\t* @param column - The array or range column to filter on\n\t* @param value - The array or range value to filter with\n\t*/ overlaps(column, value) {\n        if (typeof value === \"string\") this.url.searchParams.append(column, `ov.${value}`);\n        else this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n        return this;\n    }\n    /**\n\t* Only relevant for text and tsvector columns. Match only rows where\n\t* `column` matches the query string in `query`.\n\t*\n\t* @param column - The text or tsvector column to filter on\n\t* @param query - The query text to match with\n\t* @param options - Named parameters\n\t* @param options.config - The text search configuration to use\n\t* @param options.type - Change how the `query` text is interpreted\n\t*/ textSearch(column, query, { config, type } = {}) {\n        let typePart = \"\";\n        if (type === \"plain\") typePart = \"pl\";\n        else if (type === \"phrase\") typePart = \"ph\";\n        else if (type === \"websearch\") typePart = \"w\";\n        const configPart = config === void 0 ? \"\" : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n\t* Match only rows where each column in `query` keys is equal to its\n\t* associated value. Shorthand for multiple `.eq()`s.\n\t*\n\t* @param query - The object to filter with, with column names as keys mapped\n\t* to their filter values\n\t*/ match(query) {\n        Object.entries(query).forEach(([column, value])=>{\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n\t* Match only rows which doesn't satisfy the filter.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to be negated to filter with, following\n\t* PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy at least one of the filters.\n\t*\n\t* Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure it's properly sanitized.\n\t*\n\t* It's currently not possible to do an `.or()` filter across multiple tables.\n\t*\n\t* @param filters - The filters to use, following PostgREST syntax\n\t* @param options - Named parameters\n\t* @param options.referencedTable - Set this to filter on referenced tables\n\t* instead of the parent table\n\t* @param options.foreignTable - Deprecated, use `referencedTable` instead\n\t*/ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : \"or\";\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n\t* Match only rows which satisfy the filter. This is an escape hatch - you\n\t* should use the specific filter methods wherever possible.\n\t*\n\t* Unlike most filters, `opearator` and `value` are used as-is and need to\n\t* follow [PostgREST\n\t* syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n\t* to make sure they are properly sanitized.\n\t*\n\t* @param column - The column to filter on\n\t* @param operator - The operator to filter with, following PostgREST syntax\n\t* @param value - The value to filter with, following PostgREST syntax\n\t*/ filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n};\n//#endregion\n//#region src/PostgrestQueryBuilder.ts\nvar PostgrestQueryBuilder = class {\n    /**\n\t* Creates a query builder scoped to a Postgres table or view.\n\t*\n\t* @example\n\t* ```ts\n\t* import PostgrestQueryBuilder from '@supabase/postgrest-js'\n\t*\n\t* const query = new PostgrestQueryBuilder(\n\t*   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n\t*   { headers: { apikey: 'public-anon-key' } }\n\t* )\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1 }){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch$1;\n    }\n    /**\n\t* Perform a SELECT query on the table or view.\n\t*\n\t* @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t*\n\t* @param options.count - Count algorithm to use to count rows in the table or view.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? \"HEAD\" : \"GET\";\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) return \"\";\n            if (c === '\"') quoted = !quoted;\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        if (count) this.headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Perform an INSERT into the table or view.\n\t*\n\t* By default, inserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to insert. Pass an object to insert a single row\n\t* or an array to insert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count inserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. Only applies for bulk\n\t* inserts.\n\t*/ insert(values, { count, defaultToNull = true } = {}) {\n        var _this$fetch;\n        const method = \"POST\";\n        if (count) this.headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) this.headers.append(\"Prefer\", `missing=default`);\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n        });\n    }\n    /**\n\t* Perform an UPSERT on the table or view. Depending on the column(s) passed\n\t* to `onConflict`, `.upsert()` allows you to perform the equivalent of\n\t* `.insert()` if a row with the corresponding `onConflict` columns doesn't\n\t* exist, or if it does exist, perform an alternative action depending on\n\t* `ignoreDuplicates`.\n\t*\n\t* By default, upserted rows are not returned. To return it, chain the call\n\t* with `.select()`.\n\t*\n\t* @param values - The values to upsert with. Pass an object to upsert a\n\t* single row or an array to upsert multiple rows.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n\t* duplicate rows are determined. Two rows are duplicates if all the\n\t* `onConflict` columns are equal.\n\t*\n\t* @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n\t* `false`, duplicate rows are merged with existing rows.\n\t*\n\t* @param options.count - Count algorithm to use to count upserted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @param options.defaultToNull - Make missing fields default to `null`.\n\t* Otherwise, use the default value for the column. This only applies when\n\t* inserting new rows, not when merging with existing rows under\n\t* `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n\t*\n\t* @example Upsert a single row using a unique key\n\t* ```ts\n\t* // Upserting a single row, overwriting based on the 'username' unique column\n\t* const { data, error } = await supabase\n\t*   .from('users')\n\t*   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     { id: 4, message: 'bar', username: 'supabot' }\n\t* //   ],\n\t* //   error: null\n\t* // }\n\t* ```\n\t*\n\t* @example Upsert with conflict resolution and exact row counting\n\t* ```ts\n\t* // Upserting and returning exact count\n\t* const { data, error, count } = await supabase\n\t*   .from('users')\n\t*   .upsert(\n\t*     {\n\t*       id: 3,\n\t*       message: 'foo',\n\t*       username: 'supabot'\n\t*     },\n\t*     {\n\t*       onConflict: 'username',\n\t*       count: 'exact'\n\t*     }\n\t*   )\n\t*\n\t* // Example response:\n\t* // {\n\t* //   data: [\n\t* //     {\n\t* //       id: 42,\n\t* //       handle: \"saoirse\",\n\t* //       display_name: \"Saoirse\"\n\t* //     }\n\t* //   ],\n\t* //   count: 1,\n\t* //   error: null\n\t* // }\n\t* ```\n\t*/ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n        var _this$fetch2;\n        const method = \"POST\";\n        this.headers.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n        if (onConflict !== void 0) this.url.searchParams.set(\"on_conflict\", onConflict);\n        if (count) this.headers.append(\"Prefer\", `count=${count}`);\n        if (!defaultToNull) this.headers.append(\"Prefer\", \"missing=default\");\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch2 = this.fetch) !== null && _this$fetch2 !== void 0 ? _this$fetch2 : fetch\n        });\n    }\n    /**\n\t* Perform an UPDATE on the table or view.\n\t*\n\t* By default, updated rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param values - The values to update with\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count updated rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ update(values, { count } = {}) {\n        var _this$fetch3;\n        const method = \"PATCH\";\n        if (count) this.headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_this$fetch3 = this.fetch) !== null && _this$fetch3 !== void 0 ? _this$fetch3 : fetch\n        });\n    }\n    /**\n\t* Perform a DELETE on the table or view.\n\t*\n\t* By default, deleted rows are not returned. To return it, chain the call\n\t* with `.select()` after filters.\n\t*\n\t* @param options - Named parameters\n\t*\n\t* @param options.count - Count algorithm to use to count deleted rows.\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ delete({ count } = {}) {\n        var _this$fetch4;\n        const method = \"DELETE\";\n        if (count) this.headers.append(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: (_this$fetch4 = this.fetch) !== null && _this$fetch4 !== void 0 ? _this$fetch4 : fetch\n        });\n    }\n};\n//#endregion\n//#region src/PostgrestClient.ts\n/**\n* PostgREST client.\n*\n* @typeParam Database - Types for the schema from the [type\n* generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n*\n* @typeParam SchemaName - Postgres schema to switch to. Must be a string\n* literal, the same one passed to the constructor. If the schema is not\n* `\"public\"`, this must be supplied manually.\n*/ var PostgrestClient = class PostgrestClient {\n    /**\n\t* Creates a PostgREST client.\n\t*\n\t* @param url - URL of the PostgREST endpoint\n\t* @param options - Named parameters\n\t* @param options.headers - Custom headers\n\t* @param options.schema - Postgres schema to switch to\n\t* @param options.fetch - Custom fetch\n\t* @example\n\t* ```ts\n\t* import PostgrestClient from '@supabase/postgrest-js'\n\t*\n\t* const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n\t*   headers: { apikey: 'public-anon-key' },\n\t*   schema: 'public',\n\t* })\n\t* ```\n\t*/ constructor(url, { headers = {}, schema, fetch: fetch$1 } = {}){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.fetch = fetch$1;\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        if (!relation || typeof relation !== \"string\" || relation.trim() === \"\") throw new Error(\"Invalid relation name: relation must be a non-empty string.\");\n        return new PostgrestQueryBuilder(new URL(`${this.url}/${relation}`), {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*\n\t* @example\n\t* ```ts\n\t* // For cross-schema functions where type inference fails, use overrideTypes:\n\t* const { data } = await supabase\n\t*   .schema('schema_b')\n\t*   .rpc('function_a', {})\n\t*   .overrideTypes<{ id: string; user_id: string }[]>()\n\t* ```\n\t*/ rpc(fn, args = {}, { head = false, get = false, count } = {}) {\n        var _this$fetch;\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        const _isObject = (v)=>v !== null && typeof v === \"object\" && (!Array.isArray(v) || v.some(_isObject));\n        const _hasObjectArg = head && Object.values(args).some(_isObject);\n        if (_hasObjectArg) {\n            method = \"POST\";\n            body = args;\n        } else if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args).filter(([_, value])=>value !== void 0).map(([name, value])=>[\n                    name,\n                    Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`\n                ]).forEach(([name, value])=>{\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (_hasObjectArg) headers.set(\"Prefer\", count ? `count=${count},return=minimal` : \"return=minimal\");\n        else if (count) headers.set(\"Prefer\", `count=${count}`);\n        return new PostgrestFilterBuilder({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_this$fetch = this.fetch) !== null && _this$fetch !== void 0 ? _this$fetch : fetch\n        });\n    }\n};\n//#endregion\n//#region src/index.ts\nvar src_default = {\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsK0JBQStCO0FBQy9COzs7O0FBSUEsR0FDQSxJQUFJQSxpQkFBaUIsY0FBY0M7SUFDbEM7Ozs7Ozs7Ozs7OztDQVlBLEdBQ0FDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBLFFBQVFDLE9BQU87UUFDckIsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBR0gsUUFBUUcsT0FBTztRQUM5QixJQUFJLENBQUNDLElBQUksR0FBR0osUUFBUUksSUFBSTtRQUN4QixJQUFJLENBQUNDLElBQUksR0FBR0wsUUFBUUssSUFBSTtJQUN6QjtBQUNEO0FBRUEsWUFBWTtBQUNaLGlDQUFpQztBQUNqQyxJQUFJQyxtQkFBbUI7SUFDdEI7Ozs7Ozs7Ozs7OztDQVlBLEdBQ0FQLFlBQVlRLE9BQU8sQ0FBRTtRQUNwQixJQUFJQyx1QkFBdUJDO1FBQzNCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxNQUFNLEdBQUdKLFFBQVFJLE1BQU07UUFDNUIsSUFBSSxDQUFDQyxHQUFHLEdBQUdMLFFBQVFLLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsUUFBUVAsUUFBUU0sT0FBTztRQUMxQyxJQUFJLENBQUNFLE1BQU0sR0FBR1IsUUFBUVEsTUFBTTtRQUM1QixJQUFJLENBQUNDLElBQUksR0FBR1QsUUFBUVMsSUFBSTtRQUN4QixJQUFJLENBQUNOLGtCQUFrQixHQUFHLENBQUNGLHdCQUF3QkQsUUFBUUcsa0JBQWtCLE1BQU0sUUFBUUYsMEJBQTBCLEtBQUssSUFBSUEsd0JBQXdCO1FBQ3RKLElBQUksQ0FBQ1MsTUFBTSxHQUFHVixRQUFRVSxNQUFNO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUNULHdCQUF3QkYsUUFBUVcsYUFB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QUM5RSxJQUFJQSxPQUFPeEIsUUFBUVUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUVjLE1BQU0sQ0FBQztRQUN0RCxPQUFPLElBQUlnRix1QkFBdUI7WUFDakMxRztZQUNBQztZQUNBQztZQUNBRSxRQUFRLElBQUksQ0FBQ3lLLFVBQVU7WUFDdkJ4SztZQUNBRyxPQUFPLENBQUNxSixjQUFjLElBQUksQ0FBQ3JKLEtBQUssTUFBTSxRQUFRcUosZ0JBQWdCLEtBQUssSUFBSUEsY0FBY3JKO1FBQ3RGO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWixzQkFBc0I7QUFDdEIsSUFBSWlMLGNBQWM7SUFDakJiO0lBQ0FwQjtJQUNBOUM7SUFDQTdDO0lBQ0FsRTtJQUNBVDtBQUNEO0FBRUEsWUFBWTtBQUNtSixDQUMvSixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvaW5kZXgubWpzPzdhYzMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RFcnJvci50c1xuLyoqXG4qIEVycm9yIGZvcm1hdFxuKlxuKiB7QGxpbmsgaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbD9oaWdobGlnaHQ9b3B0aW9ucyNlcnJvcnMtYW5kLWh0dHAtc3RhdHVzLWNvZGVzfVxuKi9cbnZhciBQb3N0Z3Jlc3RFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHQvKipcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdEVycm9yIGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5cdCpcblx0KiB0aHJvdyBuZXcgUG9zdGdyZXN0RXJyb3Ioe1xuXHQqICAgbWVzc2FnZTogJ1JvdyBsZXZlbCBzZWN1cml0eSBwcmV2ZW50ZWQgdGhlIHJlcXVlc3QnLFxuXHQqICAgZGV0YWlsczogJ1JMUyBkZW5pZWQgdGhlIGluc2VydCcsXG5cdCogICBoaW50OiAnQ2hlY2sgeW91ciBwb2xpY2llcycsXG5cdCogICBjb2RlOiAnUEdSU1QzMDEnLFxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcblx0XHRzdXBlcihjb250ZXh0Lm1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiUG9zdGdyZXN0RXJyb3JcIjtcblx0XHR0aGlzLmRldGFpbHMgPSBjb250ZXh0LmRldGFpbHM7XG5cdFx0dGhpcy5oaW50ID0gY29udGV4dC5oaW50O1xuXHRcdHRoaXMuY29kZSA9IGNvbnRleHQuY29kZTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdEJ1aWxkZXIudHNcbnZhciBQb3N0Z3Jlc3RCdWlsZGVyID0gY2xhc3Mge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgYnVpbGRlciBjb25maWd1cmVkIGZvciBhIHNwZWNpZmljIFBvc3RnUkVTVCByZXF1ZXN0LlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIGltcG9ydCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgZnJvbSAnQHN1cGFiYXNlL3Bvc3RncmVzdC1qcydcblx0KlxuXHQqIGNvbnN0IGJ1aWxkZXIgPSBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKFxuXHQqICAgbmV3IFVSTCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3Jlc3QvdjEvdXNlcnMnKSxcblx0KiAgIHsgaGVhZGVyczogbmV3IEhlYWRlcnMoeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0pIH1cblx0KiApXG5cdCogYGBgXG5cdCovXG5cdGNvbnN0cnVjdG9yKGJ1aWxkZXIpIHtcblx0XHR2YXIgX2J1aWxkZXIkc2hvdWxkVGhyb3dPLCBfYnVpbGRlciRpc01heWJlU2luZ2w7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLm1ldGhvZCA9IGJ1aWxkZXIubWV0aG9kO1xuXHRcdHRoaXMudXJsID0gYnVpbGRlci51cmw7XG5cdFx0dGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoYnVpbGRlci5oZWFkZXJzKTtcblx0XHR0aGlzLnNjaGVtYSA9IGJ1aWxkZXIuc2NoZW1hO1xuXHRcdHRoaXMuYm9keSA9IGJ1aWxkZXIuYm9keTtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IChfYnVpbGRlciRzaG91bGRUaHJvd08gPSBidWlsZGVyLnNob3VsZFRocm93T25FcnJvcikgIT09IG51bGwgJiYgX2J1aWxkZXIkc2hvdWxkVGhyb3dPICE9PSB2b2lkIDAgPyBfYnVpbGRlciRzaG91bGRUaHJvd08gOiBmYWxzZTtcblx0XHR0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuXHRcdHRoaXMuaXNNYXliZVNpbmdsZSA9IChfYnVpbGRlciRpc01heWJlU2luZ2wgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGUpICE9PSBudWxsICYmIF9idWlsZGVyJGlzTWF5YmVTaW5nbCAhPT0gdm9pZCAwID8gX2J1aWxkZXIkaXNNYXliZVNpbmdsIDogZmFsc2U7XG5cdFx0aWYgKGJ1aWxkZXIuZmV0Y2gpIHRoaXMuZmV0Y2ggPSBidWlsZGVyLmZldGNoO1xuXHRcdGVsc2UgdGhpcy5mZXRjaCA9IGZldGNoO1xuXHR9XG5cdC8qKlxuXHQqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuXHQqIHRocm93aW5nIHRoZSBlcnJvciBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBhcyBwYXJ0IG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cblx0KlxuXHQqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFNldCBhbiBIVFRQIGhlYWRlciBmb3IgdGhlIHJlcXVlc3QuXG5cdCovXG5cdHNldEhlYWRlcihuYW1lLCB2YWx1ZSkge1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0aWYgKHRoaXMuc2NoZW1hID09PSB2b2lkIDApIHt9IGVsc2UgaWYgKFtcIkdFVFwiLCBcIkhFQURcIl0uaW5jbHVkZXModGhpcy5tZXRob2QpKSB0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0LVByb2ZpbGVcIiwgdGhpcy5zY2hlbWEpO1xuXHRcdGVsc2UgdGhpcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtUHJvZmlsZVwiLCB0aGlzLnNjaGVtYSk7XG5cdFx0aWYgKHRoaXMubWV0aG9kICE9PSBcIkdFVFwiICYmIHRoaXMubWV0aG9kICE9PSBcIkhFQURcIikgdGhpcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0Y29uc3QgX2ZldGNoID0gdGhpcy5mZXRjaDtcblx0XHRsZXQgcmVzID0gX2ZldGNoKHRoaXMudXJsLnRvU3RyaW5nKCksIHtcblx0XHRcdG1ldGhvZDogdGhpcy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRib2R5OiBKU09OLnN0cmluZ2lmeSh0aGlzLmJvZHkpLFxuXHRcdFx0c2lnbmFsOiB0aGlzLnNpZ25hbFxuXHRcdH0pLnRoZW4oYXN5bmMgKHJlcyQxKSA9PiB7XG5cdFx0XHRsZXQgZXJyb3IgPSBudWxsO1xuXHRcdFx0bGV0IGRhdGEgPSBudWxsO1xuXHRcdFx0bGV0IGNvdW50ID0gbnVsbDtcblx0XHRcdGxldCBzdGF0dXMgPSByZXMkMS5zdGF0dXM7XG5cdFx0XHRsZXQgc3RhdHVzVGV4dCA9IHJlcyQxLnN0YXR1c1RleHQ7XG5cdFx0XHRpZiAocmVzJDEub2spIHtcblx0XHRcdFx0dmFyIF90aGlzJGhlYWRlcnMkZ2V0MiwgX3JlcyRoZWFkZXJzJGdldDtcblx0XHRcdFx0aWYgKF90aGlzLm1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcblx0XHRcdFx0XHR2YXIgX3RoaXMkaGVhZGVycyRnZXQ7XG5cdFx0XHRcdFx0Y29uc3QgYm9keSA9IGF3YWl0IHJlcyQxLnRleHQoKTtcblx0XHRcdFx0XHRpZiAoYm9keSA9PT0gXCJcIikge30gZWxzZSBpZiAoX3RoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikgPT09IFwidGV4dC9jc3ZcIikgZGF0YSA9IGJvZHk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoX3RoaXMuaGVhZGVycy5nZXQoXCJBY2NlcHRcIikgJiYgKChfdGhpcyRoZWFkZXJzJGdldCA9IF90aGlzLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpKSA9PT0gbnVsbCB8fCBfdGhpcyRoZWFkZXJzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaGVhZGVycyRnZXQuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0XCIpKSkgZGF0YSA9IGJvZHk7XG5cdFx0XHRcdFx0ZWxzZSBkYXRhID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBjb3VudEhlYWRlciA9IChfdGhpcyRoZWFkZXJzJGdldDIgPSBfdGhpcy5oZWFkZXJzLmdldChcIlByZWZlclwiKSkgPT09IG51bGwgfHwgX3RoaXMkaGVhZGVycyRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRoZWFkZXJzJGdldDIubWF0Y2goL2NvdW50PShleGFjdHxwbGFubmVkfGVzdGltYXRlZCkvKTtcblx0XHRcdFx0Y29uc3QgY29udGVudFJhbmdlID0gKF9yZXMkaGVhZGVycyRnZXQgPSByZXMkMS5oZWFkZXJzLmdldChcImNvbnRlbnQtcmFuZ2VcIikpID09PSBudWxsIHx8IF9yZXMkaGVhZGVycyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXMkaGVhZGVycyRnZXQuc3BsaXQoXCIvXCIpO1xuXHRcdFx0XHRpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSBjb3VudCA9IHBhcnNlSW50KGNvbnRlbnRSYW5nZVsxXSk7XG5cdFx0XHRcdGlmIChfdGhpcy5pc01heWJlU2luZ2xlICYmIF90aGlzLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSB7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIlBHUlNUMTE2XCIsXG5cdFx0XHRcdFx0XHRkZXRhaWxzOiBgUmVzdWx0cyBjb250YWluICR7ZGF0YS5sZW5ndGh9IHJvd3MsIGFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvbiByZXF1aXJlcyAxIHJvd2AsXG5cdFx0XHRcdFx0XHRoaW50OiBudWxsLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogXCJKU09OIG9iamVjdCByZXF1ZXN0ZWQsIG11bHRpcGxlIChvciBubykgcm93cyByZXR1cm5lZFwiXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdFx0XHRjb3VudCA9IG51bGw7XG5cdFx0XHRcdFx0c3RhdHVzID0gNDA2O1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk5vdCBBY2NlcHRhYmxlXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPT09IDEpIGRhdGEgPSBkYXRhWzBdO1xuXHRcdFx0XHRlbHNlIGRhdGEgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIF9lcnJvciRkZXRhaWxzO1xuXHRcdFx0XHRjb25zdCBib2R5ID0gYXdhaXQgcmVzJDEudGV4dCgpO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGVycm9yID0gSlNPTi5wYXJzZShib2R5KTtcblx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShlcnJvcikgJiYgcmVzJDEuc3RhdHVzID09PSA0MDQpIHtcblx0XHRcdFx0XHRcdGRhdGEgPSBbXTtcblx0XHRcdFx0XHRcdGVycm9yID0gbnVsbDtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDIwMDtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk9LXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGNhdGNoIChfdW51c2VkKSB7XG5cdFx0XHRcdFx0aWYgKHJlcyQxLnN0YXR1cyA9PT0gNDA0ICYmIGJvZHkgPT09IFwiXCIpIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDIwNDtcblx0XHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIk5vIENvbnRlbnRcIjtcblx0XHRcdFx0XHR9IGVsc2UgZXJyb3IgPSB7IG1lc3NhZ2U6IGJvZHkgfTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoZXJyb3IgJiYgX3RoaXMuaXNNYXliZVNpbmdsZSAmJiAoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCB8fCAoX2Vycm9yJGRldGFpbHMgPSBlcnJvci5kZXRhaWxzKSA9PT0gbnVsbCB8fCBfZXJyb3IkZGV0YWlscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yJGRldGFpbHMuaW5jbHVkZXMoXCIwIHJvd3NcIikpKSB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBudWxsO1xuXHRcdFx0XHRcdHN0YXR1cyA9IDIwMDtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJPS1wiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlcnJvciAmJiBfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IG5ldyBQb3N0Z3Jlc3RFcnJvcihlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRlcnJvcixcblx0XHRcdFx0ZGF0YSxcblx0XHRcdFx0Y291bnQsXG5cdFx0XHRcdHN0YXR1cyxcblx0XHRcdFx0c3RhdHVzVGV4dFxuXHRcdFx0fTtcblx0XHR9KTtcblx0XHRpZiAoIXRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSByZXMgPSByZXMuY2F0Y2goKGZldGNoRXJyb3IpID0+IHtcblx0XHRcdHZhciBfZmV0Y2hFcnJvciRuYW1lMjtcblx0XHRcdGxldCBlcnJvckRldGFpbHMgPSBcIlwiO1xuXHRcdFx0Y29uc3QgY2F1c2UgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IuY2F1c2U7XG5cdFx0XHRpZiAoY2F1c2UpIHtcblx0XHRcdFx0dmFyIF9jYXVzZSRtZXNzYWdlLCBfY2F1c2UkY29kZSwgX2ZldGNoRXJyb3IkbmFtZSwgX2NhdXNlJG5hbWU7XG5cdFx0XHRcdGNvbnN0IGNhdXNlTWVzc2FnZSA9IChfY2F1c2UkbWVzc2FnZSA9IGNhdXNlID09PSBudWxsIHx8IGNhdXNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXVzZS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfY2F1c2UkbWVzc2FnZSAhPT0gdm9pZCAwID8gX2NhdXNlJG1lc3NhZ2UgOiBcIlwiO1xuXHRcdFx0XHRjb25zdCBjYXVzZUNvZGUgPSAoX2NhdXNlJGNvZGUgPSBjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UuY29kZSkgIT09IG51bGwgJiYgX2NhdXNlJGNvZGUgIT09IHZvaWQgMCA/IF9jYXVzZSRjb2RlIDogXCJcIjtcblx0XHRcdFx0ZXJyb3JEZXRhaWxzID0gYCR7KF9mZXRjaEVycm9yJG5hbWUgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubmFtZSkgIT09IG51bGwgJiYgX2ZldGNoRXJyb3IkbmFtZSAhPT0gdm9pZCAwID8gX2ZldGNoRXJyb3IkbmFtZSA6IFwiRmV0Y2hFcnJvclwifTogJHtmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubWVzc2FnZX1gO1xuXHRcdFx0XHRlcnJvckRldGFpbHMgKz0gYFxcblxcbkNhdXNlZCBieTogJHsoX2NhdXNlJG5hbWUgPSBjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UubmFtZSkgIT09IG51bGwgJiYgX2NhdXNlJG5hbWUgIT09IHZvaWQgMCA/IF9jYXVzZSRuYW1lIDogXCJFcnJvclwifTogJHtjYXVzZU1lc3NhZ2V9YDtcblx0XHRcdFx0aWYgKGNhdXNlQ29kZSkgZXJyb3JEZXRhaWxzICs9IGAgKCR7Y2F1c2VDb2RlfSlgO1xuXHRcdFx0XHRpZiAoY2F1c2UgPT09IG51bGwgfHwgY2F1c2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhdXNlLnN0YWNrKSBlcnJvckRldGFpbHMgKz0gYFxcbiR7Y2F1c2Uuc3RhY2t9YDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBfZmV0Y2hFcnJvciRzdGFjaztcblx0XHRcdFx0ZXJyb3JEZXRhaWxzID0gKF9mZXRjaEVycm9yJHN0YWNrID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLnN0YWNrKSAhPT0gbnVsbCAmJiBfZmV0Y2hFcnJvciRzdGFjayAhPT0gdm9pZCAwID8gX2ZldGNoRXJyb3Ikc3RhY2sgOiBcIlwiO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXJyb3I6IHtcblx0XHRcdFx0XHRtZXNzYWdlOiBgJHsoX2ZldGNoRXJyb3IkbmFtZTIgPSBmZXRjaEVycm9yID09PSBudWxsIHx8IGZldGNoRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZldGNoRXJyb3IubmFtZSkgIT09IG51bGwgJiYgX2ZldGNoRXJyb3IkbmFtZTIgIT09IHZvaWQgMCA/IF9mZXRjaEVycm9yJG5hbWUyIDogXCJGZXRjaEVycm9yXCJ9OiAke2ZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5tZXNzYWdlfWAsXG5cdFx0XHRcdFx0ZGV0YWlsczogZXJyb3JEZXRhaWxzLFxuXHRcdFx0XHRcdGhpbnQ6IFwiXCIsXG5cdFx0XHRcdFx0Y29kZTogXCJcIlxuXHRcdFx0XHR9LFxuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRjb3VudDogbnVsbCxcblx0XHRcdFx0c3RhdHVzOiAwLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiBcIlwiXG5cdFx0XHR9O1xuXHRcdH0pO1xuXHRcdHJldHVybiByZXMudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG5cdH1cblx0LyoqXG5cdCogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cblx0KlxuXHQqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG5cdCogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcblx0Ki9cblx0cmV0dXJucygpIHtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAgZmllbGQgaW4gdGhlIHJlc3BvbnNlLlxuXHQqXG5cdCogQHR5cGVQYXJhbSBOZXdSZXN1bHQgLSBUaGUgbmV3IHR5cGUgdG8gY2FzdCB0aGUgcmVzcG9uc2UgZGF0YSB0b1xuXHQqIEB0eXBlUGFyYW0gT3B0aW9ucyAtIE9wdGlvbmFsIHR5cGUgY29uZmlndXJhdGlvbiAoZGVmYXVsdHMgdG8geyBtZXJnZTogdHJ1ZSB9KVxuXHQqIEB0eXBlUGFyYW0gT3B0aW9ucy5tZXJnZSAtIFdoZW4gdHJ1ZSwgbWVyZ2VzIHRoZSBuZXcgdHlwZSB3aXRoIGV4aXN0aW5nIHJldHVybiB0eXBlLiBXaGVuIGZhbHNlLCByZXBsYWNlcyB0aGUgZXhpc3RpbmcgdHlwZXMgZW50aXJlbHkgKGRlZmF1bHRzIHRvIHRydWUpXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogLy8gTWVyZ2Ugd2l0aCBleGlzdGluZyB0eXBlcyAoZGVmYXVsdCBiZWhhdmlvcilcblx0KiBjb25zdCBxdWVyeSA9IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnNlbGVjdCgpXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGN1c3RvbV9maWVsZDogc3RyaW5nIH0+KClcblx0KlxuXHQqIC8vIFJlcGxhY2UgZXhpc3RpbmcgdHlwZXMgY29tcGxldGVseVxuXHQqIGNvbnN0IHJlcGxhY2VRdWVyeSA9IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnNlbGVjdCgpXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGlkOiBudW1iZXI7IG5hbWU6IHN0cmluZyB9LCB7IG1lcmdlOiBmYWxzZSB9PigpXG5cdCogYGBgXG5cdCogQHJldHVybnMgQSBQb3N0Z3Jlc3RCdWlsZGVyIGluc3RhbmNlIHdpdGggdGhlIG5ldyB0eXBlXG5cdCovXG5cdG92ZXJyaWRlVHlwZXMoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLnRzXG52YXIgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgUG9zdGdyZXN0QnVpbGRlciB7XG5cdC8qKlxuXHQqIFBlcmZvcm0gYSBTRUxFQ1Qgb24gdGhlIHF1ZXJ5IHJlc3VsdC5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGAuaW5zZXJ0KClgLCBgLnVwZGF0ZSgpYCwgYC51cHNlcnQoKWAsIGFuZCBgLmRlbGV0ZSgpYCBkbyBub3Rcblx0KiByZXR1cm4gbW9kaWZpZWQgcm93cy4gQnkgY2FsbGluZyB0aGlzIG1ldGhvZCwgbW9kaWZpZWQgcm93cyBhcmUgcmV0dXJuZWQgaW5cblx0KiBgZGF0YWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1ucyAtIFRoZSBjb2x1bW5zIHRvIHJldHJpZXZlLCBzZXBhcmF0ZWQgYnkgY29tbWFzXG5cdCovXG5cdHNlbGVjdChjb2x1bW5zKSB7XG5cdFx0bGV0IHF1b3RlZCA9IGZhbHNlO1xuXHRcdGNvbnN0IGNsZWFuZWRDb2x1bW5zID0gKGNvbHVtbnMgIT09IG51bGwgJiYgY29sdW1ucyAhPT0gdm9pZCAwID8gY29sdW1ucyA6IFwiKlwiKS5zcGxpdChcIlwiKS5tYXAoKGMpID0+IHtcblx0XHRcdGlmICgvXFxzLy50ZXN0KGMpICYmICFxdW90ZWQpIHJldHVybiBcIlwiO1xuXHRcdFx0aWYgKGMgPT09IFwiXFxcIlwiKSBxdW90ZWQgPSAhcXVvdGVkO1xuXHRcdFx0cmV0dXJuIGM7XG5cdFx0fSkuam9pbihcIlwiKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KFwic2VsZWN0XCIsIGNsZWFuZWRDb2x1bW5zKTtcblx0XHR0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIFwicmV0dXJuPXJlcHJlc2VudGF0aW9uXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9yZGVyIHRoZSBxdWVyeSByZXN1bHQgYnkgYGNvbHVtbmAuXG5cdCpcblx0KiBZb3UgY2FuIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgdG8gb3JkZXIgYnkgbXVsdGlwbGUgY29sdW1ucy5cblx0KlxuXHQqIFlvdSBjYW4gb3JkZXIgcmVmZXJlbmNlZCB0YWJsZXMsIGJ1dCBpdCBvbmx5IGFmZmVjdHMgdGhlIG9yZGVyaW5nIG9mIHRoZVxuXHQqIHBhcmVudCB0YWJsZSBpZiB5b3UgdXNlIGAhaW5uZXJgIGluIHRoZSBxdWVyeS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIG9yZGVyIGJ5XG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMuYXNjZW5kaW5nIC0gSWYgYHRydWVgLCB0aGUgcmVzdWx0IHdpbGwgYmUgaW4gYXNjZW5kaW5nIG9yZGVyXG5cdCogQHBhcmFtIG9wdGlvbnMubnVsbHNGaXJzdCAtIElmIGB0cnVlYCwgYG51bGxgcyBhcHBlYXIgZmlyc3QuIElmIGBmYWxzZWAsXG5cdCogYG51bGxgcyBhcHBlYXIgbGFzdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBvcmRlciBhIHJlZmVyZW5jZWQgdGFibGUgYnlcblx0KiBpdHMgY29sdW1uc1xuXHQqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG5cdCogaW5zdGVhZFxuXHQqL1xuXHRvcmRlcihjb2x1bW4sIHsgYXNjZW5kaW5nID0gdHJ1ZSwgbnVsbHNGaXJzdCwgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmRlcmAgOiBcIm9yZGVyXCI7XG5cdFx0Y29uc3QgZXhpc3RpbmdPcmRlciA9IHRoaXMudXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7ZXhpc3RpbmdPcmRlciA/IGAke2V4aXN0aW5nT3JkZXJ9LGAgOiBcIlwifSR7Y29sdW1ufS4ke2FzY2VuZGluZyA/IFwiYXNjXCIgOiBcImRlc2NcIn0ke251bGxzRmlyc3QgPT09IHZvaWQgMCA/IFwiXCIgOiBudWxsc0ZpcnN0ID8gXCIubnVsbHNmaXJzdFwiIDogXCIubnVsbHNsYXN0XCJ9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY291bnRgLlxuXHQqXG5cdCogQHBhcmFtIGNvdW50IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG5cdCogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuXHQqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG5cdCogaW5zdGVhZFxuXHQqL1xuXHRsaW1pdChjb3VudCwgeyBmb3JlaWduVGFibGUsIHJlZmVyZW5jZWRUYWJsZSA9IGZvcmVpZ25UYWJsZSB9ID0ge30pIHtcblx0XHRjb25zdCBrZXkgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSBcInVuZGVmaW5lZFwiID8gXCJsaW1pdFwiIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGA7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIExpbWl0IHRoZSBxdWVyeSByZXN1bHQgYnkgc3RhcnRpbmcgYXQgYW4gb2Zmc2V0IGBmcm9tYCBhbmQgZW5kaW5nIGF0IHRoZSBvZmZzZXQgYHRvYC5cblx0KiBPbmx5IHJlY29yZHMgd2l0aGluIHRoaXMgcmFuZ2UgYXJlIHJldHVybmVkLlxuXHQqIFRoaXMgcmVzcGVjdHMgdGhlIHF1ZXJ5IG9yZGVyIGFuZCBpZiB0aGVyZSBpcyBubyBvcmRlciBjbGF1c2UgdGhlIHJhbmdlIGNvdWxkIGJlaGF2ZSB1bmV4cGVjdGVkbHkuXG5cdCogVGhlIGBmcm9tYCBhbmQgYHRvYCB2YWx1ZXMgYXJlIDAtYmFzZWQgYW5kIGluY2x1c2l2ZTogYHJhbmdlKDEsIDMpYCB3aWxsIGluY2x1ZGUgdGhlIHNlY29uZCwgdGhpcmRcblx0KiBhbmQgZm91cnRoIHJvd3Mgb2YgdGhlIHF1ZXJ5LlxuXHQqXG5cdCogQHBhcmFtIGZyb20gLSBUaGUgc3RhcnRpbmcgaW5kZXggZnJvbSB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG5cdCogQHBhcmFtIHRvIC0gVGhlIGxhc3QgaW5kZXggdG8gd2hpY2ggdG8gbGltaXQgdGhlIHJlc3VsdFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIGxpbWl0IHJvd3Mgb2YgcmVmZXJlbmNlZFxuXHQqIHRhYmxlcyBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlYFxuXHQqIGluc3RlYWRcblx0Ki9cblx0cmFuZ2UoZnJvbSwgdG8sIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUgfSA9IHt9KSB7XG5cdFx0Y29uc3Qga2V5T2Zmc2V0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwib2Zmc2V0XCIgOiBgJHtyZWZlcmVuY2VkVGFibGV9Lm9mZnNldGA7XG5cdFx0Y29uc3Qga2V5TGltaXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSBcInVuZGVmaW5lZFwiID8gXCJsaW1pdFwiIDogYCR7cmVmZXJlbmNlZFRhYmxlfS5saW1pdGA7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YCk7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBTZXQgdGhlIEFib3J0U2lnbmFsIGZvciB0aGUgZmV0Y2ggcmVxdWVzdC5cblx0KlxuXHQqIEBwYXJhbSBzaWduYWwgLSBUaGUgQWJvcnRTaWduYWwgdG8gdXNlIGZvciB0aGUgZmV0Y2ggcmVxdWVzdFxuXHQqL1xuXHRhYm9ydFNpZ25hbChzaWduYWwpIHtcblx0XHR0aGlzLnNpZ25hbCA9IHNpZ25hbDtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG5cdCpcblx0KiBRdWVyeSByZXN1bHQgbXVzdCBiZSBvbmUgcm93IChlLmcuIHVzaW5nIGAubGltaXQoMSlgKSwgb3RoZXJ3aXNlIHRoaXNcblx0KiByZXR1cm5zIGFuIGVycm9yLlxuXHQqL1xuXHRzaW5nbGUoKSB7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL3ZuZC5wZ3JzdC5vYmplY3QranNvblwiKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBSZXR1cm4gYGRhdGFgIGFzIGEgc2luZ2xlIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG5cdCpcblx0KiBRdWVyeSByZXN1bHQgbXVzdCBiZSB6ZXJvIG9yIG9uZSByb3cgKGUuZy4gdXNpbmcgYC5saW1pdCgxKWApLCBvdGhlcndpc2Vcblx0KiB0aGlzIHJldHVybnMgYW4gZXJyb3IuXG5cdCovXG5cdG1heWJlU2luZ2xlKCkge1xuXHRcdGlmICh0aGlzLm1ldGhvZCA9PT0gXCJHRVRcIikgdGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0ZWxzZSB0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIFwiYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uXCIpO1xuXHRcdHRoaXMuaXNNYXliZVNpbmdsZSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUmV0dXJuIGBkYXRhYCBhcyBhIHN0cmluZyBpbiBDU1YgZm9ybWF0LlxuXHQqL1xuXHRjc3YoKSB7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcInRleHQvY3N2XCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgYW4gb2JqZWN0IGluIFtHZW9KU09OXShodHRwczovL2dlb2pzb24ub3JnKSBmb3JtYXQuXG5cdCovXG5cdGdlb2pzb24oKSB7XG5cdFx0dGhpcy5oZWFkZXJzLnNldChcIkFjY2VwdFwiLCBcImFwcGxpY2F0aW9uL2dlbytqc29uXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuXHQqXG5cdCogWW91IG5lZWQgdG8gZW5hYmxlIHRoZVxuXHQqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuXHQqIHNldHRpbmcgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5hbmFseXplIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgd2lsbCBiZSBleGVjdXRlZCBhbmQgdGhlXG5cdCogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2UgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSBpZGVudGlmaWVyIHdpbGwgYmUgcmV0dXJuZWRcblx0KiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5zZXR0aW5ncyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBjb25maWd1cmF0aW9uXG5cdCogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuYnVmZmVycyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBidWZmZXIgdXNhZ2Vcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLndhbCAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBXQUwgcmVjb3JkIGdlbmVyYXRpb25cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG5cdCogb3IgYFwianNvblwiYFxuXHQqL1xuXHRleHBsYWluKHsgYW5hbHl6ZSA9IGZhbHNlLCB2ZXJib3NlID0gZmFsc2UsIHNldHRpbmdzID0gZmFsc2UsIGJ1ZmZlcnMgPSBmYWxzZSwgd2FsID0gZmFsc2UsIGZvcm1hdCA9IFwidGV4dFwiIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRoZWFkZXJzJGdldDtcblx0XHRjb25zdCBvcHRpb25zID0gW1xuXHRcdFx0YW5hbHl6ZSA/IFwiYW5hbHl6ZVwiIDogbnVsbCxcblx0XHRcdHZlcmJvc2UgPyBcInZlcmJvc2VcIiA6IG51bGwsXG5cdFx0XHRzZXR0aW5ncyA/IFwic2V0dGluZ3NcIiA6IG51bGwsXG5cdFx0XHRidWZmZXJzID8gXCJidWZmZXJzXCIgOiBudWxsLFxuXHRcdFx0d2FsID8gXCJ3YWxcIiA6IG51bGxcblx0XHRdLmZpbHRlcihCb29sZWFuKS5qb2luKFwifFwiKTtcblx0XHRjb25zdCBmb3JNZWRpYXR5cGUgPSAoX3RoaXMkaGVhZGVycyRnZXQgPSB0aGlzLmhlYWRlcnMuZ2V0KFwiQWNjZXB0XCIpKSAhPT0gbnVsbCAmJiBfdGhpcyRoZWFkZXJzJGdldCAhPT0gdm9pZCAwID8gX3RoaXMkaGVhZGVycyRnZXQgOiBcImFwcGxpY2F0aW9uL2pzb25cIjtcblx0XHR0aGlzLmhlYWRlcnMuc2V0KFwiQWNjZXB0XCIsIGBhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbiske2Zvcm1hdH07IGZvcj1cIiR7Zm9yTWVkaWF0eXBlfVwiOyBvcHRpb25zPSR7b3B0aW9uc307YCk7XG5cdFx0aWYgKGZvcm1hdCA9PT0gXCJqc29uXCIpIHJldHVybiB0aGlzO1xuXHRcdGVsc2UgcmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogUm9sbGJhY2sgdGhlIHF1ZXJ5LlxuXHQqXG5cdCogYGRhdGFgIHdpbGwgc3RpbGwgYmUgcmV0dXJuZWQsIGJ1dCB0aGUgcXVlcnkgaXMgbm90IGNvbW1pdHRlZC5cblx0Ki9cblx0cm9sbGJhY2soKSB7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcInR4PXJvbGxiYWNrXCIpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG5cdCpcblx0KiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuXHQqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZVR5cGVzPHlvdXJUeXBlLCB7IG1lcmdlOiBmYWxzZSB9PigpIG1ldGhvZCBhdCB0aGUgZW5kIG9mIHlvdXIgY2FsbCBjaGFpbiBpbnN0ZWFkXG5cdCovXG5cdHJldHVybnMoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRoYXQgY2FuIGJlIGFmZmVjdGVkIGJ5IHRoZSBxdWVyeS5cblx0KiBPbmx5IGF2YWlsYWJsZSBpbiBQb3N0Z1JFU1QgdjEzKyBhbmQgb25seSB3b3JrcyB3aXRoIFBBVENIIGFuZCBERUxFVEUgbWV0aG9kcy5cblx0KlxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzIHRoYXQgY2FuIGJlIGFmZmVjdGVkXG5cdCovXG5cdG1heEFmZmVjdGVkKHZhbHVlKSB7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBcImhhbmRsaW5nPXN0cmljdFwiKTtcblx0XHR0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBtYXgtYWZmZWN0ZWQ9JHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXIudHNcbmNvbnN0IFBvc3RncmVzdFJlc2VydmVkQ2hhcnNSZWdleHAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChcIlssKCldXCIpO1xudmFyIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIge1xuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIFRvIGNoZWNrIGlmIHRoZSB2YWx1ZSBvZiBgY29sdW1uYCBpcyBOVUxMLCB5b3Ugc2hvdWxkIHVzZSBgLmlzKClgIGluc3RlYWQuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0ZXEoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZXEuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgaXMgbm90IGVxdWFsIHRvIGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0bmVxKGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5lcS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRndChjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndC4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYHZhbHVlYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRndGUoY29sdW1uLCB2YWx1ZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgZ3RlLiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGx0KGNvbHVtbiwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGx0LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGx0ZShjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdGUuJHt2YWx1ZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZS4ke3BhdHRlcm59YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYWxsIG9mIGBwYXR0ZXJuc2AgY2FzZS1zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGxpa2VBbGxPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlKGFsbCkueyR7cGF0dGVybnMuam9pbihcIixcIil9fWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFueSBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBgcGF0dGVybmAgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGlsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UuJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG5cdCovXG5cdGlsaWtlQWxsT2YoY29sdW1uLCBwYXR0ZXJucykge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKFwiLFwiKX19YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcblx0Ki9cblx0aWxpa2VBbnlPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyB0aGUgUG9zdGdyZVNRTCByZWdleCBgcGF0dGVybmBcblx0KiBjYXNlLXNlbnNpdGl2ZWx5ICh1c2luZyB0aGUgYH5gIG9wZXJhdG9yKS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIFBvc3RncmVTUUwgcmVndWxhciBleHByZXNzaW9uIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuXHQqL1xuXHRyZWdleE1hdGNoKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbWF0Y2guJHtwYXR0ZXJufWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIHRoZSBQb3N0Z3JlU1FMIHJlZ2V4IGBwYXR0ZXJuYFxuXHQqIGNhc2UtaW5zZW5zaXRpdmVseSAodXNpbmcgdGhlIGB+KmAgb3BlcmF0b3IpLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHBhdHRlcm4gLSBUaGUgUG9zdGdyZVNRTCByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiB0byBtYXRjaCB3aXRoXG5cdCovXG5cdHJlZ2V4SU1hdGNoKGNvbHVtbiwgcGF0dGVybikge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW1hdGNoLiR7cGF0dGVybn1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgYHZhbHVlYC5cblx0KlxuXHQqIEZvciBub24tYm9vbGVhbiBjb2x1bW5zLCB0aGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIGNoZWNraW5nIGlmIHRoZSB2YWx1ZSBvZlxuXHQqIGBjb2x1bW5gIGlzIE5VTEwgYnkgc2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYC5cblx0KlxuXHQqIEZvciBib29sZWFuIGNvbHVtbnMsIHlvdSBjYW4gYWxzbyBzZXQgYHZhbHVlYCB0byBgdHJ1ZWAgb3IgYGZhbHNlYCBhbmQgaXRcblx0KiB3aWxsIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgYC5lcSgpYC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRpcyhjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpcy4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBJUyBESVNUSU5DVCBGUk9NIGB2YWx1ZWAuXG5cdCpcblx0KiBVbmxpa2UgYC5uZXEoKWAsIHRoaXMgdHJlYXRzIGBOVUxMYCBhcyBhIGNvbXBhcmFibGUgdmFsdWUuIFR3byBgTlVMTGAgdmFsdWVzXG5cdCogYXJlIGNvbnNpZGVyZWQgZXF1YWwgKG5vdCBkaXN0aW5jdCksIGFuZCBjb21wYXJpbmcgYE5VTExgIHdpdGggYW55IG5vbi1OVUxMXG5cdCogdmFsdWUgcmV0dXJucyB0cnVlIChkaXN0aW5jdCkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0aXNEaXN0aW5jdChjb2x1bW4sIHZhbHVlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpc2Rpc3RpbmN0LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGluY2x1ZGVkIGluIHRoZSBgdmFsdWVzYCBhcnJheS5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIGFycmF5IHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGluKGNvbHVtbiwgdmFsdWVzKSB7XG5cdFx0Y29uc3QgY2xlYW5lZFZhbHVlcyA9IEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpKS5tYXAoKHMpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcyA9PT0gXCJzdHJpbmdcIiAmJiBQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwLnRlc3QocykpIHJldHVybiBgXCIke3N9XCJgO1xuXHRcdFx0ZWxzZSByZXR1cm4gYCR7c31gO1xuXHRcdH0pLmpvaW4oXCIsXCIpO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaW4uKCR7Y2xlYW5lZFZhbHVlc30pYCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIE5PVCBpbmNsdWRlZCBpbiB0aGUgYHZhbHVlc2AgYXJyYXkuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyBhcnJheSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRub3RJbihjb2x1bW4sIHZhbHVlcykge1xuXHRcdGNvbnN0IGNsZWFuZWRWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQodmFsdWVzKSkubWFwKChzKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHMgPT09IFwic3RyaW5nXCIgJiYgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cC50ZXN0KHMpKSByZXR1cm4gYFwiJHtzfVwiYDtcblx0XHRcdGVsc2UgcmV0dXJuIGAke3N9YDtcblx0XHR9KS5qb2luKFwiLFwiKTtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC5pbi4oJHtjbGVhbmVkVmFsdWVzfSlgKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBgY29sdW1uYCBjb250YWlucyBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgdmFsdWVgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gdmFsdWUgLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRjb250YWlucyhjb2x1bW4sIHZhbHVlKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjcy4ke3ZhbHVlfWApO1xuXHRcdGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLnske3ZhbHVlLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRlbHNlIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY3MuJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG5cdCogZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYGNvbHVtbmAgaXMgY29udGFpbmVkIGJ5IGB2YWx1ZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSB2YWx1ZSAtIFRoZSBqc29uYiwgYXJyYXksIG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdGNvbnRhaW5lZEJ5KGNvbHVtbiwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNkLiR7dmFsdWV9YCk7XG5cdFx0ZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgY2QueyR7dmFsdWUuam9pbihcIixcIil9fWApO1xuXHRcdGVsc2UgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBhbnkgZWxlbWVudCBpbiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlR3QoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgc3IuJHtyYW5nZX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuXHQqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cblx0KiBgcmFuZ2VgLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdHJhbmdlR3RlKGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54bC4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG5cdCogYGNvbHVtbmAgaXMgbGVzcyB0aGFuIGFueSBlbGVtZW50IGluIGByYW5nZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VMdChjb2x1bW4sIHJhbmdlKSB7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBzbC4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBldmVyeSBlbGVtZW50IGluXG5cdCogYGNvbHVtbmAgaXMgZWl0aGVyIGNvbnRhaW5lZCBpbiBgcmFuZ2VgIG9yIGxlc3MgdGhhbiBhbnkgZWxlbWVudCBpblxuXHQqIGByYW5nZWAuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gcmFuZ2UgLSBUaGUgcmFuZ2UgdG8gZmlsdGVyIHdpdGhcblx0Ki9cblx0cmFuZ2VMdGUoY29sdW1uLCByYW5nZSkge1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbnhyLiR7cmFuZ2V9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzXG5cdCogbXV0dWFsbHkgZXhjbHVzaXZlIHRvIGByYW5nZWAgYW5kIHRoZXJlIGNhbiBiZSBubyBlbGVtZW50IGJldHdlZW4gdGhlIHR3b1xuXHQqIHJhbmdlcy5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuXHQqL1xuXHRyYW5nZUFkamFjZW50KGNvbHVtbiwgcmFuZ2UpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGFkai4ke3JhbmdlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE9ubHkgcmVsZXZhbnQgZm9yIGFycmF5IGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBgY29sdW1uYCBhbmQgYHZhbHVlYCBoYXZlIGFuIGVsZW1lbnQgaW4gY29tbW9uLlxuXHQqXG5cdCogQHBhcmFtIGNvbHVtbiAtIFRoZSBhcnJheSBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIGFycmF5IG9yIHJhbmdlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG5cdCovXG5cdG92ZXJsYXBzKGNvbHVtbiwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92LiR7dmFsdWV9YCk7XG5cdFx0ZWxzZSB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG92Lnske3ZhbHVlLmpvaW4oXCIsXCIpfX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBPbmx5IHJlbGV2YW50IGZvciB0ZXh0IGFuZCB0c3ZlY3RvciBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcblx0KiBgY29sdW1uYCBtYXRjaGVzIHRoZSBxdWVyeSBzdHJpbmcgaW4gYHF1ZXJ5YC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgdGV4dCBvciB0c3ZlY3RvciBjb2x1bW4gdG8gZmlsdGVyIG9uXG5cdCogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRleHQgdG8gbWF0Y2ggd2l0aFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmNvbmZpZyAtIFRoZSB0ZXh0IHNlYXJjaCBjb25maWd1cmF0aW9uIHRvIHVzZVxuXHQqIEBwYXJhbSBvcHRpb25zLnR5cGUgLSBDaGFuZ2UgaG93IHRoZSBgcXVlcnlgIHRleHQgaXMgaW50ZXJwcmV0ZWRcblx0Ki9cblx0dGV4dFNlYXJjaChjb2x1bW4sIHF1ZXJ5LCB7IGNvbmZpZywgdHlwZSB9ID0ge30pIHtcblx0XHRsZXQgdHlwZVBhcnQgPSBcIlwiO1xuXHRcdGlmICh0eXBlID09PSBcInBsYWluXCIpIHR5cGVQYXJ0ID0gXCJwbFwiO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwicGhyYXNlXCIpIHR5cGVQYXJ0ID0gXCJwaFwiO1xuXHRcdGVsc2UgaWYgKHR5cGUgPT09IFwid2Vic2VhcmNoXCIpIHR5cGVQYXJ0ID0gXCJ3XCI7XG5cdFx0Y29uc3QgY29uZmlnUGFydCA9IGNvbmZpZyA9PT0gdm9pZCAwID8gXCJcIiA6IGAoJHtjb25maWd9KWA7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGAke3R5cGVQYXJ0fWZ0cyR7Y29uZmlnUGFydH0uJHtxdWVyeX1gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKipcblx0KiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZWFjaCBjb2x1bW4gaW4gYHF1ZXJ5YCBrZXlzIGlzIGVxdWFsIHRvIGl0c1xuXHQqIGFzc29jaWF0ZWQgdmFsdWUuIFNob3J0aGFuZCBmb3IgbXVsdGlwbGUgYC5lcSgpYHMuXG5cdCpcblx0KiBAcGFyYW0gcXVlcnkgLSBUaGUgb2JqZWN0IHRvIGZpbHRlciB3aXRoLCB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIG1hcHBlZFxuXHQqIHRvIHRoZWlyIGZpbHRlciB2YWx1ZXNcblx0Ki9cblx0bWF0Y2gocXVlcnkpIHtcblx0XHRPYmplY3QuZW50cmllcyhxdWVyeSkuZm9yRWFjaCgoW2NvbHVtbiwgdmFsdWVdKSA9PiB7XG5cdFx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGVxLiR7dmFsdWV9YCk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoaWNoIGRvZXNuJ3Qgc2F0aXNmeSB0aGUgZmlsdGVyLlxuXHQqXG5cdCogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cblx0KiBmb2xsb3cgW1Bvc3RnUkVTVFxuXHQqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG5cdCogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuXHQqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBiZSBuZWdhdGVkIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmdcblx0KiBQb3N0Z1JFU1Qgc3ludGF4XG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqL1xuXHRub3QoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG5vdC4ke29wZXJhdG9yfS4ke3ZhbHVlfWApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsdGVycy5cblx0KlxuXHQqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBmaWx0ZXJzYCBpcyB1c2VkIGFzLWlzIGFuZCBuZWVkcyB0byBmb2xsb3cgW1Bvc3RnUkVTVFxuXHQqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG5cdCogdG8gbWFrZSBzdXJlIGl0J3MgcHJvcGVybHkgc2FuaXRpemVkLlxuXHQqXG5cdCogSXQncyBjdXJyZW50bHkgbm90IHBvc3NpYmxlIHRvIGRvIGFuIGAub3IoKWAgZmlsdGVyIGFjcm9zcyBtdWx0aXBsZSB0YWJsZXMuXG5cdCpcblx0KiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIHVzZSwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBmaWx0ZXIgb24gcmVmZXJlbmNlZCB0YWJsZXNcblx0KiBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcblx0KiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYHJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZFxuXHQqL1xuXHRvcihmaWx0ZXJzLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlIH0gPSB7fSkge1xuXHRcdGNvbnN0IGtleSA9IHJlZmVyZW5jZWRUYWJsZSA/IGAke3JlZmVyZW5jZWRUYWJsZX0ub3JgIDogXCJvclwiO1xuXHRcdHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgKCR7ZmlsdGVyc30pYCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogTWF0Y2ggb25seSByb3dzIHdoaWNoIHNhdGlzZnkgdGhlIGZpbHRlci4gVGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggLSB5b3Vcblx0KiBzaG91bGQgdXNlIHRoZSBzcGVjaWZpYyBmaWx0ZXIgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZS5cblx0KlxuXHQqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG5cdCogZm9sbG93IFtQb3N0Z1JFU1Rcblx0KiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuXHQqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG5cdCpcblx0KiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cblx0KiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG5cdCogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoLCBmb2xsb3dpbmcgUG9zdGdSRVNUIHN5bnRheFxuXHQqL1xuXHRmaWx0ZXIoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7b3BlcmF0b3J9LiR7dmFsdWV9YCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIudHNcbnZhciBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgPSBjbGFzcyB7XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBxdWVyeSBidWlsZGVyIHNjb3BlZCB0byBhIFBvc3RncmVzIHRhYmxlIG9yIHZpZXcuXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IFBvc3RncmVzdFF1ZXJ5QnVpbGRlciBmcm9tICdAc3VwYWJhc2UvcG9zdGdyZXN0LWpzJ1xuXHQqXG5cdCogY29uc3QgcXVlcnkgPSBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKFxuXHQqICAgbmV3IFVSTCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvL3Jlc3QvdjEvdXNlcnMnKSxcblx0KiAgIHsgaGVhZGVyczogeyBhcGlrZXk6ICdwdWJsaWMtYW5vbi1rZXknIH0gfVxuXHQqIClcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCB7IGhlYWRlcnMgPSB7fSwgc2NoZW1hLCBmZXRjaDogZmV0Y2gkMSB9KSB7XG5cdFx0dGhpcy51cmwgPSB1cmw7XG5cdFx0dGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaGVhZGVycyk7XG5cdFx0dGhpcy5zY2hlbWEgPSBzY2hlbWE7XG5cdFx0dGhpcy5mZXRjaCA9IGZldGNoJDE7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIFNFTEVDVCBxdWVyeSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXMuIENvbHVtbnMgY2FuIGJlIHJlbmFtZWQgd2hlbiByZXR1cm5lZCB3aXRoIGBjdXN0b21OYW1lOmNvbHVtbk5hbWVgXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyBpbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcblx0KiBob29kLlxuXHQqXG5cdCogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcblx0KiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuXHQqXG5cdCogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuXHQqIG51bWJlcnMuXG5cdCovXG5cdHNlbGVjdChjb2x1bW5zLCBvcHRpb25zKSB7XG5cdFx0Y29uc3QgeyBoZWFkID0gZmFsc2UsIGNvdW50IH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcblx0XHRjb25zdCBtZXRob2QgPSBoZWFkID8gXCJIRUFEXCIgOiBcIkdFVFwiO1xuXHRcdGxldCBxdW90ZWQgPSBmYWxzZTtcblx0XHRjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiBcIipcIikuc3BsaXQoXCJcIikubWFwKChjKSA9PiB7XG5cdFx0XHRpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSByZXR1cm4gXCJcIjtcblx0XHRcdGlmIChjID09PSBcIlxcXCJcIikgcXVvdGVkID0gIXF1b3RlZDtcblx0XHRcdHJldHVybiBjO1xuXHRcdH0pLmpvaW4oXCJcIik7XG5cdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcInNlbGVjdFwiLCBjbGVhbmVkQ29sdW1ucyk7XG5cdFx0aWYgKGNvdW50KSB0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBjb3VudD0ke2NvdW50fWApO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmw6IHRoaXMudXJsLFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhbiBJTlNFUlQgaW50byB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGluc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBpbnNlcnQuIFBhc3MgYW4gb2JqZWN0IHRvIGluc2VydCBhIHNpbmdsZSByb3dcblx0KiBvciBhbiBhcnJheSB0byBpbnNlcnQgbXVsdGlwbGUgcm93cy5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG5cdCogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuXHQqIGluc2VydHMuXG5cdCovXG5cdGluc2VydCh2YWx1ZXMsIHsgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDtcblx0XHRjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRpZiAoY291bnQpIHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0aWYgKCFkZWZhdWx0VG9OdWxsKSB0aGlzLmhlYWRlcnMuYXBwZW5kKFwiUHJlZmVyXCIsIGBtaXNzaW5nPWRlZmF1bHRgKTtcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG5cdFx0XHRjb25zdCBjb2x1bW5zID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKSwgW10pO1xuXHRcdFx0aWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRjb25zdCB1bmlxdWVDb2x1bW5zID0gWy4uLm5ldyBTZXQoY29sdW1ucyldLm1hcCgoY29sdW1uKSA9PiBgXCIke2NvbHVtbn1cImApO1xuXHRcdFx0XHR0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KFwiY29sdW1uc1wiLCB1bmlxdWVDb2x1bW5zLmpvaW4oXCIsXCIpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0Ym9keTogdmFsdWVzLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaCA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaCA6IGZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuXHQqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG5cdCogYC5pbnNlcnQoKWAgaWYgYSByb3cgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb25Db25mbGljdGAgY29sdW1ucyBkb2Vzbid0XG5cdCogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuXHQqIGBpZ25vcmVEdXBsaWNhdGVzYC5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuXHQqIHdpdGggYC5zZWxlY3QoKWAuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcblx0KiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5vbkNvbmZsaWN0IC0gQ29tbWEtc2VwYXJhdGVkIFVOSVFVRSBjb2x1bW4ocykgdG8gc3BlY2lmeSBob3dcblx0KiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuXHQqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cblx0KlxuXHQqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuXHQqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG5cdCogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cblx0KiBpbnNlcnRpbmcgbmV3IHJvd3MsIG5vdCB3aGVuIG1lcmdpbmcgd2l0aCBleGlzdGluZyByb3dzIHVuZGVyXG5cdCogYGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlYC4gVGhpcyBhbHNvIG9ubHkgYXBwbGllcyB3aGVuIGRvaW5nIGJ1bGsgdXBzZXJ0cy5cblx0KlxuXHQqIEBleGFtcGxlIFVwc2VydCBhIHNpbmdsZSByb3cgdXNpbmcgYSB1bmlxdWUga2V5XG5cdCogYGBgdHNcblx0KiAvLyBVcHNlcnRpbmcgYSBzaW5nbGUgcm93LCBvdmVyd3JpdGluZyBiYXNlZCBvbiB0aGUgJ3VzZXJuYW1lJyB1bmlxdWUgY29sdW1uXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5mcm9tKCd1c2VycycpXG5cdCogICAudXBzZXJ0KHsgdXNlcm5hbWU6ICdzdXBhYm90JyB9LCB7IG9uQ29uZmxpY3Q6ICd1c2VybmFtZScgfSlcblx0KlxuXHQqIC8vIEV4YW1wbGUgcmVzcG9uc2U6XG5cdCogLy8ge1xuXHQqIC8vICAgZGF0YTogW1xuXHQqIC8vICAgICB7IGlkOiA0LCBtZXNzYWdlOiAnYmFyJywgdXNlcm5hbWU6ICdzdXBhYm90JyB9XG5cdCogLy8gICBdLFxuXHQqIC8vICAgZXJyb3I6IG51bGxcblx0KiAvLyB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBVcHNlcnQgd2l0aCBjb25mbGljdCByZXNvbHV0aW9uIGFuZCBleGFjdCByb3cgY291bnRpbmdcblx0KiBgYGB0c1xuXHQqIC8vIFVwc2VydGluZyBhbmQgcmV0dXJuaW5nIGV4YWN0IGNvdW50XG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciwgY291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuZnJvbSgndXNlcnMnKVxuXHQqICAgLnVwc2VydChcblx0KiAgICAge1xuXHQqICAgICAgIGlkOiAzLFxuXHQqICAgICAgIG1lc3NhZ2U6ICdmb28nLFxuXHQqICAgICAgIHVzZXJuYW1lOiAnc3VwYWJvdCdcblx0KiAgICAgfSxcblx0KiAgICAge1xuXHQqICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VybmFtZScsXG5cdCogICAgICAgY291bnQ6ICdleGFjdCdcblx0KiAgICAgfVxuXHQqICAgKVxuXHQqXG5cdCogLy8gRXhhbXBsZSByZXNwb25zZTpcblx0KiAvLyB7XG5cdCogLy8gICBkYXRhOiBbXG5cdCogLy8gICAgIHtcblx0KiAvLyAgICAgICBpZDogNDIsXG5cdCogLy8gICAgICAgaGFuZGxlOiBcInNhb2lyc2VcIixcblx0KiAvLyAgICAgICBkaXNwbGF5X25hbWU6IFwiU2FvaXJzZVwiXG5cdCogLy8gICAgIH1cblx0KiAvLyAgIF0sXG5cdCogLy8gICBjb3VudDogMSxcblx0KiAvLyAgIGVycm9yOiBudWxsXG5cdCogLy8gfVxuXHQqIGBgYFxuXHQqL1xuXHR1cHNlcnQodmFsdWVzLCB7IG9uQ29uZmxpY3QsIGlnbm9yZUR1cGxpY2F0ZXMgPSBmYWxzZSwgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlIH0gPSB7fSkge1xuXHRcdHZhciBfdGhpcyRmZXRjaDI7XG5cdFx0Y29uc3QgbWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0dGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgcmVzb2x1dGlvbj0ke2lnbm9yZUR1cGxpY2F0ZXMgPyBcImlnbm9yZVwiIDogXCJtZXJnZVwifS1kdXBsaWNhdGVzYCk7XG5cdFx0aWYgKG9uQ29uZmxpY3QgIT09IHZvaWQgMCkgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcIm9uX2NvbmZsaWN0XCIsIG9uQ29uZmxpY3QpO1xuXHRcdGlmIChjb3VudCkgdGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRpZiAoIWRlZmF1bHRUb051bGwpIHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgXCJtaXNzaW5nPWRlZmF1bHRcIik7XG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuXHRcdFx0Y29uc3QgY29sdW1ucyA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgeCkgPT4gYWNjLmNvbmNhdChPYmplY3Qua2V5cyh4KSksIFtdKTtcblx0XHRcdGlmIChjb2x1bW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0Y29uc3QgdW5pcXVlQ29sdW1ucyA9IFsuLi5uZXcgU2V0KGNvbHVtbnMpXS5tYXAoKGNvbHVtbikgPT4gYFwiJHtjb2x1bW59XCJgKTtcblx0XHRcdFx0dGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChcImNvbHVtbnNcIiwgdW5pcXVlQ29sdW1ucy5qb2luKFwiLFwiKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcih7XG5cdFx0XHRtZXRob2QsXG5cdFx0XHR1cmw6IHRoaXMudXJsLFxuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiB0aGlzLnNjaGVtYSxcblx0XHRcdGJvZHk6IHZhbHVlcyxcblx0XHRcdGZldGNoOiAoX3RoaXMkZmV0Y2gyID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2gyICE9PSB2b2lkIDAgPyBfdGhpcyRmZXRjaDIgOiBmZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqIFBlcmZvcm0gYW4gVVBEQVRFIG9uIHRoZSB0YWJsZSBvciB2aWV3LlxuXHQqXG5cdCogQnkgZGVmYXVsdCwgdXBkYXRlZCByb3dzIGFyZSBub3QgcmV0dXJuZWQuIFRvIHJldHVybiBpdCwgY2hhaW4gdGhlIGNhbGxcblx0KiB3aXRoIGAuc2VsZWN0KClgIGFmdGVyIGZpbHRlcnMuXG5cdCpcblx0KiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cGRhdGUgd2l0aFxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgdXBkYXRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0dXBkYXRlKHZhbHVlcywgeyBjb3VudCB9ID0ge30pIHtcblx0XHR2YXIgX3RoaXMkZmV0Y2gzO1xuXHRcdGNvbnN0IG1ldGhvZCA9IFwiUEFUQ0hcIjtcblx0XHRpZiAoY291bnQpIHRoaXMuaGVhZGVycy5hcHBlbmQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybDogdGhpcy51cmwsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hLFxuXHRcdFx0Ym9keTogdmFsdWVzLFxuXHRcdFx0ZmV0Y2g6IChfdGhpcyRmZXRjaDMgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfdGhpcyRmZXRjaDMgIT09IHZvaWQgMCA/IF90aGlzJGZldGNoMyA6IGZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBhIERFTEVURSBvbiB0aGUgdGFibGUgb3Igdmlldy5cblx0KlxuXHQqIEJ5IGRlZmF1bHQsIGRlbGV0ZWQgcm93cyBhcmUgbm90IHJldHVybmVkLiBUbyByZXR1cm4gaXQsIGNoYWluIHRoZSBjYWxsXG5cdCogd2l0aCBgLnNlbGVjdCgpYCBhZnRlciBmaWx0ZXJzLlxuXHQqXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG5cdCpcblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgZGVsZXRlZCByb3dzLlxuXHQqXG5cdCogYFwiZXhhY3RcImA6IEV4YWN0IGJ1dCBzbG93IGNvdW50IGFsZ29yaXRobS4gUGVyZm9ybXMgYSBgQ09VTlQoKilgIHVuZGVyIHRoZVxuXHQqIGhvb2QuXG5cdCpcblx0KiBgXCJwbGFubmVkXCJgOiBBcHByb3hpbWF0ZWQgYnV0IGZhc3QgY291bnQgYWxnb3JpdGhtLiBVc2VzIHRoZSBQb3N0Z3Jlc1xuXHQqIHN0YXRpc3RpY3MgdW5kZXIgdGhlIGhvb2QuXG5cdCpcblx0KiBgXCJlc3RpbWF0ZWRcImA6IFVzZXMgZXhhY3QgY291bnQgZm9yIGxvdyBudW1iZXJzIGFuZCBwbGFubmVkIGNvdW50IGZvciBoaWdoXG5cdCogbnVtYmVycy5cblx0Ki9cblx0ZGVsZXRlKHsgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoNDtcblx0XHRjb25zdCBtZXRob2QgPSBcIkRFTEVURVwiO1xuXHRcdGlmIChjb3VudCkgdGhpcy5oZWFkZXJzLmFwcGVuZChcIlByZWZlclwiLCBgY291bnQ9JHtjb3VudH1gKTtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXIoe1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0dXJsOiB0aGlzLnVybCxcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdHNjaGVtYTogdGhpcy5zY2hlbWEsXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoNCA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF90aGlzJGZldGNoNCAhPT0gdm9pZCAwID8gX3RoaXMkZmV0Y2g0IDogZmV0Y2hcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1Bvc3RncmVzdENsaWVudC50c1xuLyoqXG4qIFBvc3RnUkVTVCBjbGllbnQuXG4qXG4qIEB0eXBlUGFyYW0gRGF0YWJhc2UgLSBUeXBlcyBmb3IgdGhlIHNjaGVtYSBmcm9tIHRoZSBbdHlwZVxuKiBnZW5lcmF0b3JdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvbmV4dC90eXBlc2NyaXB0LXN1cHBvcnQpXG4qXG4qIEB0eXBlUGFyYW0gU2NoZW1hTmFtZSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG8uIE11c3QgYmUgYSBzdHJpbmdcbiogbGl0ZXJhbCwgdGhlIHNhbWUgb25lIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIElmIHRoZSBzY2hlbWEgaXMgbm90XG4qIGBcInB1YmxpY1wiYCwgdGhpcyBtdXN0IGJlIHN1cHBsaWVkIG1hbnVhbGx5LlxuKi9cbnZhciBQb3N0Z3Jlc3RDbGllbnQgPSBjbGFzcyBQb3N0Z3Jlc3RDbGllbnQge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgUG9zdGdSRVNUIGNsaWVudC5cblx0KlxuXHQqIEBwYXJhbSB1cmwgLSBVUkwgb2YgdGhlIFBvc3RnUkVTVCBlbmRwb2ludFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgLSBDdXN0b20gaGVhZGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLnNjaGVtYSAtIFBvc3RncmVzIHNjaGVtYSB0byBzd2l0Y2ggdG9cblx0KiBAcGFyYW0gb3B0aW9ucy5mZXRjaCAtIEN1c3RvbSBmZXRjaFxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgUG9zdGdyZXN0Q2xpZW50IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnXG5cdCpcblx0KiBjb25zdCBwb3N0Z3Jlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KCdodHRwczovL3h5emNvbXBhbnkuc3VwYWJhc2UuY28vcmVzdC92MScsIHtcblx0KiAgIGhlYWRlcnM6IHsgYXBpa2V5OiAncHVibGljLWFub24ta2V5JyB9LFxuXHQqICAgc2NoZW1hOiAncHVibGljJyxcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoOiBmZXRjaCQxIH0gPSB7fSkge1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuXHRcdHRoaXMuc2NoZW1hTmFtZSA9IHNjaGVtYTtcblx0XHR0aGlzLmZldGNoID0gZmV0Y2gkMTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG5cdCpcblx0KiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG5cdCovXG5cdGZyb20ocmVsYXRpb24pIHtcblx0XHRpZiAoIXJlbGF0aW9uIHx8IHR5cGVvZiByZWxhdGlvbiAhPT0gXCJzdHJpbmdcIiB8fCByZWxhdGlvbi50cmltKCkgPT09IFwiXCIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVsYXRpb24gbmFtZTogcmVsYXRpb24gbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIpO1xuXHRcdHJldHVybiBuZXcgUG9zdGdyZXN0UXVlcnlCdWlsZGVyKG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7cmVsYXRpb259YCksIHtcblx0XHRcdGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyksXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcblx0XHRcdGZldGNoOiB0aGlzLmZldGNoXG5cdFx0fSk7XG5cdH1cblx0LyoqXG5cdCogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cblx0KlxuXHQqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cblx0KlxuXHQqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG5cdCovXG5cdHNjaGVtYShzY2hlbWEpIHtcblx0XHRyZXR1cm4gbmV3IFBvc3RncmVzdENsaWVudCh0aGlzLnVybCwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hLFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cblx0KlxuXHQqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcblx0KiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuXHQqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcblx0KiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuXHQqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0c1xuXHQqIC8vIEZvciBjcm9zcy1zY2hlbWEgZnVuY3Rpb25zIHdoZXJlIHR5cGUgaW5mZXJlbmNlIGZhaWxzLCB1c2Ugb3ZlcnJpZGVUeXBlczpcblx0KiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc2NoZW1hKCdzY2hlbWFfYicpXG5cdCogICAucnBjKCdmdW5jdGlvbl9hJywge30pXG5cdCogICAub3ZlcnJpZGVUeXBlczx7IGlkOiBzdHJpbmc7IHVzZXJfaWQ6IHN0cmluZyB9W10+KClcblx0KiBgYGBcblx0Ki9cblx0cnBjKGZuLCBhcmdzID0ge30sIHsgaGVhZCA9IGZhbHNlLCBnZXQgPSBmYWxzZSwgY291bnQgfSA9IHt9KSB7XG5cdFx0dmFyIF90aGlzJGZldGNoO1xuXHRcdGxldCBtZXRob2Q7XG5cdFx0Y29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vcnBjLyR7Zm59YCk7XG5cdFx0bGV0IGJvZHk7XG5cdFx0Y29uc3QgX2lzT2JqZWN0ID0gKHYpID0+IHYgIT09IG51bGwgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgKCFBcnJheS5pc0FycmF5KHYpIHx8IHYuc29tZShfaXNPYmplY3QpKTtcblx0XHRjb25zdCBfaGFzT2JqZWN0QXJnID0gaGVhZCAmJiBPYmplY3QudmFsdWVzKGFyZ3MpLnNvbWUoX2lzT2JqZWN0KTtcblx0XHRpZiAoX2hhc09iamVjdEFyZykge1xuXHRcdFx0bWV0aG9kID0gXCJQT1NUXCI7XG5cdFx0XHRib2R5ID0gYXJncztcblx0XHR9IGVsc2UgaWYgKGhlYWQgfHwgZ2V0KSB7XG5cdFx0XHRtZXRob2QgPSBoZWFkID8gXCJIRUFEXCIgOiBcIkdFVFwiO1xuXHRcdFx0T2JqZWN0LmVudHJpZXMoYXJncykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gdm9pZCAwKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKFwiLFwiKX19YCA6IGAke3ZhbHVlfWBdKS5mb3JFYWNoKChbbmFtZSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRcdHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtZXRob2QgPSBcIlBPU1RcIjtcblx0XHRcdGJvZHkgPSBhcmdzO1xuXHRcdH1cblx0XHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcblx0XHRpZiAoX2hhc09iamVjdEFyZykgaGVhZGVycy5zZXQoXCJQcmVmZXJcIiwgY291bnQgPyBgY291bnQ9JHtjb3VudH0scmV0dXJuPW1pbmltYWxgIDogXCJyZXR1cm49bWluaW1hbFwiKTtcblx0XHRlbHNlIGlmIChjb3VudCkgaGVhZGVycy5zZXQoXCJQcmVmZXJcIiwgYGNvdW50PSR7Y291bnR9YCk7XG5cdFx0cmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyKHtcblx0XHRcdG1ldGhvZCxcblx0XHRcdHVybCxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRzY2hlbWE6IHRoaXMuc2NoZW1hTmFtZSxcblx0XHRcdGJvZHksXG5cdFx0XHRmZXRjaDogKF90aGlzJGZldGNoID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX3RoaXMkZmV0Y2ggIT09IHZvaWQgMCA/IF90aGlzJGZldGNoIDogZmV0Y2hcblx0XHR9KTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2luZGV4LnRzXG52YXIgc3JjX2RlZmF1bHQgPSB7XG5cdFBvc3RncmVzdENsaWVudCxcblx0UG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuXHRQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuXHRQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuXHRQb3N0Z3Jlc3RCdWlsZGVyLFxuXHRQb3N0Z3Jlc3RFcnJvclxufTtcblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBQb3N0Z3Jlc3RCdWlsZGVyLCBQb3N0Z3Jlc3RDbGllbnQsIFBvc3RncmVzdEVycm9yLCBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLCBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIsIFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIsIHNyY19kZWZhdWx0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiUG9zdGdyZXN0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29udGV4dCIsIm1lc3NhZ2UiLCJuYW1lIiwiZGV0YWlscyIsImhpbnQiLCJjb2RlIiwiUG9zdGdyZXN0QnVpbGRlciIsImJ1aWxkZXIiLCJfYnVpbGRlciRzaG91bGRUaHJvd08iLCJfYnVpbGRlciRpc01heWJlU2luZ2wiLCJzaG91bGRUaHJvd09uRXJyb3IiLCJtZXRob2QiLCJ1cmwiLCJoZWFkZXJzIiwiSGVhZGVycyIsInNjaGVtYSIsImJvZHkiLCJzaWduYWwiLCJpc01heWJlU2luZ2xlIiwiZmV0Y2giLCJ0aHJvd09uRXJyb3IiLCJzZXRIZWFkZXIiLCJ2YWx1ZSIsInNldCIsInRoZW4iLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJfdGhpcyIsImluY2x1ZGVzIiwiX2ZldGNoIiwicmVzIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVzJDEiLCJlcnJvciIsImRhdGEiLCJjb3VudCIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJvayIsIl90aGlzJGhlYWRlcnMkZ2V0MiIsIl9yZXMkaGVhZGVycyRnZXQiLCJfdGhpcyRoZWFkZXJzJGdldCIsInRleHQiLCJnZXQiLCJwYXJzZSIsImNvdW50SGVhZGVyIiwibWF0Y2giLCJjb250ZW50UmFuZ2UiLCJzcGxpdCIsImxlbmd0aCIsInBhcnNlSW50IiwiQXJyYXkiLCJpc0FycmF5IiwiX2Vycm9yJGRldGFpbHMiLCJfdW51c2VkIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwiX2ZldGNoRXJyb3IkbmFtZTIiLCJlcnJvckRldGFpbHMiLCJjYXVzZSIsIl9jYXVzZSRtZXNzYWdlIiwiX2NhdXNlJGNvZGUiLCJfZmV0Y2hFcnJvciRuYW1lIiwiX2NhdXNlJG5hbWUiLCJjYXVzZU1lc3NhZ2UiLCJjYXVzZUNvZGUiLCJzdGFjayIsIl9mZXRjaEVycm9yJHN0YWNrIiwicmV0dXJucyIsIm92ZXJyaWRlVHlwZXMiLCJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIiwic2VsZWN0IiwiY29sdW1ucyIsInF1b3RlZCIsImNsZWFuZWRDb2x1bW5zIiwibWFwIiwiYyIsInRlc3QiLCJqb2luIiwic2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwib3JkZXIiLCJjb2x1bW4iLCJhc2NlbmRpbmciLCJudWxsc0ZpcnN0IiwiZm9yZWlnblRhYmxlIiwicmVmZXJlbmNlZFRhYmxlIiwia2V5IiwiZXhpc3RpbmdPcmRlciIsImxpbWl0IiwicmFuZ2UiLCJmcm9tIiwidG8iLCJrZXlPZmZzZXQiLCJrZXlMaW1pdCIsImFib3J0U2lnbmFsIiwic2luZ2xlIiwibWF5YmVTaW5nbGUiLCJjc3YiLCJnZW9qc29uIiwiZXhwbGFpbiIsImFuYWx5emUiLCJ2ZXJib3NlIiwic2V0dGluZ3MiLCJidWZmZXJzIiwid2FsIiwiZm9ybWF0Iiwib3B0aW9ucyIsImZpbHRlciIsIkJvb2xlYW4iLCJmb3JNZWRpYXR5cGUiLCJyb2xsYmFjayIsIm1heEFmZmVjdGVkIiwiUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cCIsIlJlZ0V4cCIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXIiLCJlcSIsIm5lcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJsaWtlIiwicGF0dGVybiIsImxpa2VBbGxPZiIsInBhdHRlcm5zIiwibGlrZUFueU9mIiwiaWxpa2UiLCJpbGlrZUFsbE9mIiwiaWxpa2VBbnlPZiIsInJlZ2V4TWF0Y2giLCJyZWdleElNYXRjaCIsImlzIiwiaXNEaXN0aW5jdCIsImluIiwidmFsdWVzIiwiY2xlYW5lZFZhbHVlcyIsIlNldCIsInMiLCJub3RJbiIsImNvbnRhaW5zIiwiY29udGFpbmVkQnkiLCJyYW5nZUd0IiwicmFuZ2VHdGUiLCJyYW5nZUx0IiwicmFuZ2VMdGUiLCJyYW5nZUFkamFjZW50Iiwib3ZlcmxhcHMiLCJ0ZXh0U2VhcmNoIiwicXVlcnkiLCJjb25maWciLCJ0eXBlIiwidHlwZVBhcnQiLCJjb25maWdQYXJ0IiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJub3QiLCJvcGVyYXRvciIsIm9yIiwiZmlsdGVycyIsIlBvc3RncmVzdFF1ZXJ5QnVpbGRlciIsImZldGNoJDEiLCJoZWFkIiwiaW5zZXJ0IiwiZGVmYXVsdFRvTnVsbCIsIl90aGlzJGZldGNoIiwicmVkdWNlIiwiYWNjIiwieCIsImNvbmNhdCIsImtleXMiLCJ1bmlxdWVDb2x1bW5zIiwidXBzZXJ0Iiwib25Db25mbGljdCIsImlnbm9yZUR1cGxpY2F0ZXMiLCJfdGhpcyRmZXRjaDIiLCJ1cGRhdGUiLCJfdGhpcyRmZXRjaDMiLCJkZWxldGUiLCJfdGhpcyRmZXRjaDQiLCJQb3N0Z3Jlc3RDbGllbnQiLCJzY2hlbWFOYW1lIiwicmVsYXRpb24iLCJ0cmltIiwiVVJMIiwicnBjIiwiZm4iLCJhcmdzIiwiX2lzT2JqZWN0IiwidiIsInNvbWUiLCJfaGFzT2JqZWN0QXJnIiwiXyIsInNyY19kZWZhdWx0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/index.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/index.mjs ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageAnalyticsClient: () => (/* binding */ StorageAnalyticsClient),\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   StorageVectorsApiError: () => (/* binding */ StorageVectorsApiError),\n/* harmony export */   StorageVectorsClient: () => (/* binding */ StorageVectorsClient),\n/* harmony export */   StorageVectorsError: () => (/* binding */ StorageVectorsError),\n/* harmony export */   StorageVectorsErrorCode: () => (/* binding */ StorageVectorsErrorCode),\n/* harmony export */   StorageVectorsUnknownError: () => (/* binding */ StorageVectorsUnknownError),\n/* harmony export */   VectorBucketApi: () => (/* binding */ VectorBucketApi),\n/* harmony export */   VectorBucketScope: () => (/* binding */ VectorBucketScope),\n/* harmony export */   VectorDataApi: () => (/* binding */ VectorDataApi),\n/* harmony export */   VectorIndexApi: () => (/* binding */ VectorIndexApi),\n/* harmony export */   VectorIndexScope: () => (/* binding */ VectorIndexScope),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError),\n/* harmony export */   isStorageVectorsError: () => (/* binding */ isStorageVectorsError),\n/* harmony export */   normalizeToFloat32: () => (/* binding */ normalizeToFloat32),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   validateVectorDimension: () => (/* binding */ validateVectorDimension)\n/* harmony export */ });\n/* harmony import */ var iceberg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! iceberg-js */ \"(ssr)/./node_modules/iceberg-js/dist/index.mjs\");\n\n//#region src/lib/errors.ts\nvar StorageError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n};\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nvar StorageApiError = class extends StorageError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\nvar StorageUnknownError = class extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n};\n//#endregion\n//#region src/lib/helpers.ts\nconst resolveFetch$1 = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveResponse$1 = ()=>{\n    return Response;\n};\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) return item.map((el)=>recursiveToCamel(el));\n    else if (typeof item === \"function\" || item !== Object(item)) return item;\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n* source: https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject$1 = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Validates if a given bucket name is valid according to Supabase Storage API rules\n* Mirrors backend validation from: storage/src/storage/limits.ts:isValidBucketName()\n*\n* Rules:\n* - Length: 1-100 characters\n* - Allowed characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), and safe special characters\n* - Safe special characters: ! - . * ' ( ) space & $ @ = ; : + , ?\n* - Forbidden: path separators (/, \\), path traversal (..), leading/trailing whitespace\n*\n* AWS S3 Reference: https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-keys.html\n*\n* @param bucketName - The bucket name to validate\n* @returns true if valid, false otherwise\n*/ const isValidBucketName = (bucketName)=>{\n    if (!bucketName || typeof bucketName !== \"string\") return false;\n    if (bucketName.length === 0 || bucketName.length > 100) return false;\n    if (bucketName.trim() !== bucketName) return false;\n    if (bucketName.includes(\"/\") || bucketName.includes(\"\\\\\")) return false;\n    return /^[\\w!.\\*'() &$@=;:+,?-]+$/.test(bucketName);\n};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst _getErrorMessage$1 = (err)=>{\n    var _err$error;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_err$error = err.error) === null || _err$error === void 0 ? void 0 : _err$error.message) || JSON.stringify(err);\n};\nconst handleError$1 = async (error, reject, options)=>{\n    if (error instanceof await resolveResponse$1() && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) error.json().then((err)=>{\n        const status = error.status || 500;\n        const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + \"\";\n        reject(new StorageApiError(_getErrorMessage$1(err), status, statusCode));\n    }).catch((err)=>{\n        reject(new StorageUnknownError(_getErrorMessage$1(err), err));\n    });\n    else reject(new StorageUnknownError(_getErrorMessage$1(error), error));\n};\nconst _getRequestParams$1 = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject$1(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    if (options === null || options === void 0 ? void 0 : options.duplex) params.duplex = options.duplex;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\nasync function _handleRequest$1(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams$1(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError$1(error, reject, options));\n    });\n}\nasync function get(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"GET\", url, options, parameters);\n}\nasync function post$1(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"POST\", url, options, parameters, body);\n}\nasync function put(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"PUT\", url, options, parameters, body);\n}\nasync function head(fetcher, url, options, parameters) {\n    return _handleRequest$1(fetcher, \"HEAD\", url, _objectSpread2(_objectSpread2({}, options), {}, {\n        noResolveJson: true\n    }), parameters);\n}\nasync function remove(fetcher, url, body, options, parameters) {\n    return _handleRequest$1(fetcher, \"DELETE\", url, options, parameters, body);\n}\n//#endregion\n//#region src/packages/StreamDownloadBuilder.ts\nvar StreamDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: (await _this.downloadFn()).body,\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/BlobDownloadBuilder.ts\nlet _Symbol$toStringTag;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar BlobDownloadBuilder = class {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_Symbol$toStringTag] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new StreamDownloadBuilder(this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) this.promise = this.execute();\n        return this.promise;\n    }\n    async execute() {\n        var _this = this;\n        try {\n            return {\n                data: await (await _this.downloadFn()).blob(),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/packages/StorageFileApi.ts\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nvar StorageFileApi = class {\n    constructor(url, headers = {}, bucketId, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n\t*\n\t* @param method HTTP method.\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t*/ async uploadOrUpdate(method, path, fileBody, fileOptions) {\n        var _this = this;\n        try {\n            let body;\n            const options = _objectSpread2(_objectSpread2({}, DEFAULT_FILE_OPTIONS), fileOptions);\n            let headers = _objectSpread2(_objectSpread2({}, _this.headers), method === \"POST\" && {\n                \"x-upsert\": String(options.upsert)\n            });\n            const metadata = options.metadata;\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                if (metadata) body.append(\"metadata\", _this.encodeMetadata(metadata));\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                if (!body.has(\"cacheControl\")) body.append(\"cacheControl\", options.cacheControl);\n                if (metadata && !body.has(\"metadata\")) body.append(\"metadata\", _this.encodeMetadata(metadata));\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n                if (metadata) headers[\"x-metadata\"] = _this.toBase64(_this.encodeMetadata(metadata));\n                if ((typeof ReadableStream !== \"undefined\" && body instanceof ReadableStream || body && typeof body === \"object\" && \"pipe\" in body && typeof body.pipe === \"function\") && !options.duplex) options.duplex = \"half\";\n            }\n            if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) headers = _objectSpread2(_objectSpread2({}, headers), fileOptions.headers);\n            const cleanPath = _this._removeEmptyFolders(path);\n            const _path = _this._getFinalPath(cleanPath);\n            const data = await (method == \"PUT\" ? put : post$1)(_this.fetch, `${_this.url}/object/${_path}`, body, _objectSpread2({\n                headers\n            }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                duplex: options.duplex\n            } : {}));\n            return {\n                data: {\n                    path: cleanPath,\n                    id: data.Id,\n                    fullPath: data.Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Uploads a file to an existing bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Upload file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: false\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Upload file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import { decode } from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .upload('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async upload(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Upload a file with a token generated from `createSignedUploadUrl`.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n\t* @param token The token generated from `createSignedUploadUrl`\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions HTTP headers (cacheControl, contentType, etc.).\n\t* **Note:** The `upsert` option has no effect here. To enable upsert behavior,\n\t* pass `{ upsert: true }` when calling `createSignedUploadUrl()` instead.\n\t* @returns Promise with response containing file path and fullPath or error\n\t*\n\t* @example Upload to a signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .uploadToSignedUrl('folder/cat.jpg', 'token-from-createSignedUploadUrl', file)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"fullPath\": \"avatars/folder/cat.jpg\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        var _this3 = this;\n        const cleanPath = _this3._removeEmptyFolders(path);\n        const _path = _this3._getFinalPath(cleanPath);\n        const url = new URL(_this3.url + `/object/upload/sign/${_path}`);\n        url.searchParams.set(\"token\", token);\n        try {\n            let body;\n            const options = _objectSpread2({\n                upsert: DEFAULT_FILE_OPTIONS.upsert\n            }, fileOptions);\n            const headers = _objectSpread2(_objectSpread2({}, _this3.headers), {\n                \"x-upsert\": String(options.upsert)\n            });\n            if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                body = new FormData();\n                body.append(\"cacheControl\", options.cacheControl);\n                body.append(\"\", fileBody);\n            } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                body = fileBody;\n                body.append(\"cacheControl\", options.cacheControl);\n            } else {\n                body = fileBody;\n                headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                headers[\"content-type\"] = options.contentType;\n            }\n            return {\n                data: {\n                    path: cleanPath,\n                    fullPath: (await put(_this3.fetch, url.toString(), body, {\n                        headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed upload URL.\n\t* Signed upload URLs can be used to upload files to the bucket without further authentication.\n\t* They are valid for 2 hours.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n\t* @returns Promise with response containing signed upload URL, token, and path or error\n\t*\n\t* @example Create Signed Upload URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUploadUrl('folder/cat.jpg')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/upload/sign/avatars/folder/cat.jpg?token=<TOKEN>\",\n\t*     \"path\": \"folder/cat.jpg\",\n\t*     \"token\": \"<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUploadUrl(path, options) {\n        var _this4 = this;\n        try {\n            let _path = _this4._getFinalPath(path);\n            const headers = _objectSpread2({}, _this4.headers);\n            if (options === null || options === void 0 ? void 0 : options.upsert) headers[\"x-upsert\"] = \"true\";\n            const data = await post$1(_this4.fetch, `${_this4.url}/object/upload/sign/${_path}`, {}, {\n                headers\n            });\n            const url = new URL(_this4.url + data.url);\n            const token = url.searchParams.get(\"token\");\n            if (!token) throw new StorageError(\"No token returned by API\");\n            return {\n                data: {\n                    signedUrl: url.toString(),\n                    path,\n                    token\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Replaces an existing file at the specified path with a new one.\n\t*\n\t* @category File Buckets\n\t* @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n\t* @param fileBody The body of the file to be stored in the bucket.\n\t* @param fileOptions Optional file upload options including cacheControl, contentType, upsert, and metadata.\n\t* @returns Promise with response containing file path, id, and fullPath or error\n\t*\n\t* @example Update file\n\t* ```js\n\t* const avatarFile = event.target.files[0]\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', avatarFile, {\n\t*     cacheControl: '3600',\n\t*     upsert: true\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"public/avatar1.png\",\n\t*     \"fullPath\": \"avatars/public/avatar1.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Update file using `ArrayBuffer` from base64 file data\n\t* ```js\n\t* import {decode} from 'base64-arraybuffer'\n\t*\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .update('public/avatar1.png', decode('base64FileData'), {\n\t*     contentType: 'image/png'\n\t*   })\n\t* ```\n\t*/ async update(path, fileBody, fileOptions) {\n        return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n    }\n    /**\n\t* Moves an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Move file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .move('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully moved\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async move(fromPath, toPath, options) {\n        var _this6 = this;\n        try {\n            return {\n                data: await post$1(_this6.fetch, `${_this6.url}/object/move`, {\n                    bucketId: _this6.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Copies an existing file to a new path in the same bucket.\n\t*\n\t* @category File Buckets\n\t* @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n\t* @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n\t* @param options The destination options.\n\t* @returns Promise with response containing copied file path or error\n\t*\n\t* @example Copy file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .copy('public/avatar1.png', 'private/avatar2.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"path\": \"avatars/private/avatar2.png\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async copy(fromPath, toPath, options) {\n        var _this7 = this;\n        try {\n            return {\n                data: {\n                    path: (await post$1(_this7.fetch, `${_this7.url}/object/copy`, {\n                        bucketId: _this7.bucketId,\n                        sourceKey: fromPath,\n                        destinationKey: toPath,\n                        destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                    }, {\n                        headers: _this7.headers\n                    })).Key\n                },\n                error: null\n            };\n        } catch (error) {\n            if (_this7.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the current file name. For example `folder/image.png`.\n\t* @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Promise with response containing signed URL or error\n\t*\n\t* @example Create Signed URL\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Create a signed URL for an asset with transformations\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Create a signed URL which triggers the download of the asset\n\t* ```js\n\t* const { data } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrl('folder/avatar1.png', 60, {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ async createSignedUrl(path, expiresIn, options) {\n        var _this8 = this;\n        try {\n            let _path = _this8._getFinalPath(path);\n            let data = await post$1(_this8.fetch, `${_this8.url}/object/sign/${_path}`, _objectSpread2({\n                expiresIn\n            }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                transform: options.transform\n            } : {}), {\n                headers: _this8.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            data = {\n                signedUrl: encodeURI(`${_this8.url}${data.signedURL}${downloadQueryParam}`)\n            };\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if (_this8.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n\t*\n\t* @category File Buckets\n\t* @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n\t* @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n\t* @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @returns Promise with response containing array of objects with signedUrl, path, and error or error\n\t*\n\t* @example Create Signed URLs\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .createSignedUrls(['folder/avatar1.png', 'folder/avatar2.png'], 60)\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar1.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar1.png?token=<TOKEN>\"\n\t*     },\n\t*     {\n\t*       \"error\": null,\n\t*       \"path\": \"folder/avatar2.png\",\n\t*       \"signedURL\": \"/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\",\n\t*       \"signedUrl\": \"https://example.supabase.co/storage/v1/object/sign/avatars/folder/avatar2.png?token=<TOKEN>\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createSignedUrls(paths, expiresIn, options) {\n        var _this9 = this;\n        try {\n            const data = await post$1(_this9.fetch, `${_this9.url}/object/sign/${_this9.bucketId}`, {\n                expiresIn,\n                paths\n            }, {\n                headers: _this9.headers\n            });\n            const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n            return {\n                data: data.map((datum)=>_objectSpread2(_objectSpread2({}, datum), {}, {\n                        signedUrl: datum.signedURL ? encodeURI(`${_this9.url}${datum.signedURL}${downloadQueryParam}`) : null\n                    })),\n                error: null\n            };\n        } catch (error) {\n            if (_this9.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n\t*\n\t* @category File Buckets\n\t* @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns BlobDownloadBuilder instance for downloading the file\n\t*\n\t* @example Download file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": <BLOB>,\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Download file with transformations\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .download('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*       quality: 80\n\t*     }\n\t*   })\n\t* ```\n\t*/ download(path, options) {\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n        return new BlobDownloadBuilder(downloadFn, this.shouldThrowOnError);\n    }\n    /**\n\t* Retrieves the details of an existing file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing file metadata or error\n\t*\n\t* @example Get file info\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .info('folder/avatar1.png')\n\t* ```\n\t*/ async info(path) {\n        var _this10 = this;\n        const _path = _this10._getFinalPath(path);\n        try {\n            return {\n                data: recursiveToCamel(await get(_this10.fetch, `${_this10.url}/object/info/${_path}`, {\n                    headers: _this10.headers\n                })),\n                error: null\n            };\n        } catch (error) {\n            if (_this10.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Checks the existence of a file.\n\t*\n\t* @category File Buckets\n\t* @param path The file path, including the file name. For example `folder/image.png`.\n\t* @returns Promise with response containing boolean indicating file existence or error\n\t*\n\t* @example Check file existence\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .exists('folder/avatar1.png')\n\t* ```\n\t*/ async exists(path) {\n        var _this11 = this;\n        const _path = _this11._getFinalPath(path);\n        try {\n            await head(_this11.fetch, `${_this11.url}/object/${_path}`, {\n                headers: _this11.headers\n            });\n            return {\n                data: true,\n                error: null\n            };\n        } catch (error) {\n            if (_this11.shouldThrowOnError) throw error;\n            if (isStorageError(error) && error instanceof StorageUnknownError) {\n                const originalError = error.originalError;\n                if ([\n                    400,\n                    404\n                ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) return {\n                    data: false,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n\t* A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n\t* This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n\t*\n\t* @category File Buckets\n\t* @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n\t* @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n\t* @param options.transform Transform the asset before serving it to the client.\n\t* @returns Object with public URL\n\t*\n\t* @example Returns the URL for an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"publicUrl\": \"https://example.supabase.co/storage/v1/object/public/public-bucket/folder/avatar1.png\"\n\t*   }\n\t* }\n\t* ```\n\t*\n\t* @example Returns the URL for an asset in a public bucket with transformations\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     transform: {\n\t*       width: 100,\n\t*       height: 100,\n\t*     }\n\t*   })\n\t* ```\n\t*\n\t* @example Returns the URL which triggers the download of an asset in a public bucket\n\t* ```js\n\t* const { data } = supabase\n\t*   .storage\n\t*   .from('public-bucket')\n\t*   .getPublicUrl('folder/avatar1.png', {\n\t*     download: true,\n\t*   })\n\t* ```\n\t*/ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") _queryString.push(downloadQueryParam);\n        const renderPath = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\" ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") _queryString.push(transformationQuery);\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") queryString = `?${queryString}`;\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n\t* Deletes files within the same bucket\n\t*\n\t* @category File Buckets\n\t* @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n\t* @returns Promise with response containing array of deleted file objects or error\n\t*\n\t* @example Delete file\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .remove(['folder/avatar1.png'])\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async remove(paths) {\n        var _this12 = this;\n        try {\n            return {\n                data: await remove(_this12.fetch, `${_this12.url}/object/${_this12.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: _this12.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this12.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Get file metadata\n\t* @param id the file id to retrieve metadata\n\t*/ /**\n\t* Update file metadata\n\t* @param id the file id to update metadata\n\t* @param meta the new file metadata\n\t*/ /**\n\t* Lists all the files and folders within a path of the bucket.\n\t*\n\t* @category File Buckets\n\t* @param path The folder path.\n\t* @param options Search options including limit (defaults to 100), offset, sortBy, and search\n\t* @param parameters Optional fetch parameters including signal for cancellation\n\t* @returns Promise with response containing array of files or error\n\t*\n\t* @example List files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"avatar1.png\",\n\t*       \"id\": \"e668cf7f-821b-4a2f-9dce-7dfa5dd1cfd2\",\n\t*       \"updated_at\": \"2024-05-22T23:06:05.580Z\",\n\t*       \"created_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"last_accessed_at\": \"2024-05-22T23:04:34.443Z\",\n\t*       \"metadata\": {\n\t*         \"eTag\": \"\\\"c5e8c553235d9af30ef4f6e280790b92\\\"\",\n\t*         \"size\": 32175,\n\t*         \"mimetype\": \"image/png\",\n\t*         \"cacheControl\": \"max-age=3600\",\n\t*         \"lastModified\": \"2024-05-22T23:06:05.574Z\",\n\t*         \"contentLength\": 32175,\n\t*         \"httpStatusCode\": 200\n\t*       }\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*\n\t* @example Search files in a bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .from('avatars')\n\t*   .list('folder', {\n\t*     limit: 100,\n\t*     offset: 0,\n\t*     sortBy: { column: 'name', order: 'asc' },\n\t*     search: 'jon'\n\t*   })\n\t* ```\n\t*/ async list(path, options, parameters) {\n        var _this13 = this;\n        try {\n            const body = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_SEARCH_OPTIONS), options), {}, {\n                prefix: path || \"\"\n            });\n            return {\n                data: await post$1(_this13.fetch, `${_this13.url}/object/list/${_this13.bucketId}`, body, {\n                    headers: _this13.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this13.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @experimental this method signature might change in the future\n\t*\n\t* @category File Buckets\n\t* @param options search options\n\t* @param parameters\n\t*/ async listV2(options, parameters) {\n        var _this14 = this;\n        try {\n            const body = _objectSpread2({}, options);\n            return {\n                data: await post$1(_this14.fetch, `${_this14.url}/object/list-v2/${_this14.bucketId}`, body, {\n                    headers: _this14.headers\n                }, parameters),\n                error: null\n            };\n        } catch (error) {\n            if (_this14.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") return Buffer.from(data).toString(\"base64\");\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) params.push(`width=${transform.width}`);\n        if (transform.height) params.push(`height=${transform.height}`);\n        if (transform.resize) params.push(`resize=${transform.resize}`);\n        if (transform.format) params.push(`format=${transform.format}`);\n        if (transform.quality) params.push(`quality=${transform.quality}`);\n        return params.join(\"&\");\n    }\n};\n//#endregion\n//#region src/lib/version.ts\nconst version = \"2.90.0\";\n//#endregion\n//#region src/lib/constants.ts\nconst DEFAULT_HEADERS$1 = {\n    \"X-Client-Info\": `storage-js/${version}`\n};\n//#endregion\n//#region src/packages/StorageBucketApi.ts\nvar StorageBucketApi = class {\n    constructor(url, headers = {}, fetch$1, opts){\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            if (/supabase\\.(co|in|red)$/.test(baseUrl.hostname) && !baseUrl.hostname.includes(\"storage.supabase.\")) baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n        }\n        this.url = baseUrl.href.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* Enable throwing errors instead of returning them.\n\t*\n\t* @category File Buckets\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* Retrieves the details of all Storage buckets within an existing project.\n\t*\n\t* @category File Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of buckets or error\n\t*\n\t* @example List buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets()\n\t* ```\n\t*\n\t* @example List buckets with options\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc',\n\t*     search: 'prod'\n\t*   })\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this = this;\n        try {\n            const queryString = _this.listBucketOptionsToQueryString(options);\n            return {\n                data: await get(_this.fetch, `${_this.url}/bucket${queryString}`, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Retrieves the details of an existing Storage bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to retrieve.\n\t* @returns Promise with response containing bucket details or error\n\t*\n\t* @example Get bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .getBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"id\": \"avatars\",\n\t*     \"name\": \"avatars\",\n\t*     \"owner\": \"\",\n\t*     \"public\": false,\n\t*     \"file_size_limit\": 1024,\n\t*     \"allowed_mime_types\": [\n\t*       \"image/png\"\n\t*     ],\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async getBucket(id) {\n        var _this2 = this;\n        try {\n            return {\n                data: await get(_this2.fetch, `${_this2.url}/bucket/${id}`, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Creates a new Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are creating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n\t*   - default bucket type is `STANDARD`\n\t* @returns Promise with response containing newly created bucket name or error\n\t*\n\t* @example Create bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .createBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"avatars\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(id, options = {\n        public: false\n    }) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post$1(_this3.fetch, `${_this3.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Updates a Storage bucket\n\t*\n\t* @category File Buckets\n\t* @param id A unique identifier for the bucket you are updating.\n\t* @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n\t* @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n\t* The global file size limit takes precedence over this value.\n\t* The default value is null, which doesn't set a per bucket file size limit.\n\t* @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n\t* The default value is null, which allows files with all mime types to be uploaded.\n\t* Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Update bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .updateBucket('avatars', {\n\t*     public: false,\n\t*     allowedMimeTypes: ['image/png'],\n\t*     fileSizeLimit: 1024\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully updated\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async updateBucket(id, options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await put(_this4.fetch, `${_this4.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Removes all objects inside a single bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to empty.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Empty bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .emptyBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully emptied\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async emptyBucket(id) {\n        var _this5 = this;\n        try {\n            return {\n                data: await post$1(_this5.fetch, `${_this5.url}/bucket/${id}/empty`, {}, {\n                    headers: _this5.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n\t* You must first `empty()` the bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The unique identifier of the bucket you would like to delete.\n\t* @returns Promise with success message or error\n\t*\n\t* @example Delete bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .deleteBucket('avatars')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(id) {\n        var _this6 = this;\n        try {\n            return {\n                data: await remove(_this6.fetch, `${_this6.url}/bucket/${id}`, {}, {\n                    headers: _this6.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this6.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) params.limit = String(options.limit);\n            if (\"offset\" in options) params.offset = String(options.offset);\n            if (options.search) params.search = options.search;\n            if (options.sortColumn) params.sortColumn = options.sortColumn;\n            if (options.sortOrder) params.sortOrder = options.sortOrder;\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n};\n//#endregion\n//#region src/packages/StorageAnalyticsClient.ts\n/**\n* Client class for managing Analytics Buckets using Iceberg tables\n* Provides methods for creating, listing, and deleting analytics buckets\n*/ var StorageAnalyticsClient = class {\n    /**\n\t* @alpha\n\t*\n\t* Creates a new StorageAnalyticsClient instance\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param url - The base URL for the storage API\n\t* @param headers - HTTP headers to include in requests\n\t* @param fetch - Optional custom fetch implementation\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageAnalyticsClient(url, headers)\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS$1), headers);\n        this.fetch = resolveFetch$1(fetch$1);\n    }\n    /**\n\t* @alpha\n\t*\n\t* Enable throwing errors instead of returning them in the response\n\t* When enabled, failed operations will throw instead of returning { data: null, error }\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns This instance for method chaining\n\t*/ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n\t* @alpha\n\t*\n\t* Creates a new analytics bucket using Iceberg tables\n\t* Analytics buckets are optimized for analytical queries and data processing\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param name A unique name for the bucket you are creating\n\t* @returns Promise with response containing newly created analytics bucket or error\n\t*\n\t* @example Create analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"name\": \"analytics-data\",\n\t*     \"type\": \"ANALYTICS\",\n\t*     \"format\": \"iceberg\",\n\t*     \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*     \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async createBucket(name) {\n        var _this = this;\n        try {\n            return {\n                data: await post$1(_this.fetch, `${_this.url}/bucket`, {\n                    name\n                }, {\n                    headers: _this.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Retrieves the details of all Analytics Storage buckets within an existing project\n\t* Only returns buckets of type 'ANALYTICS'\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param options Query parameters for listing buckets\n\t* @param options.limit Maximum number of buckets to return\n\t* @param options.offset Number of buckets to skip\n\t* @param options.sortColumn Column to sort by ('name', 'created_at', 'updated_at')\n\t* @param options.sortOrder Sort order ('asc' or 'desc')\n\t* @param options.search Search term to filter bucket names\n\t* @returns Promise with response containing array of analytics buckets or error\n\t*\n\t* @example List analytics buckets\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .listBuckets({\n\t*     limit: 10,\n\t*     offset: 0,\n\t*     sortColumn: 'created_at',\n\t*     sortOrder: 'desc'\n\t*   })\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": [\n\t*     {\n\t*       \"name\": \"analytics-data\",\n\t*       \"type\": \"ANALYTICS\",\n\t*       \"format\": \"iceberg\",\n\t*       \"created_at\": \"2024-05-22T22:26:05.100Z\",\n\t*       \"updated_at\": \"2024-05-22T22:26:05.100Z\"\n\t*     }\n\t*   ],\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async listBuckets(options) {\n        var _this2 = this;\n        try {\n            const queryParams = new URLSearchParams();\n            if ((options === null || options === void 0 ? void 0 : options.limit) !== void 0) queryParams.set(\"limit\", options.limit.toString());\n            if ((options === null || options === void 0 ? void 0 : options.offset) !== void 0) queryParams.set(\"offset\", options.offset.toString());\n            if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n            if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n            if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n            const queryString = queryParams.toString();\n            const url = queryString ? `${_this2.url}/bucket?${queryString}` : `${_this2.url}/bucket`;\n            return {\n                data: await get(_this2.fetch, url, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Deletes an existing analytics bucket\n\t* A bucket can't be deleted with existing objects inside it\n\t* You must first empty the bucket before deletion\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName The unique identifier of the bucket you would like to delete\n\t* @returns Promise with response containing success message or error\n\t*\n\t* @example Delete analytics bucket\n\t* ```js\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .deleteBucket('analytics-data')\n\t* ```\n\t*\n\t* Response:\n\t* ```json\n\t* {\n\t*   \"data\": {\n\t*     \"message\": \"Successfully deleted\"\n\t*   },\n\t*   \"error\": null\n\t* }\n\t* ```\n\t*/ async deleteBucket(bucketName) {\n        var _this3 = this;\n        try {\n            return {\n                data: await remove(_this3.fetch, `${_this3.url}/bucket/${bucketName}`, {}, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /**\n\t* @alpha\n\t*\n\t* Get an Iceberg REST Catalog client configured for a specific analytics bucket\n\t* Use this to perform advanced table and namespace operations within the bucket\n\t* The returned client provides full access to the Apache Iceberg REST Catalog API\n\t* with the Supabase `{ data, error }` pattern for consistent error handling on all operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @param bucketName - The name of the analytics bucket (warehouse) to connect to\n\t* @returns The wrapped Iceberg catalog client\n\t* @throws {StorageError} If the bucket name is invalid\n\t*\n\t* @example Get catalog and create table\n\t* ```js\n\t* // First, create an analytics bucket\n\t* const { data: bucket, error: bucketError } = await supabase\n\t*   .storage\n\t*   .analytics\n\t*   .createBucket('analytics-data')\n\t*\n\t* // Get the Iceberg catalog for that bucket\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Create a namespace\n\t* const { error: nsError } = await catalog.createNamespace({ namespace: ['default'] })\n\t*\n\t* // Create a table with schema\n\t* const { data: tableMetadata, error: tableError } = await catalog.createTable(\n\t*   { namespace: ['default'] },\n\t*   {\n\t*     name: 'events',\n\t*     schema: {\n\t*       type: 'struct',\n\t*       fields: [\n\t*         { id: 1, name: 'id', type: 'long', required: true },\n\t*         { id: 2, name: 'timestamp', type: 'timestamp', required: true },\n\t*         { id: 3, name: 'user_id', type: 'string', required: false }\n\t*       ],\n\t*       'schema-id': 0,\n\t*       'identifier-field-ids': [1]\n\t*     },\n\t*     'partition-spec': {\n\t*       'spec-id': 0,\n\t*       fields: []\n\t*     },\n\t*     'write-order': {\n\t*       'order-id': 0,\n\t*       fields: []\n\t*     },\n\t*     properties: {\n\t*       'write.format.default': 'parquet'\n\t*     }\n\t*   }\n\t* )\n\t* ```\n\t*\n\t* @example List tables in namespace\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all tables in the default namespace\n\t* const { data: tables, error: listError } = await catalog.listTables({ namespace: ['default'] })\n\t* if (listError) {\n\t*   if (listError.isNotFound()) {\n\t*     console.log('Namespace not found')\n\t*   }\n\t*   return\n\t* }\n\t* console.log(tables) // [{ namespace: ['default'], name: 'events' }]\n\t* ```\n\t*\n\t* @example Working with namespaces\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // List all namespaces\n\t* const { data: namespaces } = await catalog.listNamespaces()\n\t*\n\t* // Create namespace with properties\n\t* await catalog.createNamespace(\n\t*   { namespace: ['production'] },\n\t*   { properties: { owner: 'data-team', env: 'prod' } }\n\t* )\n\t* ```\n\t*\n\t* @example Cleanup operations\n\t* ```js\n\t* const catalog = supabase.storage.analytics.from('analytics-data')\n\t*\n\t* // Drop table with purge option (removes all data)\n\t* const { error: dropError } = await catalog.dropTable(\n\t*   { namespace: ['default'], name: 'events' },\n\t*   { purge: true }\n\t* )\n\t*\n\t* if (dropError?.isNotFound()) {\n\t*   console.log('Table does not exist')\n\t* }\n\t*\n\t* // Drop namespace (must be empty)\n\t* await catalog.dropNamespace({ namespace: ['default'] })\n\t* ```\n\t*\n\t* @remarks\n\t* This method provides a bridge between Supabase's bucket management and the standard\n\t* Apache Iceberg REST Catalog API. The bucket name maps to the Iceberg warehouse parameter.\n\t* All authentication and configuration is handled automatically using your Supabase credentials.\n\t*\n\t* **Error Handling**: Invalid bucket names throw immediately. All catalog\n\t* operations return `{ data, error }` where errors are `IcebergError` instances from iceberg-js.\n\t* Use helper methods like `error.isNotFound()` or check `error.status` for specific error handling.\n\t* Use `.throwOnError()` on the analytics client if you prefer exceptions for catalog operations.\n\t*\n\t* **Cleanup Operations**: When using `dropTable`, the `purge: true` option permanently\n\t* deletes all table data. Without it, the table is marked as deleted but data remains.\n\t*\n\t* **Library Dependency**: The returned catalog wraps `IcebergRestCatalog` from iceberg-js.\n\t* For complete API documentation and advanced usage, refer to the\n\t* [iceberg-js documentation](https://supabase.github.io/iceberg-js/).\n\t*/ from(bucketName) {\n        var _this4 = this;\n        if (!isValidBucketName(bucketName)) throw new StorageError(\"Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.\");\n        const catalog = new iceberg_js__WEBPACK_IMPORTED_MODULE_0__.IcebergRestCatalog({\n            baseUrl: this.url,\n            catalogName: bucketName,\n            auth: {\n                type: \"custom\",\n                getHeaders: async ()=>_this4.headers\n            },\n            fetch: this.fetch\n        });\n        const shouldThrowOnError = this.shouldThrowOnError;\n        return new Proxy(catalog, {\n            get (target, prop) {\n                const value = target[prop];\n                if (typeof value !== \"function\") return value;\n                return async (...args)=>{\n                    try {\n                        return {\n                            data: await value.apply(target, args),\n                            error: null\n                        };\n                    } catch (error) {\n                        if (shouldThrowOnError) throw error;\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                };\n            }\n        });\n    }\n};\n//#endregion\n//#region src/lib/vectors/constants.ts\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${version}`,\n    \"Content-Type\": \"application/json\"\n};\n//#endregion\n//#region src/lib/vectors/errors.ts\n/**\n* Base error class for all Storage Vectors errors\n*/ var StorageVectorsError = class extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageVectorsError = true;\n        this.name = \"StorageVectorsError\";\n    }\n};\n/**\n* Type guard to check if an error is a StorageVectorsError\n* @param error - The error to check\n* @returns True if the error is a StorageVectorsError\n*/ function isStorageVectorsError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageVectorsError\" in error;\n}\n/**\n* API error returned from S3 Vectors service\n* Includes HTTP status code and service-specific error code\n*/ var StorageVectorsApiError = class extends StorageVectorsError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageVectorsApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n};\n/**\n* Unknown error that doesn't match expected error patterns\n* Wraps the original error for debugging\n*/ var StorageVectorsUnknownError = class extends StorageVectorsError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageVectorsUnknownError\";\n        this.originalError = originalError;\n    }\n};\n/**\n* Error codes specific to S3 Vectors API\n* Maps AWS service errors to application-friendly error codes\n*/ let StorageVectorsErrorCode = /* @__PURE__ */ function(StorageVectorsErrorCode$1) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode$1[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode$1[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode$1[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode$1[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n    return StorageVectorsErrorCode$1;\n}({});\n//#endregion\n//#region src/lib/vectors/helpers.ts\n/**\n* Resolves the fetch implementation to use\n* Uses custom fetch if provided, otherwise uses native fetch\n*\n* @param customFetch - Optional custom fetch implementation\n* @returns Resolved fetch function\n*/ const resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\n/**\n* Resolves the Response constructor to use\n* Returns native Response constructor\n*\n* @returns Response constructor\n*/ const resolveResponse = ()=>{\n    return Response;\n};\n/**\n* Determine if input is a plain object\n* An object is plain if it's created by either {}, new Object(), or Object.create(null)\n*\n* @param value - Value to check\n* @returns True if value is a plain object\n* @source https://github.com/sindresorhus/is-plain-obj\n*/ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) return false;\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n* Normalizes a number array to float32 format\n* Ensures all vector values are valid 32-bit floats\n*\n* @param values - Array of numbers to normalize\n* @returns Normalized float32 array\n*/ const normalizeToFloat32 = (values)=>{\n    return Array.from(new Float32Array(values));\n};\n/**\n* Validates vector dimensions match expected dimension\n* Throws error if dimensions don't match\n*\n* @param vector - Vector data to validate\n* @param expectedDimension - Expected vector dimension\n* @throws Error if dimensions don't match\n*/ const validateVectorDimension = (vector, expectedDimension)=>{\n    if (expectedDimension !== void 0 && vector.float32.length !== expectedDimension) throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);\n};\n//#endregion\n//#region src/lib/vectors/fetch.ts\n/**\n* Extracts error message from various error response formats\n* @param err - Error object from API\n* @returns Human-readable error message\n*/ const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n* Handles fetch errors and converts them to StorageVectors error types\n* @param error - The error caught from fetch\n* @param reject - Promise rejection function\n* @param options - Fetch options that may affect error handling\n*/ const handleError = async (error, reject, options)=>{\n    if (error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\" && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n        const status = error.status || 500;\n        const responseError = error;\n        if (typeof responseError.json === \"function\") responseError.json().then((err)=>{\n            const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n            reject(new StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n        }).catch(()=>{\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        });\n        else {\n            const statusCode = status + \"\";\n            reject(new StorageVectorsApiError(responseError.statusText || `HTTP ${status} error`, status, statusCode));\n        }\n    } else reject(new StorageVectorsUnknownError(_getErrorMessage(error), error));\n};\n/**\n* Builds request parameters for fetch calls\n* @param method - HTTP method\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters like AbortSignal\n* @param body - Request body (will be JSON stringified if plain object)\n* @returns Complete fetch request parameters\n*/ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) return params;\n    if (isPlainObject(body)) {\n        params.headers = _objectSpread2({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else params.body = body;\n    return _objectSpread2(_objectSpread2({}, params), parameters);\n};\n/**\n* Internal request handler that wraps fetch with error handling\n* @param fetcher - Fetch function to use\n* @param method - HTTP method\n* @param url - Request URL\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @param body - Request body\n* @returns Promise with parsed response or error\n*/ async function _handleRequest(fetcher, method, url, options, parameters, body) {\n    return new Promise((resolve, reject)=>{\n        fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n            if (!result.ok) throw result;\n            if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n            const contentType = result.headers.get(\"content-type\");\n            if (!contentType || !contentType.includes(\"application/json\")) return {};\n            return result.json();\n        }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n    });\n}\n/**\n* Performs a POST request\n* @param fetcher - Fetch function to use\n* @param url - Request URL\n* @param body - Request body to be JSON stringified\n* @param options - Custom fetch options\n* @param parameters - Additional fetch parameters\n* @returns Promise with parsed response\n*/ async function post(fetcher, url, body, options, parameters) {\n    return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n}\n//#endregion\n//#region src/lib/vectors/VectorIndexApi.ts\n/**\n* @hidden\n* Base implementation for vector index operations.\n* Use {@link VectorBucketScope} via `supabase.storage.vectors.from('bucket')` instead.\n*/ var VectorIndexApi = class {\n    /** Creates a new VectorIndexApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector index within a bucket */ async createIndex(options) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateIndex`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector index */ async getIndex(vectorBucketName, indexName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector indexes within a bucket with optional filtering and pagination */ async listIndexes(options) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListIndexes`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector index and all its data */ async deleteIndex(vectorBucketName, indexName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorDataApi.ts\n/**\n* @hidden\n* Base implementation for vector data operations.\n* Use {@link VectorIndexScope} via `supabase.storage.vectors.from('bucket').index('idx')` instead.\n*/ var VectorDataApi = class {\n    /** Creates a new VectorDataApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Inserts or updates vectors in batch (1-500 per request) */ async putVectors(options) {\n        var _this = this;\n        try {\n            if (options.vectors.length < 1 || options.vectors.length > 500) throw new Error(\"Vector batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this.fetch, `${_this.url}/PutVectors`, options, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves vectors by their keys in batch */ async getVectors(options) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectors`, options, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vectors in an index with pagination */ async listVectors(options) {\n        var _this3 = this;\n        try {\n            if (options.segmentCount !== void 0) {\n                if (options.segmentCount < 1 || options.segmentCount > 16) throw new Error(\"segmentCount must be between 1 and 16\");\n                if (options.segmentIndex !== void 0) {\n                    if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n                }\n            }\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectors`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Queries for similar vectors using approximate nearest neighbor search */ async queryVectors(options) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/QueryVectors`, options, {\n                    headers: _this4.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes vectors by their keys in batch (1-500 per request) */ async deleteVectors(options) {\n        var _this5 = this;\n        try {\n            if (options.keys.length < 1 || options.keys.length > 500) throw new Error(\"Keys batch size must be between 1 and 500 items\");\n            return {\n                data: await post(_this5.fetch, `${_this5.url}/DeleteVectors`, options, {\n                    headers: _this5.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this5.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/VectorBucketApi.ts\n/**\n* @hidden\n* Base implementation for vector bucket operations.\n* Use {@link StorageVectorsClient} via `supabase.storage.vectors` instead.\n*/ var VectorBucketApi = class {\n    /** Creates a new VectorBucketApi instance */ constructor(url, headers = {}, fetch$1){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = _objectSpread2(_objectSpread2({}, DEFAULT_HEADERS), headers);\n        this.fetch = resolveFetch(fetch$1);\n    }\n    /** Enable throwing errors instead of returning them in the response */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /** Creates a new vector bucket */ async createBucket(vectorBucketName) {\n        var _this = this;\n        try {\n            return {\n                data: await post(_this.fetch, `${_this.url}/CreateVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Retrieves metadata for a specific vector bucket */ async getBucket(vectorBucketName) {\n        var _this2 = this;\n        try {\n            return {\n                data: await post(_this2.fetch, `${_this2.url}/GetVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this2.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this2.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Lists vector buckets with optional filtering and pagination */ async listBuckets(options = {}) {\n        var _this3 = this;\n        try {\n            return {\n                data: await post(_this3.fetch, `${_this3.url}/ListVectorBuckets`, options, {\n                    headers: _this3.headers\n                }),\n                error: null\n            };\n        } catch (error) {\n            if (_this3.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n    /** Deletes a vector bucket (must be empty first) */ async deleteBucket(vectorBucketName) {\n        var _this4 = this;\n        try {\n            return {\n                data: await post(_this4.fetch, `${_this4.url}/DeleteVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: _this4.headers\n                }) || {},\n                error: null\n            };\n        } catch (error) {\n            if (_this4.shouldThrowOnError) throw error;\n            if (isStorageVectorsError(error)) return {\n                data: null,\n                error\n            };\n            throw error;\n        }\n    }\n};\n//#endregion\n//#region src/lib/vectors/StorageVectorsClient.ts\n/**\n*\n* @alpha\n*\n* Main client for interacting with S3 Vectors API\n* Provides access to bucket, index, and vector data operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*\n* **Usage Patterns:**\n*\n* ```typescript\n* const { data, error } = await supabase\n*  .storage\n*  .vectors\n*  .createBucket('embeddings-prod')\n*\n* // Access index operations via buckets\n* const bucket = supabase.storage.vectors.from('embeddings-prod')\n* await bucket.createIndex({\n*   indexName: 'documents',\n*   dataType: 'float32',\n*   dimension: 1536,\n*   distanceMetric: 'cosine'\n* })\n*\n* // Access vector operations via index\n* const index = bucket.index('documents')\n* await index.putVectors({\n*   vectors: [\n*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n*   ]\n* })\n*\n* // Query similar vectors\n* const { data } = await index.queryVectors({\n*   queryVector: { float32: [...] },\n*   topK: 5,\n*   returnDistance: true\n* })\n* ```\n*/ var StorageVectorsClient = class extends VectorBucketApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a StorageVectorsClient that can manage buckets, indexes, and vectors.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param url - Base URL of the Storage Vectors REST API.\n\t* @param options.headers - Optional headers (for example `Authorization`) applied to every request.\n\t* @param options.fetch - Optional custom `fetch` implementation for non-browser runtimes.\n\t*\n\t* @example\n\t* ```typescript\n\t* const client = new StorageVectorsClient(url, options)\n\t* ```\n\t*/ constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific vector bucket\n\t* Returns a scoped client for index and vector operations within the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Bucket-scoped client with index and vector operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector bucket\n\t* Vector buckets are containers for vector indexes and their data\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Unique name for the vector bucket\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .createBucket('embeddings-prod')\n\t* ```\n\t*/ async createBucket(vectorBucketName) {\n        var _superprop_getCreateBucket = ()=>super.createBucket, _this = this;\n        return _superprop_getCreateBucket().call(_this, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific vector bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket\n\t* @returns Promise with bucket metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .getBucket('embeddings-prod')\n\t*\n\t* console.log('Bucket created:', data?.vectorBucket.creationTime)\n\t* ```\n\t*/ async getBucket(vectorBucketName) {\n        var _superprop_getGetBucket = ()=>super.getBucket, _this2 = this;\n        return _superprop_getGetBucket().call(_this2, vectorBucketName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists all vector buckets with optional filtering and pagination\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Optional filters (prefix, maxResults, nextToken)\n\t* @returns Promise with list of buckets or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .listBuckets({ prefix: 'embeddings-' })\n\t*\n\t* data?.vectorBuckets.forEach(bucket => {\n\t*   console.log(bucket.vectorBucketName)\n\t* })\n\t* ```\n\t*/ async listBuckets(options = {}) {\n        var _superprop_getListBuckets = ()=>super.listBuckets, _this3 = this;\n        return _superprop_getListBuckets().call(_this3, options);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes a vector bucket (bucket must be empty)\n\t* All indexes must be deleted before deleting the bucket\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param vectorBucketName - Name of the vector bucket to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const { data, error } = await supabase\n\t*   .storage\n\t*   .vectors\n\t*   .deleteBucket('embeddings-old')\n\t* ```\n\t*/ async deleteBucket(vectorBucketName) {\n        var _superprop_getDeleteBucket = ()=>super.deleteBucket, _this4 = this;\n        return _superprop_getDeleteBucket().call(_this4, vectorBucketName);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector bucket\n* Provides index management and access to vector operations\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorBucketScope = class extends VectorIndexApi {\n    /**\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all index operations to the provided bucket.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a new vector index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Index configuration (vectorBucketName is automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.createIndex({\n\t*   indexName: 'documents-openai',\n\t*   dataType: 'float32',\n\t*   dimension: 1536,\n\t*   distanceMetric: 'cosine',\n\t*   metadataConfiguration: {\n\t*     nonFilterableMetadataKeys: ['raw_text']\n\t*   }\n\t* })\n\t* ```\n\t*/ async createIndex(options) {\n        var _superprop_getCreateIndex = ()=>super.createIndex, _this5 = this;\n        return _superprop_getCreateIndex().call(_this5, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this5.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists indexes in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (vectorBucketName is automatically set)\n\t* @returns Promise with response containing indexes array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n\t* ```\n\t*/ async listIndexes(options = {}) {\n        var _superprop_getListIndexes = ()=>super.listIndexes, _this6 = this;\n        return _superprop_getListIndexes().call(_this6, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this6.vectorBucketName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves metadata for a specific index in this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to retrieve\n\t* @returns Promise with index metadata or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* const { data } = await bucket.getIndex('documents-openai')\n\t* console.log('Dimension:', data?.index.dimension)\n\t* ```\n\t*/ async getIndex(indexName) {\n        var _superprop_getGetIndex = ()=>super.getIndex, _this7 = this;\n        return _superprop_getGetIndex().call(_this7, _this7.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes an index from this bucket\n\t* Convenience method that automatically includes the bucket name\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index to delete\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const bucket = supabase.storage.vectors.from('embeddings-prod')\n\t* await bucket.deleteIndex('old-index')\n\t* ```\n\t*/ async deleteIndex(indexName) {\n        var _superprop_getDeleteIndex = ()=>super.deleteIndex, _this8 = this;\n        return _superprop_getDeleteIndex().call(_this8, _this8.vectorBucketName, indexName);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access operations for a specific index within this bucket\n\t* Returns a scoped client for vector data operations\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param indexName - Name of the index\n\t* @returns Index-scoped client with vector data operations\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t*\n\t* // Insert vectors\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n\t*   ]\n\t* })\n\t*\n\t* // Query similar vectors\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [...] },\n\t*   topK: 5\n\t* })\n\t* ```\n\t*/ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n};\n/**\n*\n* @alpha\n*\n* Scoped client for operations within a specific vector index\n* Provides vector data operations (put, get, list, query, delete)\n*\n* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n*/ var VectorIndexScope = class extends VectorDataApi {\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Creates a helper that automatically scopes all vector operations to the provided bucket/index names.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* ```\n\t*/ constructor(url, headers, vectorBucketName, indexName, fetch$1){\n        super(url, headers, fetch$1);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Inserts or updates vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector insertion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.putVectors({\n\t*   vectors: [\n\t*     {\n\t*       key: 'doc-1',\n\t*       data: { float32: [0.1, 0.2, ...] },\n\t*       metadata: { title: 'Introduction', page: 1 }\n\t*     }\n\t*   ]\n\t* })\n\t* ```\n\t*/ async putVectors(options) {\n        var _superprop_getPutVectors = ()=>super.putVectors, _this9 = this;\n        return _superprop_getPutVectors().call(_this9, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this9.vectorBucketName,\n            indexName: _this9.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Retrieves vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Vector retrieval options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.getVectors({\n\t*   keys: ['doc-1', 'doc-2'],\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async getVectors(options) {\n        var _superprop_getGetVectors = ()=>super.getVectors, _this10 = this;\n        return _superprop_getGetVectors().call(_this10, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this10.vectorBucketName,\n            indexName: _this10.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Lists vectors in this index with pagination\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Listing options (bucket and index names automatically set)\n\t* @returns Promise with response containing vectors array and pagination token or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.listVectors({\n\t*   maxResults: 500,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async listVectors(options = {}) {\n        var _superprop_getListVectors = ()=>super.listVectors, _this11 = this;\n        return _superprop_getListVectors().call(_this11, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this11.vectorBucketName,\n            indexName: _this11.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Queries for similar vectors in this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Query options (bucket and index names automatically set)\n\t* @returns Promise with response containing matches array of similar vectors ordered by distance or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* const { data } = await index.queryVectors({\n\t*   queryVector: { float32: [0.1, 0.2, ...] },\n\t*   topK: 5,\n\t*   filter: { category: 'technical' },\n\t*   returnDistance: true,\n\t*   returnMetadata: true\n\t* })\n\t* ```\n\t*/ async queryVectors(options) {\n        var _superprop_getQueryVectors = ()=>super.queryVectors, _this12 = this;\n        return _superprop_getQueryVectors().call(_this12, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this12.vectorBucketName,\n            indexName: _this12.indexName\n        }));\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Deletes vectors by keys from this index\n\t* Convenience method that automatically includes bucket and index names\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @param options - Deletion options (bucket and index names automatically set)\n\t* @returns Promise with empty response on success or error\n\t*\n\t* @example\n\t* ```typescript\n\t* const index = supabase.storage.vectors.from('embeddings-prod').index('documents-openai')\n\t* await index.deleteVectors({\n\t*   keys: ['doc-1', 'doc-2', 'doc-3']\n\t* })\n\t* ```\n\t*/ async deleteVectors(options) {\n        var _superprop_getDeleteVectors = ()=>super.deleteVectors, _this13 = this;\n        return _superprop_getDeleteVectors().call(_this13, _objectSpread2(_objectSpread2({}, options), {}, {\n            vectorBucketName: _this13.vectorBucketName,\n            indexName: _this13.indexName\n        }));\n    }\n};\n//#endregion\n//#region src/StorageClient.ts\nvar StorageClient = class extends StorageBucketApi {\n    /**\n\t* Creates a client for Storage buckets, files, analytics, and vectors.\n\t*\n\t* @category File Buckets\n\t* @example\n\t* ```ts\n\t* import { StorageClient } from '@supabase/storage-js'\n\t*\n\t* const storage = new StorageClient('https://xyzcompany.supabase.co/storage/v1', {\n\t*   apikey: 'public-anon-key',\n\t* })\n\t* const avatars = storage.from('avatars')\n\t* ```\n\t*/ constructor(url, headers = {}, fetch$1, opts){\n        super(url, headers, fetch$1, opts);\n    }\n    /**\n\t* Perform file operation in a bucket.\n\t*\n\t* @category File Buckets\n\t* @param id The bucket id to operate on.\n\t*\n\t* @example\n\t* ```typescript\n\t* const avatars = supabase.storage.from('avatars')\n\t* ```\n\t*/ from(id) {\n        return new StorageFileApi(this.url, this.headers, id, this.fetch);\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access vector storage operations.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Vector Buckets\n\t* @returns A StorageVectorsClient instance configured with the current storage settings.\n\t*/ get vectors() {\n        return new StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n\t*\n\t* @alpha\n\t*\n\t* Access analytics storage operations using Iceberg tables.\n\t*\n\t* **Public alpha:** This API is part of a public alpha release and may not be available to your account type.\n\t*\n\t* @category Analytics Buckets\n\t* @returns A StorageAnalyticsClient instance configured with the current storage settings.\n\t*/ get analytics() {\n        return new StorageAnalyticsClient(this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n};\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0Q7QUFFaEQsMkJBQTJCO0FBQzNCLElBQUlDLGVBQWUsY0FBY0M7SUFDaENDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLElBQUksR0FBRztJQUNiO0FBQ0Q7QUFDQSxTQUFTQyxlQUFlQyxLQUFLO0lBQzVCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUM3RTtBQUNBLElBQUlDLGtCQUFrQixjQUFjUjtJQUNuQ0UsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUN4QyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNSLE9BQU87WUFDTk4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM1QjtJQUNEO0FBQ0Q7QUFDQSxJQUFJRSxzQkFBc0IsY0FBY1o7SUFDdkNFLFlBQVlDLE9BQU8sRUFBRVUsYUFBYSxDQUFFO1FBQ25DLEtBQUssQ0FBQ1Y7UUFDTixJQUFJLENBQUNFLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ1EsYUFBYSxHQUFHQTtJQUN0QjtBQUNEO0FBRUEsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixNQUFNQyxpQkFBaUIsQ0FBQ0M7SUFDdkIsSUFBSUEsYUFBYSxPQUFPLENBQUMsR0FBR0MsT0FBU0QsZUFBZUM7SUFDcEQsT0FBTyxD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O1FBQzNFLE9BQU8yRyw4QkFBOEJwUSxJQUFJLENBQUN5SixTQUFTdkksZUFBZUEsZUFBZSxDQUFDLEdBQUdhLFVBQVUsQ0FBQyxHQUFHO1lBQ2xHdU0sa0JBQWtCN0UsUUFBUTZFLGdCQUFnQjtZQUMxQ0MsV0FBVzlFLFFBQVE4RSxTQUFTO1FBQzdCO0lBQ0Q7QUFDRDtBQUVBLFlBQVk7QUFDWiw4QkFBOEI7QUFDOUIsSUFBSThCLGdCQUFnQixjQUFjOUY7SUFDakM7Ozs7Ozs7Ozs7Ozs7Q0FhQSxHQUNBN04sWUFBWW1HLEdBQUcsRUFBRUosVUFBVSxDQUFDLENBQUMsRUFBRXlDLE9BQU8sRUFBRXNGLElBQUksQ0FBRTtRQUM3QyxLQUFLLENBQUMzSCxLQUFLSixTQUFTeUMsU0FBU3NGO0lBQzlCO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBVixLQUFLekQsRUFBRSxFQUFFO1FBQ1IsT0FBTyxJQUFJckIsZUFBZSxJQUFJLENBQUNuQyxHQUFHLEVBQUUsSUFBSSxDQUFDSixPQUFPLEVBQUU0RCxJQUFJLElBQUksQ0FBQzVJLEtBQUs7SUFDakU7SUFDQTs7Ozs7Ozs7OztDQVVBLEdBQ0EsSUFBSW1SLFVBQVU7UUFDYixPQUFPLElBQUlRLHFCQUFxQixJQUFJLENBQUN2TSxHQUFHLEdBQUcsV0FBVztZQUNyREosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJoRixPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNsQjtJQUNEO0lBQ0E7Ozs7Ozs7Ozs7Q0FVQSxHQUNBLElBQUk2UyxZQUFZO1FBQ2YsT0FBTyxJQUFJdEUsdUJBQXVCLElBQUksQ0FBQ25KLEdBQUcsR0FBRyxZQUFZLElBQUksQ0FBQ0osT0FBTyxFQUFFLElBQUksQ0FBQ2hGLEtBQUs7SUFDbEY7QUFDRDtBQUVBLFlBQVk7QUFDd2EsQ0FDcGIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2VkZGluZy1ndWVzdC1hcHAvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9pbmRleC5tanM/ZWIzNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJY2ViZXJnUmVzdENhdGFsb2cgfSBmcm9tIFwiaWNlYmVyZy1qc1wiO1xuXG4vLyNyZWdpb24gc3JjL2xpYi9lcnJvcnMudHNcbnZhciBTdG9yYWdlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMuX19pc1N0b3JhZ2VFcnJvciA9IHRydWU7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlRXJyb3JcIjtcblx0fVxufTtcbmZ1bmN0aW9uIGlzU3RvcmFnZUVycm9yKGVycm9yKSB7XG5cdHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJfX2lzU3RvcmFnZUVycm9yXCIgaW4gZXJyb3I7XG59XG52YXIgU3RvcmFnZUFwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUpIHtcblx0XHRzdXBlcihtZXNzYWdlKTtcblx0XHR0aGlzLm5hbWUgPSBcIlN0b3JhZ2VBcGlFcnJvclwiO1xuXHRcdHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdH1cblx0dG9KU09OKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiB0aGlzLm5hbWUsXG5cdFx0XHRtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG5cdFx0XHRzdGF0dXM6IHRoaXMuc3RhdHVzLFxuXHRcdFx0c3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlXG5cdFx0fTtcblx0fVxufTtcbnZhciBTdG9yYWdlVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlVW5rbm93bkVycm9yXCI7XG5cdFx0dGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9oZWxwZXJzLnRzXG5jb25zdCByZXNvbHZlRmV0Y2gkMSA9IChjdXN0b21GZXRjaCkgPT4ge1xuXHRpZiAoY3VzdG9tRmV0Y2gpIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG5cdHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG59O1xuY29uc3QgcmVzb2x2ZVJlc3BvbnNlJDEgPSAoKSA9PiB7XG5cdHJldHVybiBSZXNwb25zZTtcbn07XG5jb25zdCByZWN1cnNpdmVUb0NhbWVsID0gKGl0ZW0pID0+IHtcblx0aWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHJldHVybiBpdGVtLm1hcCgoZWwpID0+IHJlY3Vyc2l2ZVRvQ2FtZWwoZWwpKTtcblx0ZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIiB8fCBpdGVtICE9PSBPYmplY3QoaXRlbSkpIHJldHVybiBpdGVtO1xuXHRjb25zdCByZXN1bHQgPSB7fTtcblx0T2JqZWN0LmVudHJpZXMoaXRlbSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG5cdFx0Y29uc3QgbmV3S2V5ID0ga2V5LnJlcGxhY2UoLyhbLV9dW2Etel0pL2dpLCAoYykgPT4gYy50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoL1stX10vZywgXCJcIikpO1xuXHRcdHJlc3VsdFtuZXdLZXldID0gcmVjdXJzaXZlVG9DYW1lbCh2YWx1ZSk7XG5cdH0pO1xuXHRyZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuKiBEZXRlcm1pbmUgaWYgaW5wdXQgaXMgYSBwbGFpbiBvYmplY3RcbiogQW4gb2JqZWN0IGlzIHBsYWluIGlmIGl0J3MgY3JlYXRlZCBieSBlaXRoZXIge30sIG5ldyBPYmplY3QoKSwgb3IgT2JqZWN0LmNyZWF0ZShudWxsKVxuKiBzb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqXG4qL1xuY29uc3QgaXNQbGFpbk9iamVjdCQxID0gKHZhbHVlKSA9PiB7XG5cdGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblx0cmV0dXJuIChwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJiAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpO1xufTtcbi8qKlxuKiBWYWxpZGF0ZXMgaWYgYSBnaXZlbiBidWNrZXQgbmFtZSBpcyB2YWxpZCBhY2NvcmRpbmcgdG8gU3VwYWJhc2UgU3RvcmFnZSBBUEkgcnVsZXNcbiogTWlycm9ycyBiYWNrZW5kIHZhbGlkYXRpb24gZnJvbTogc3RvcmFnZS9zcmMvc3RvcmFnZS9saW1pdHMudHM6aXNWYWxpZEJ1Y2tldE5hbWUoKVxuKlxuKiBSdWxlczpcbiogLSBMZW5ndGg6IDEtMTAwIGNoYXJhY3RlcnNcbiogLSBBbGxvd2VkIGNoYXJhY3RlcnM6IGFscGhhbnVtZXJpYyAoYS16LCBBLVosIDAtOSksIHVuZGVyc2NvcmUgKF8pLCBhbmQgc2FmZSBzcGVjaWFsIGNoYXJhY3RlcnNcbiogLSBTYWZlIHNwZWNpYWwgY2hhcmFjdGVyczogISAtIC4gKiAnICggKSBzcGFjZSAmICQgQCA9IDsgOiArICwgP1xuKiAtIEZvcmJpZGRlbjogcGF0aCBzZXBhcmF0b3JzICgvLCBcXCksIHBhdGggdHJhdmVyc2FsICguLiksIGxlYWRpbmcvdHJhaWxpbmcgd2hpdGVzcGFjZVxuKlxuKiBBV1MgUzMgUmVmZXJlbmNlOiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQW1hem9uUzMvbGF0ZXN0L3VzZXJndWlkZS9vYmplY3Qta2V5cy5odG1sXG4qXG4qIEBwYXJhbSBidWNrZXROYW1lIC0gVGhlIGJ1Y2tldCBuYW1lIHRvIHZhbGlkYXRlXG4qIEByZXR1cm5zIHRydWUgaWYgdmFsaWQsIGZhbHNlIG90aGVyd2lzZVxuKi9cbmNvbnN0IGlzVmFsaWRCdWNrZXROYW1lID0gKGJ1Y2tldE5hbWUpID0+IHtcblx0aWYgKCFidWNrZXROYW1lIHx8IHR5cGVvZiBidWNrZXROYW1lICE9PSBcInN0cmluZ1wiKSByZXR1cm4gZmFsc2U7XG5cdGlmIChidWNrZXROYW1lLmxlbmd0aCA9PT0gMCB8fCBidWNrZXROYW1lLmxlbmd0aCA+IDEwMCkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoYnVja2V0TmFtZS50cmltKCkgIT09IGJ1Y2tldE5hbWUpIHJldHVybiBmYWxzZTtcblx0aWYgKGJ1Y2tldE5hbWUuaW5jbHVkZXMoXCIvXCIpIHx8IGJ1Y2tldE5hbWUuaW5jbHVkZXMoXCJcXFxcXCIpKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiAvXltcXHchLlxcKicoKSAmJEA9OzorLD8tXSskLy50ZXN0KGJ1Y2tldE5hbWUpO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3R5cGVvZi5qc1xuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG5cdFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblx0cmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbihvJDEpIHtcblx0XHRyZXR1cm4gdHlwZW9mIG8kMTtcblx0fSA6IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiBvJDEgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgbyQxLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyQxICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvJDE7XG5cdH0sIF90eXBlb2Yobyk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy90b1ByaW1pdGl2ZS5qc1xuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuXHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcblx0dmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG5cdGlmICh2b2lkIDAgIT09IGUpIHtcblx0XHR2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcblx0XHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG5cdH1cblx0cmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanNcbmZ1bmN0aW9uIHRvUHJvcGVydHlLZXkodCkge1xuXHR2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuXHRyZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanNcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG5cdHJldHVybiAociA9IHRvUHJvcGVydHlLZXkocikpIGluIGUgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuXHRcdHZhbHVlOiB0LFxuXHRcdGVudW1lcmFibGU6ICEwLFxuXHRcdGNvbmZpZ3VyYWJsZTogITAsXG5cdFx0d3JpdGFibGU6ICEwXG5cdH0pIDogZVtyXSA9IHQsIGU7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcblx0dmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcblx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHR2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG5cdFx0ciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgciQxKS5lbnVtZXJhYmxlO1xuXHRcdH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuXHR9XG5cdHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuXHRmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuXHRcdHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcblx0XHRyICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdF9kZWZpbmVQcm9wZXJ0eShlLCByJDEsIHRbciQxXSk7XG5cdFx0fSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIkMSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByJDEpKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9mZXRjaC50c1xuY29uc3QgX2dldEVycm9yTWVzc2FnZSQxID0gKGVycikgPT4ge1xuXHR2YXIgX2VyciRlcnJvcjtcblx0cmV0dXJuIGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8ICh0eXBlb2YgZXJyLmVycm9yID09PSBcInN0cmluZ1wiID8gZXJyLmVycm9yIDogKF9lcnIkZXJyb3IgPSBlcnIuZXJyb3IpID09PSBudWxsIHx8IF9lcnIkZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lcnIkZXJyb3IubWVzc2FnZSkgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbn07XG5jb25zdCBoYW5kbGVFcnJvciQxID0gYXN5bmMgKGVycm9yLCByZWplY3QsIG9wdGlvbnMpID0+IHtcblx0aWYgKGVycm9yIGluc3RhbmNlb2YgYXdhaXQgcmVzb2x2ZVJlc3BvbnNlJDEoKSAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkgZXJyb3IuanNvbigpLnRoZW4oKGVycikgPT4ge1xuXHRcdGNvbnN0IHN0YXR1cyA9IGVycm9yLnN0YXR1cyB8fCA1MDA7XG5cdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuc3RhdHVzQ29kZSkgfHwgc3RhdHVzICsgXCJcIjtcblx0XHRyZWplY3QobmV3IFN0b3JhZ2VBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlJDEoZXJyKSwgc3RhdHVzLCBzdGF0dXNDb2RlKSk7XG5cdH0pLmNhdGNoKChlcnIpID0+IHtcblx0XHRyZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZSQxKGVyciksIGVycikpO1xuXHR9KTtcblx0ZWxzZSByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZSQxKGVycm9yKSwgZXJyb3IpKTtcbn07XG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyQxID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuXHRjb25zdCBwYXJhbXMgPSB7XG5cdFx0bWV0aG9kLFxuXHRcdGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge31cblx0fTtcblx0aWYgKG1ldGhvZCA9PT0gXCJHRVRcIiB8fCAhYm9keSkgcmV0dXJuIHBhcmFtcztcblx0aWYgKGlzUGxhaW5PYmplY3QkMShib2R5KSkge1xuXHRcdHBhcmFtcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG5cdFx0cGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcblx0fSBlbHNlIHBhcmFtcy5ib2R5ID0gYm9keTtcblx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpIHBhcmFtcy5kdXBsZXggPSBvcHRpb25zLmR1cGxleDtcblx0cmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXJhbXMpLCBwYXJhbWV0ZXJzKTtcbn07XG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0ZmV0Y2hlcih1cmwsIF9nZXRSZXF1ZXN0UGFyYW1zJDEobWV0aG9kLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSkudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0O1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5qc29uKCk7XG5cdFx0fSkudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSkuY2F0Y2goKGVycm9yKSA9PiBoYW5kbGVFcnJvciQxKGVycm9yLCByZWplY3QsIG9wdGlvbnMpKTtcblx0fSk7XG59XG5hc3luYyBmdW5jdGlvbiBnZXQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiR0VUXCIsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycyk7XG59XG5hc3luYyBmdW5jdGlvbiBwb3N0JDEoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdCQxKGZldGNoZXIsIFwiUE9TVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcHV0KGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRyZXR1cm4gX2hhbmRsZVJlcXVlc3QkMShmZXRjaGVyLCBcIlBVVFwiLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xufVxuYXN5bmMgZnVuY3Rpb24gaGVhZChmZXRjaGVyLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0JDEoZmV0Y2hlciwgXCJIRUFEXCIsIHVybCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyBub1Jlc29sdmVKc29uOiB0cnVlIH0pLCBwYXJhbWV0ZXJzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZShmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcblx0cmV0dXJuIF9oYW5kbGVSZXF1ZXN0JDEoZmV0Y2hlciwgXCJERUxFVEVcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3BhY2thZ2VzL1N0cmVhbURvd25sb2FkQnVpbGRlci50c1xudmFyIFN0cmVhbURvd25sb2FkQnVpbGRlciA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IoZG93bmxvYWRGbiwgc2hvdWxkVGhyb3dPbkVycm9yKSB7XG5cdFx0dGhpcy5kb3dubG9hZEZuID0gZG93bmxvYWRGbjtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHNob3VsZFRocm93T25FcnJvcjtcblx0fVxuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGFzeW5jIGV4ZWN1dGUoKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogKGF3YWl0IF90aGlzLmRvd25sb2FkRm4oKSkuYm9keSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9CbG9iRG93bmxvYWRCdWlsZGVyLnRzXG5sZXQgX1N5bWJvbCR0b1N0cmluZ1RhZztcbl9TeW1ib2wkdG9TdHJpbmdUYWcgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG52YXIgQmxvYkRvd25sb2FkQnVpbGRlciA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IoZG93bmxvYWRGbiwgc2hvdWxkVGhyb3dPbkVycm9yKSB7XG5cdFx0dGhpcy5kb3dubG9hZEZuID0gZG93bmxvYWRGbjtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHNob3VsZFRocm93T25FcnJvcjtcblx0XHR0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWddID0gXCJCbG9iRG93bmxvYWRCdWlsZGVyXCI7XG5cdFx0dGhpcy5wcm9taXNlID0gbnVsbDtcblx0fVxuXHRhc1N0cmVhbSgpIHtcblx0XHRyZXR1cm4gbmV3IFN0cmVhbURvd25sb2FkQnVpbGRlcih0aGlzLmRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcblx0fVxuXHR0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UHJvbWlzZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuXHR9XG5cdGNhdGNoKG9ucmVqZWN0ZWQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQcm9taXNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG5cdH1cblx0ZmluYWxseShvbmZpbmFsbHkpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRQcm9taXNlKCkuZmluYWxseShvbmZpbmFsbHkpO1xuXHR9XG5cdGdldFByb21pc2UoKSB7XG5cdFx0aWYgKCF0aGlzLnByb21pc2UpIHRoaXMucHJvbWlzZSA9IHRoaXMuZXhlY3V0ZSgpO1xuXHRcdHJldHVybiB0aGlzLnByb21pc2U7XG5cdH1cblx0YXN5bmMgZXhlY3V0ZSgpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCAoYXdhaXQgX3RoaXMuZG93bmxvYWRGbigpKS5ibG9iKCksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkudHNcbmNvbnN0IERFRkFVTFRfU0VBUkNIX09QVElPTlMgPSB7XG5cdGxpbWl0OiAxMDAsXG5cdG9mZnNldDogMCxcblx0c29ydEJ5OiB7XG5cdFx0Y29sdW1uOiBcIm5hbWVcIixcblx0XHRvcmRlcjogXCJhc2NcIlxuXHR9XG59O1xuY29uc3QgREVGQVVMVF9GSUxFX09QVElPTlMgPSB7XG5cdGNhY2hlQ29udHJvbDogXCIzNjAwXCIsXG5cdGNvbnRlbnRUeXBlOiBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiLFxuXHR1cHNlcnQ6IGZhbHNlXG59O1xudmFyIFN0b3JhZ2VGaWxlQXBpID0gY2xhc3Mge1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgYnVja2V0SWQsIGZldGNoJDEpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMudXJsID0gdXJsO1xuXHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0dGhpcy5idWNrZXRJZCA9IGJ1Y2tldElkO1xuXHRcdHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2gkMShmZXRjaCQxKTtcblx0fVxuXHQvKipcblx0KiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0uXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqXG5cdCogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0IG9yIHJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuXHQqXG5cdCogQHBhcmFtIG1ldGhvZCBIVFRQIG1ldGhvZC5cblx0KiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuXHQqL1xuXHRhc3luYyB1cGxvYWRPclVwZGF0ZShtZXRob2QsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGxldCBib2R5O1xuXHRcdFx0Y29uc3Qgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0ZJTEVfT1BUSU9OUyksIGZpbGVPcHRpb25zKTtcblx0XHRcdGxldCBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF90aGlzLmhlYWRlcnMpLCBtZXRob2QgPT09IFwiUE9TVFwiICYmIHsgXCJ4LXVwc2VydFwiOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuXHRcdFx0Y29uc3QgbWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhO1xuXHRcdFx0aWYgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgQmxvYikge1xuXHRcdFx0XHRib2R5ID0gbmV3IEZvcm1EYXRhKCk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiY2FjaGVDb250cm9sXCIsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcblx0XHRcdFx0aWYgKG1ldGFkYXRhKSBib2R5LmFwcGVuZChcIm1ldGFkYXRhXCIsIF90aGlzLmVuY29kZU1ldGFkYXRhKG1ldGFkYXRhKSk7XG5cdFx0XHRcdGJvZHkuYXBwZW5kKFwiXCIsIGZpbGVCb2R5KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcblx0XHRcdFx0Ym9keSA9IGZpbGVCb2R5O1xuXHRcdFx0XHRpZiAoIWJvZHkuaGFzKFwiY2FjaGVDb250cm9sXCIpKSBib2R5LmFwcGVuZChcImNhY2hlQ29udHJvbFwiLCBvcHRpb25zLmNhY2hlQ29udHJvbCk7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSAmJiAhYm9keS5oYXMoXCJtZXRhZGF0YVwiKSkgYm9keS5hcHBlbmQoXCJtZXRhZGF0YVwiLCBfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ym9keSA9IGZpbGVCb2R5O1xuXHRcdFx0XHRoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcblx0XHRcdFx0aGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG5cdFx0XHRcdGlmIChtZXRhZGF0YSkgaGVhZGVyc1tcIngtbWV0YWRhdGFcIl0gPSBfdGhpcy50b0Jhc2U2NChfdGhpcy5lbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkpO1xuXHRcdFx0XHRpZiAoKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgYm9keSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBcInBpcGVcIiBpbiBib2R5ICYmIHR5cGVvZiBib2R5LnBpcGUgPT09IFwiZnVuY3Rpb25cIikgJiYgIW9wdGlvbnMuZHVwbGV4KSBvcHRpb25zLmR1cGxleCA9IFwiaGFsZlwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpbGVPcHRpb25zID09PSBudWxsIHx8IGZpbGVPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlT3B0aW9ucy5oZWFkZXJzKSBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGhlYWRlcnMpLCBmaWxlT3B0aW9ucy5oZWFkZXJzKTtcblx0XHRcdGNvbnN0IGNsZWFuUGF0aCA9IF90aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG5cdFx0XHRjb25zdCBfcGF0aCA9IF90aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKTtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCAobWV0aG9kID09IFwiUFVUXCIgPyBwdXQgOiBwb3N0JDEpKF90aGlzLmZldGNoLCBgJHtfdGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIGJvZHksIF9vYmplY3RTcHJlYWQyKHsgaGVhZGVycyB9LCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cGxleCkgPyB7IGR1cGxleDogb3B0aW9ucy5kdXBsZXggfSA6IHt9KSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0cGF0aDogY2xlYW5QYXRoLFxuXHRcdFx0XHRcdGlkOiBkYXRhLklkLFxuXHRcdFx0XHRcdGZ1bGxQYXRoOiBkYXRhLktleVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBVcGxvYWRzIGEgZmlsZSB0byBhbiBleGlzdGluZyBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIE9wdGlvbmFsIGZpbGUgdXBsb2FkIG9wdGlvbnMgaW5jbHVkaW5nIGNhY2hlQ29udHJvbCwgY29udGVudFR5cGUsIHVwc2VydCwgYW5kIG1ldGFkYXRhLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgcGF0aCwgaWQsIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IGF2YXRhckZpbGUgPSBldmVudC50YXJnZXQuZmlsZXNbMF1cblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWQoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGF2YXRhckZpbGUsIHtcblx0KiAgICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG5cdCogICAgIHVwc2VydDogZmFsc2Vcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJwYXRoXCI6IFwicHVibGljL2F2YXRhcjEucG5nXCIsXG5cdCogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL3B1YmxpYy9hdmF0YXIxLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgVXBsb2FkIGZpbGUgdXNpbmcgYEFycmF5QnVmZmVyYCBmcm9tIGJhc2U2NCBmaWxlIGRhdGFcblx0KiBgYGBqc1xuXHQqIGltcG9ydCB7IGRlY29kZSB9IGZyb20gJ2Jhc2U2NC1hcnJheWJ1ZmZlcidcblx0KlxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnVwbG9hZCgncHVibGljL2F2YXRhcjEucG5nJywgZGVjb2RlKCdiYXNlNjRGaWxlRGF0YScpLCB7XG5cdCogICAgIGNvbnRlbnRUeXBlOiAnaW1hZ2UvcG5nJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgdXBsb2FkKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuXHRcdHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKFwiUE9TVFwiLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqIFVwbG9hZCBhIGZpbGUgd2l0aCBhIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG5cdCogQHBhcmFtIHRva2VuIFRoZSB0b2tlbiBnZW5lcmF0ZWQgZnJvbSBgY3JlYXRlU2lnbmVkVXBsb2FkVXJsYFxuXHQqIEBwYXJhbSBmaWxlQm9keSBUaGUgYm9keSBvZiB0aGUgZmlsZSB0byBiZSBzdG9yZWQgaW4gdGhlIGJ1Y2tldC5cblx0KiBAcGFyYW0gZmlsZU9wdGlvbnMgSFRUUCBoZWFkZXJzIChjYWNoZUNvbnRyb2wsIGNvbnRlbnRUeXBlLCBldGMuKS5cblx0KiAqKk5vdGU6KiogVGhlIGB1cHNlcnRgIG9wdGlvbiBoYXMgbm8gZWZmZWN0IGhlcmUuIFRvIGVuYWJsZSB1cHNlcnQgYmVoYXZpb3IsXG5cdCogcGFzcyBgeyB1cHNlcnQ6IHRydWUgfWAgd2hlbiBjYWxsaW5nIGBjcmVhdGVTaWduZWRVcGxvYWRVcmwoKWAgaW5zdGVhZC5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBmaWxlIHBhdGggYW5kIGZ1bGxQYXRoIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBVcGxvYWQgdG8gYSBzaWduZWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGxvYWRUb1NpZ25lZFVybCgnZm9sZGVyL2NhdC5qcGcnLCAndG9rZW4tZnJvbS1jcmVhdGVTaWduZWRVcGxvYWRVcmwnLCBmaWxlKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcImZvbGRlci9jYXQuanBnXCIsXG5cdCogICAgIFwiZnVsbFBhdGhcIjogXCJhdmF0YXJzL2ZvbGRlci9jYXQuanBnXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHVwbG9hZFRvU2lnbmVkVXJsKHBhdGgsIHRva2VuLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHRjb25zdCBjbGVhblBhdGggPSBfdGhpczMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKTtcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG5cdFx0Y29uc3QgdXJsID0gbmV3IFVSTChfdGhpczMudXJsICsgYC9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gKTtcblx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldChcInRva2VuXCIsIHRva2VuKTtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGJvZHk7XG5cdFx0XHRjb25zdCBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoeyB1cHNlcnQ6IERFRkFVTFRfRklMRV9PUFRJT05TLnVwc2VydCB9LCBmaWxlT3B0aW9ucyk7XG5cdFx0XHRjb25zdCBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF90aGlzMy5oZWFkZXJzKSwgeyBcIngtdXBzZXJ0XCI6IFN0cmluZyhvcHRpb25zLnVwc2VydCkgfSk7XG5cdFx0XHRpZiAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0XHRib2R5LmFwcGVuZChcIlwiLCBmaWxlQm9keSk7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG5cdFx0XHRcdGJvZHkgPSBmaWxlQm9keTtcblx0XHRcdFx0Ym9keS5hcHBlbmQoXCJjYWNoZUNvbnRyb2xcIiwgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ym9keSA9IGZpbGVCb2R5O1xuXHRcdFx0XHRoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBtYXgtYWdlPSR7b3B0aW9ucy5jYWNoZUNvbnRyb2x9YDtcblx0XHRcdFx0aGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB7XG5cdFx0XHRcdFx0cGF0aDogY2xlYW5QYXRoLFxuXHRcdFx0XHRcdGZ1bGxQYXRoOiAoYXdhaXQgcHV0KF90aGlzMy5mZXRjaCwgdXJsLnRvU3RyaW5nKCksIGJvZHksIHsgaGVhZGVycyB9KSkuS2V5XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG5cdCogU2lnbmVkIHVwbG9hZCBVUkxzIGNhbiBiZSB1c2VkIHRvIHVwbG9hZCBmaWxlcyB0byB0aGUgYnVja2V0IHdpdGhvdXQgZnVydGhlciBhdXRoZW50aWNhdGlvbi5cblx0KiBUaGV5IGFyZSB2YWxpZCBmb3IgMiBob3Vycy5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMudXBzZXJ0IElmIHNldCB0byB0cnVlLCBhbGxvd3MgdGhlIGZpbGUgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc2lnbmVkIHVwbG9hZCBVUkwsIHRva2VuLCBhbmQgcGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIFNpZ25lZCBVcGxvYWQgVVJMXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcGxvYWRVcmwoJ2ZvbGRlci9jYXQuanBnJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInNpZ25lZFVybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC91cGxvYWQvc2lnbi9hdmF0YXJzL2ZvbGRlci9jYXQuanBnP3Rva2VuPTxUT0tFTj5cIixcblx0KiAgICAgXCJwYXRoXCI6IFwiZm9sZGVyL2NhdC5qcGdcIixcblx0KiAgICAgXCJ0b2tlblwiOiBcIjxUT0tFTj5cIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKHBhdGgsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0bGV0IF9wYXRoID0gX3RoaXM0Ll9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0XHRjb25zdCBoZWFkZXJzID0gX29iamVjdFNwcmVhZDIoe30sIF90aGlzNC5oZWFkZXJzKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXBzZXJ0KSBoZWFkZXJzW1wieC11cHNlcnRcIl0gPSBcInRydWVcIjtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0JDEoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLCB7fSwgeyBoZWFkZXJzIH0pO1xuXHRcdFx0Y29uc3QgdXJsID0gbmV3IFVSTChfdGhpczQudXJsICsgZGF0YS51cmwpO1xuXHRcdFx0Y29uc3QgdG9rZW4gPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcInRva2VuXCIpO1xuXHRcdFx0aWYgKCF0b2tlbikgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcIk5vIHRva2VuIHJldHVybmVkIGJ5IEFQSVwiKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IHtcblx0XHRcdFx0XHRzaWduZWRVcmw6IHVybC50b1N0cmluZygpLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dG9rZW5cblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cblx0KiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG5cdCogQHBhcmFtIGZpbGVPcHRpb25zIE9wdGlvbmFsIGZpbGUgdXBsb2FkIG9wdGlvbnMgaW5jbHVkaW5nIGNhY2hlQ29udHJvbCwgY29udGVudFR5cGUsIHVwc2VydCwgYW5kIG1ldGFkYXRhLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGZpbGUgcGF0aCwgaWQsIGFuZCBmdWxsUGF0aCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgVXBkYXRlIGZpbGVcblx0KiBgYGBqc1xuXHQqIGNvbnN0IGF2YXRhckZpbGUgPSBldmVudC50YXJnZXQuZmlsZXNbMF1cblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC51cGRhdGUoJ3B1YmxpYy9hdmF0YXIxLnBuZycsIGF2YXRhckZpbGUsIHtcblx0KiAgICAgY2FjaGVDb250cm9sOiAnMzYwMCcsXG5cdCogICAgIHVwc2VydDogdHJ1ZVxuXHQqICAgfSlcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInBhdGhcIjogXCJwdWJsaWMvYXZhdGFyMS5wbmdcIixcblx0KiAgICAgXCJmdWxsUGF0aFwiOiBcImF2YXRhcnMvcHVibGljL2F2YXRhcjEucG5nXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBVcGRhdGUgZmlsZSB1c2luZyBgQXJyYXlCdWZmZXJgIGZyb20gYmFzZTY0IGZpbGUgZGF0YVxuXHQqIGBgYGpzXG5cdCogaW1wb3J0IHtkZWNvZGV9IGZyb20gJ2Jhc2U2NC1hcnJheWJ1ZmZlcidcblx0KlxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLnVwZGF0ZSgncHVibGljL2F2YXRhcjEucG5nJywgZGVjb2RlKCdiYXNlNjRGaWxlRGF0YScpLCB7XG5cdCogICAgIGNvbnRlbnRUeXBlOiAnaW1hZ2UvcG5nJ1xuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgdXBkYXRlKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuXHRcdHJldHVybiB0aGlzLnVwbG9hZE9yVXBkYXRlKFwiUFVUXCIsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG5cdH1cblx0LyoqXG5cdCogTW92ZXMgYW4gZXhpc3RpbmcgZmlsZSB0byBhIG5ldyBwYXRoIGluIHRoZSBzYW1lIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gZnJvbVBhdGggVGhlIG9yaWdpbmFsIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuXHQqIEBwYXJhbSB0b1BhdGggVGhlIG5ldyBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgbmV3IGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS1uZXcucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucyBUaGUgZGVzdGluYXRpb24gb3B0aW9ucy5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIE1vdmUgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubW92ZSgncHVibGljL2F2YXRhcjEucG5nJywgJ3ByaXZhdGUvYXZhdGFyMi5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBtb3ZlZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBtb3ZlKGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM2ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzNi5mZXRjaCwgYCR7X3RoaXM2LnVybH0vb2JqZWN0L21vdmVgLCB7XG5cdFx0XHRcdFx0YnVja2V0SWQ6IF90aGlzNi5idWNrZXRJZCxcblx0XHRcdFx0XHRzb3VyY2VLZXk6IGZyb21QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG5cdFx0XHRcdFx0ZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbkJ1Y2tldFxuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNi5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ29waWVzIGFuIGV4aXN0aW5nIGZpbGUgdG8gYSBuZXcgcGF0aCBpbiB0aGUgc2FtZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtY29weS5wbmdgLlxuXHQqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGNvcGllZCBmaWxlIHBhdGggb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENvcHkgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY29weSgncHVibGljL2F2YXRhcjEucG5nJywgJ3ByaXZhdGUvYXZhdGFyMi5wbmcnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwicGF0aFwiOiBcImF2YXRhcnMvcHJpdmF0ZS9hdmF0YXIyLnBuZ1wiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjb3B5KGZyb21QYXRoLCB0b1BhdGgsIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM3ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogeyBwYXRoOiAoYXdhaXQgcG9zdCQxKF90aGlzNy5mZXRjaCwgYCR7X3RoaXM3LnVybH0vb2JqZWN0L2NvcHlgLCB7XG5cdFx0XHRcdFx0YnVja2V0SWQ6IF90aGlzNy5idWNrZXRJZCxcblx0XHRcdFx0XHRzb3VyY2VLZXk6IGZyb21QYXRoLFxuXHRcdFx0XHRcdGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG5cdFx0XHRcdFx0ZGVzdGluYXRpb25CdWNrZXQ6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbkJ1Y2tldFxuXHRcdFx0XHR9LCB7IGhlYWRlcnM6IF90aGlzNy5oZWFkZXJzIH0pKS5LZXkgfSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczcuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIENyZWF0ZXMgYSBzaWduZWQgVVJMLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIGV4cGlyZXNJbiBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdW50aWwgdGhlIHNpZ25lZCBVUkwgZXhwaXJlcy4gRm9yIGV4YW1wbGUsIGA2MGAgZm9yIGEgVVJMIHdoaWNoIGlzIHZhbGlkIGZvciBvbmUgbWludXRlLlxuXHQqIEBwYXJhbSBvcHRpb25zLmRvd25sb2FkIHRyaWdnZXJzIHRoZSBmaWxlIGFzIGEgZG93bmxvYWQgaWYgc2V0IHRvIHRydWUuIFNldCB0aGlzIHBhcmFtZXRlciBhcyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBpZiB5b3Ugd2FudCB0byB0cmlnZ2VyIHRoZSBkb3dubG9hZCB3aXRoIGEgZGlmZmVyZW50IGZpbGVuYW1lLlxuXHQqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc2lnbmVkIFVSTCBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIFNpZ25lZCBVUkxcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmNyZWF0ZVNpZ25lZFVybCgnZm9sZGVyL2F2YXRhcjEucG5nJywgNjApXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIxLnBuZz90b2tlbj08VE9LRU4+XCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYSBzaWduZWQgVVJMIGZvciBhbiBhc3NldCB3aXRoIHRyYW5zZm9ybWF0aW9uc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5jcmVhdGVTaWduZWRVcmwoJ2ZvbGRlci9hdmF0YXIxLnBuZycsIDYwLCB7XG5cdCogICAgIHRyYW5zZm9ybToge1xuXHQqICAgICAgIHdpZHRoOiAxMDAsXG5cdCogICAgICAgaGVpZ2h0OiAxMDAsXG5cdCogICAgIH1cblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBDcmVhdGUgYSBzaWduZWQgVVJMIHdoaWNoIHRyaWdnZXJzIHRoZSBkb3dubG9hZCBvZiB0aGUgYXNzZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCA2MCwge1xuXHQqICAgICBkb3dubG9hZDogdHJ1ZSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGNyZWF0ZVNpZ25lZFVybChwYXRoLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXM4ID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0bGV0IF9wYXRoID0gX3RoaXM4Ll9nZXRGaW5hbFBhdGgocGF0aCk7XG5cdFx0XHRsZXQgZGF0YSA9IGF3YWl0IHBvc3QkMShfdGhpczguZmV0Y2gsIGAke190aGlzOC51cmx9L29iamVjdC9zaWduLyR7X3BhdGh9YCwgX29iamVjdFNwcmVhZDIoeyBleHBpcmVzSW4gfSwgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSksIHsgaGVhZGVyczogX3RoaXM4LmhlYWRlcnMgfSk7XG5cdFx0XHRjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKSA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0XHRkYXRhID0geyBzaWduZWRVcmw6IGVuY29kZVVSSShgJHtfdGhpczgudXJsfSR7ZGF0YS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YCkgfTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGEsXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM4LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIG11bHRpcGxlIHNpZ25lZCBVUkxzLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aHMgVGhlIGZpbGUgcGF0aHMgdG8gYmUgZG93bmxvYWRlZCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZXMuIEZvciBleGFtcGxlIGBbJ2ZvbGRlci9pbWFnZS5wbmcnLCAnZm9sZGVyMi9pbWFnZTIucG5nJ11gLlxuXHQqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBvYmplY3RzIHdpdGggc2lnbmVkVXJsLCBwYXRoLCBhbmQgZXJyb3Igb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBTaWduZWQgVVJMc1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuY3JlYXRlU2lnbmVkVXJscyhbJ2ZvbGRlci9hdmF0YXIxLnBuZycsICdmb2xkZXIvYXZhdGFyMi5wbmcnXSwgNjApXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IFtcblx0KiAgICAge1xuXHQqICAgICAgIFwiZXJyb3JcIjogbnVsbCxcblx0KiAgICAgICBcInBhdGhcIjogXCJmb2xkZXIvYXZhdGFyMS5wbmdcIixcblx0KiAgICAgICBcInNpZ25lZFVSTFwiOiBcIi9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIxLnBuZz90b2tlbj08VE9LRU4+XCIsXG5cdCogICAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIxLnBuZz90b2tlbj08VE9LRU4+XCJcblx0KiAgICAgfSxcblx0KiAgICAge1xuXHQqICAgICAgIFwiZXJyb3JcIjogbnVsbCxcblx0KiAgICAgICBcInBhdGhcIjogXCJmb2xkZXIvYXZhdGFyMi5wbmdcIixcblx0KiAgICAgICBcInNpZ25lZFVSTFwiOiBcIi9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIyLnBuZz90b2tlbj08VE9LRU4+XCIsXG5cdCogICAgICAgXCJzaWduZWRVcmxcIjogXCJodHRwczovL2V4YW1wbGUuc3VwYWJhc2UuY28vc3RvcmFnZS92MS9vYmplY3Qvc2lnbi9hdmF0YXJzL2ZvbGRlci9hdmF0YXIyLnBuZz90b2tlbj08VE9LRU4+XCJcblx0KiAgICAgfVxuXHQqICAgXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlU2lnbmVkVXJscyhwYXRocywgZXhwaXJlc0luLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzOSA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IGRhdGEgPSBhd2FpdCBwb3N0JDEoX3RoaXM5LmZldGNoLCBgJHtfdGhpczkudXJsfS9vYmplY3Qvc2lnbi8ke190aGlzOS5idWNrZXRJZH1gLCB7XG5cdFx0XHRcdGV4cGlyZXNJbixcblx0XHRcdFx0cGF0aHNcblx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM5LmhlYWRlcnMgfSk7XG5cdFx0XHRjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKSA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gXCJcIiA6IG9wdGlvbnMuZG93bmxvYWR9YCA6IFwiXCI7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBkYXRhLm1hcCgoZGF0dW0pID0+IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkYXR1bSksIHt9LCB7IHNpZ25lZFVybDogZGF0dW0uc2lnbmVkVVJMID8gZW5jb2RlVVJJKGAke190aGlzOS51cmx9JHtkYXR1bS5zaWduZWRVUkx9JHtkb3dubG9hZFF1ZXJ5UGFyYW19YCkgOiBudWxsIH0pKSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczkuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIERvd25sb2FkcyBhIGZpbGUgZnJvbSBhIHByaXZhdGUgYnVja2V0LiBGb3IgcHVibGljIGJ1Y2tldHMsIG1ha2UgYSByZXF1ZXN0IHRvIHRoZSBVUkwgcmV0dXJuZWQgZnJvbSBgZ2V0UHVibGljVXJsYCBpbnN0ZWFkLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmdWxsIHBhdGggYW5kIGZpbGUgbmFtZSBvZiB0aGUgZmlsZSB0byBiZSBkb3dubG9hZGVkLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cblx0KiBAcmV0dXJucyBCbG9iRG93bmxvYWRCdWlsZGVyIGluc3RhbmNlIGZvciBkb3dubG9hZGluZyB0aGUgZmlsZVxuXHQqXG5cdCogQGV4YW1wbGUgRG93bmxvYWQgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuZG93bmxvYWQoJ2ZvbGRlci9hdmF0YXIxLnBuZycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IDxCTE9CPixcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIERvd25sb2FkIGZpbGUgd2l0aCB0cmFuc2Zvcm1hdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ2F2YXRhcnMnKVxuXHQqICAgLmRvd25sb2FkKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCB7XG5cdCogICAgIHRyYW5zZm9ybToge1xuXHQqICAgICAgIHdpZHRoOiAxMDAsXG5cdCogICAgICAgaGVpZ2h0OiAxMDAsXG5cdCogICAgICAgcXVhbGl0eTogODBcblx0KiAgICAgfVxuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0ZG93bmxvYWQocGF0aCwgb3B0aW9ucykge1xuXHRcdGNvbnN0IHJlbmRlclBhdGggPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSBcInVuZGVmaW5lZFwiID8gXCJyZW5kZXIvaW1hZ2UvYXV0aGVudGljYXRlZFwiIDogXCJvYmplY3RcIjtcblx0XHRjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgfHwge30pO1xuXHRcdGNvbnN0IHF1ZXJ5U3RyaW5nID0gdHJhbnNmb3JtYXRpb25RdWVyeSA/IGA/JHt0cmFuc2Zvcm1hdGlvblF1ZXJ5fWAgOiBcIlwiO1xuXHRcdGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdGNvbnN0IGRvd25sb2FkRm4gPSAoKSA9PiBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9LyR7cmVuZGVyUGF0aH0vJHtfcGF0aH0ke3F1ZXJ5U3RyaW5nfWAsIHtcblx0XHRcdGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcblx0XHRcdG5vUmVzb2x2ZUpzb246IHRydWVcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3IEJsb2JEb3dubG9hZEJ1aWxkZXIoZG93bmxvYWRGbiwgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpO1xuXHR9XG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBmaWxlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgZmlsZSBtZXRhZGF0YSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgR2V0IGZpbGUgaW5mb1xuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuaW5mbygnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgaW5mbyhwYXRoKSB7XG5cdFx0dmFyIF90aGlzMTAgPSB0aGlzO1xuXHRcdGNvbnN0IF9wYXRoID0gX3RoaXMxMC5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiByZWN1cnNpdmVUb0NhbWVsKGF3YWl0IGdldChfdGhpczEwLmZldGNoLCBgJHtfdGhpczEwLnVybH0vb2JqZWN0L2luZm8vJHtfcGF0aH1gLCB7IGhlYWRlcnM6IF90aGlzMTAuaGVhZGVycyB9KSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ2hlY2tzIHRoZSBleGlzdGVuY2Ugb2YgYSBmaWxlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYm9vbGVhbiBpbmRpY2F0aW5nIGZpbGUgZXhpc3RlbmNlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBDaGVjayBmaWxlIGV4aXN0ZW5jZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAuZXhpc3RzKCdmb2xkZXIvYXZhdGFyMS5wbmcnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBleGlzdHMocGF0aCkge1xuXHRcdHZhciBfdGhpczExID0gdGhpcztcblx0XHRjb25zdCBfcGF0aCA9IF90aGlzMTEuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgaGVhZChfdGhpczExLmZldGNoLCBgJHtfdGhpczExLnVybH0vb2JqZWN0LyR7X3BhdGh9YCwgeyBoZWFkZXJzOiBfdGhpczExLmhlYWRlcnMgfSk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiB0cnVlLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMTEuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikgJiYgZXJyb3IgaW5zdGFuY2VvZiBTdG9yYWdlVW5rbm93bkVycm9yKSB7XG5cdFx0XHRcdGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnJvci5vcmlnaW5hbEVycm9yO1xuXHRcdFx0XHRpZiAoWzQwMCwgNDA0XS5pbmNsdWRlcyhvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsRXJyb3Iuc3RhdHVzKSkgcmV0dXJuIHtcblx0XHRcdFx0XHRkYXRhOiBmYWxzZSxcblx0XHRcdFx0XHRlcnJvclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEEgc2ltcGxlIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCB0aGUgVVJMIGZvciBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXQuIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgdGhpcyBmdW5jdGlvbiwgeW91IGNhbiBjb25zdHJ1Y3QgdGhlIHB1YmxpYyBVUkwgYnkgY29uY2F0ZW5hdGluZyB0aGUgYnVja2V0IFVSTCB3aXRoIHRoZSBwYXRoIHRvIHRoZSBhc3NldC5cblx0KiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHZlcmlmeSBpZiB0aGUgYnVja2V0IGlzIHB1YmxpYy4gSWYgYSBwdWJsaWMgVVJMIGlzIGNyZWF0ZWQgZm9yIGEgYnVja2V0IHdoaWNoIGlzIG5vdCBwdWJsaWMsIHlvdSB3aWxsIG5vdCBiZSBhYmxlIHRvIGRvd25sb2FkIHRoZSBhc3NldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBhbmQgbmFtZSBvZiB0aGUgZmlsZSB0byBnZW5lcmF0ZSB0aGUgcHVibGljIFVSTCBmb3IuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cblx0KiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCBUcmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cblx0KiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuXHQqIEByZXR1cm5zIE9iamVjdCB3aXRoIHB1YmxpYyBVUkxcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcInB1YmxpY1VybFwiOiBcImh0dHBzOi8vZXhhbXBsZS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxL29iamVjdC9wdWJsaWMvcHVibGljLWJ1Y2tldC9mb2xkZXIvYXZhdGFyMS5wbmdcIlxuXHQqICAgfVxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFJldHVybnMgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0IHdpdGggdHJhbnNmb3JtYXRpb25zXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEgfSA9IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmZyb20oJ3B1YmxpYy1idWNrZXQnKVxuXHQqICAgLmdldFB1YmxpY1VybCgnZm9sZGVyL2F2YXRhcjEucG5nJywge1xuXHQqICAgICB0cmFuc2Zvcm06IHtcblx0KiAgICAgICB3aWR0aDogMTAwLFxuXHQqICAgICAgIGhlaWdodDogMTAwLFxuXHQqICAgICB9XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgUmV0dXJucyB0aGUgVVJMIHdoaWNoIHRyaWdnZXJzIHRoZSBkb3dubG9hZCBvZiBhbiBhc3NldCBpbiBhIHB1YmxpYyBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgncHVibGljLWJ1Y2tldCcpXG5cdCogICAuZ2V0UHVibGljVXJsKCdmb2xkZXIvYXZhdGFyMS5wbmcnLCB7XG5cdCogICAgIGRvd25sb2FkOiB0cnVlLFxuXHQqICAgfSlcblx0KiBgYGBcblx0Ki9cblx0Z2V0UHVibGljVXJsKHBhdGgsIG9wdGlvbnMpIHtcblx0XHRjb25zdCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcblx0XHRjb25zdCBfcXVlcnlTdHJpbmcgPSBbXTtcblx0XHRjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKSA/IGBkb3dubG9hZD0ke29wdGlvbnMuZG93bmxvYWQgPT09IHRydWUgPyBcIlwiIDogb3B0aW9ucy5kb3dubG9hZH1gIDogXCJcIjtcblx0XHRpZiAoZG93bmxvYWRRdWVyeVBhcmFtICE9PSBcIlwiKSBfcXVlcnlTdHJpbmcucHVzaChkb3dubG9hZFF1ZXJ5UGFyYW0pO1xuXHRcdGNvbnN0IHJlbmRlclBhdGggPSB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9PSBcInVuZGVmaW5lZFwiID8gXCJyZW5kZXIvaW1hZ2VcIiA6IFwib2JqZWN0XCI7XG5cdFx0Y29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcblx0XHRpZiAodHJhbnNmb3JtYXRpb25RdWVyeSAhPT0gXCJcIikgX3F1ZXJ5U3RyaW5nLnB1c2godHJhbnNmb3JtYXRpb25RdWVyeSk7XG5cdFx0bGV0IHF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLmpvaW4oXCImXCIpO1xuXHRcdGlmIChxdWVyeVN0cmluZyAhPT0gXCJcIikgcXVlcnlTdHJpbmcgPSBgPyR7cXVlcnlTdHJpbmd9YDtcblx0XHRyZXR1cm4geyBkYXRhOiB7IHB1YmxpY1VybDogZW5jb2RlVVJJKGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9L3B1YmxpYy8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCkgfSB9O1xuXHR9XG5cdC8qKlxuXHQqIERlbGV0ZXMgZmlsZXMgd2l0aGluIHRoZSBzYW1lIGJ1Y2tldFxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBwYXRocyBBbiBhcnJheSBvZiBmaWxlcyB0byBkZWxldGUsIGluY2x1ZGluZyB0aGUgcGF0aCBhbmQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBbYCdmb2xkZXIvaW1hZ2UucG5nJ2BdLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIGRlbGV0ZWQgZmlsZSBvYmplY3RzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBEZWxldGUgZmlsZVxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAucmVtb3ZlKFsnZm9sZGVyL2F2YXRhcjEucG5nJ10pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IFtdLFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyByZW1vdmUocGF0aHMpIHtcblx0XHR2YXIgX3RoaXMxMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHJlbW92ZShfdGhpczEyLmZldGNoLCBgJHtfdGhpczEyLnVybH0vb2JqZWN0LyR7X3RoaXMxMi5idWNrZXRJZH1gLCB7IHByZWZpeGVzOiBwYXRocyB9LCB7IGhlYWRlcnM6IF90aGlzMTIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczEyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBHZXQgZmlsZSBtZXRhZGF0YVxuXHQqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byByZXRyaWV2ZSBtZXRhZGF0YVxuXHQqL1xuXHQvKipcblx0KiBVcGRhdGUgZmlsZSBtZXRhZGF0YVxuXHQqIEBwYXJhbSBpZCB0aGUgZmlsZSBpZCB0byB1cGRhdGUgbWV0YWRhdGFcblx0KiBAcGFyYW0gbWV0YSB0aGUgbmV3IGZpbGUgbWV0YWRhdGFcblx0Ki9cblx0LyoqXG5cdCogTGlzdHMgYWxsIHRoZSBmaWxlcyBhbmQgZm9sZGVycyB3aXRoaW4gYSBwYXRoIG9mIHRoZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIHBhdGggVGhlIGZvbGRlciBwYXRoLlxuXHQqIEBwYXJhbSBvcHRpb25zIFNlYXJjaCBvcHRpb25zIGluY2x1ZGluZyBsaW1pdCAoZGVmYXVsdHMgdG8gMTAwKSwgb2Zmc2V0LCBzb3J0QnksIGFuZCBzZWFyY2hcblx0KiBAcGFyYW0gcGFyYW1ldGVycyBPcHRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzIGluY2x1ZGluZyBzaWduYWwgZm9yIGNhbmNlbGxhdGlvblxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIGZpbGVzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGZpbGVzIGluIGEgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5mcm9tKCdhdmF0YXJzJylcblx0KiAgIC5saXN0KCdmb2xkZXInLCB7XG5cdCogICAgIGxpbWl0OiAxMDAsXG5cdCogICAgIG9mZnNldDogMCxcblx0KiAgICAgc29ydEJ5OiB7IGNvbHVtbjogJ25hbWUnLCBvcmRlcjogJ2FzYycgfSxcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IFtcblx0KiAgICAge1xuXHQqICAgICAgIFwibmFtZVwiOiBcImF2YXRhcjEucG5nXCIsXG5cdCogICAgICAgXCJpZFwiOiBcImU2NjhjZjdmLTgyMWItNGEyZi05ZGNlLTdkZmE1ZGQxY2ZkMlwiLFxuXHQqICAgICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDY6MDUuNTgwWlwiLFxuXHQqICAgICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDQ6MzQuNDQzWlwiLFxuXHQqICAgICAgIFwibGFzdF9hY2Nlc3NlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjM6MDQ6MzQuNDQzWlwiLFxuXHQqICAgICAgIFwibWV0YWRhdGFcIjoge1xuXHQqICAgICAgICAgXCJlVGFnXCI6IFwiXFxcImM1ZThjNTUzMjM1ZDlhZjMwZWY0ZjZlMjgwNzkwYjkyXFxcIlwiLFxuXHQqICAgICAgICAgXCJzaXplXCI6IDMyMTc1LFxuXHQqICAgICAgICAgXCJtaW1ldHlwZVwiOiBcImltYWdlL3BuZ1wiLFxuXHQqICAgICAgICAgXCJjYWNoZUNvbnRyb2xcIjogXCJtYXgtYWdlPTM2MDBcIixcblx0KiAgICAgICAgIFwibGFzdE1vZGlmaWVkXCI6IFwiMjAyNC0wNS0yMlQyMzowNjowNS41NzRaXCIsXG5cdCogICAgICAgICBcImNvbnRlbnRMZW5ndGhcIjogMzIxNzUsXG5cdCogICAgICAgICBcImh0dHBTdGF0dXNDb2RlXCI6IDIwMFxuXHQqICAgICAgIH1cblx0KiAgICAgfVxuXHQqICAgXSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFNlYXJjaCBmaWxlcyBpbiBhIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZnJvbSgnYXZhdGFycycpXG5cdCogICAubGlzdCgnZm9sZGVyJywge1xuXHQqICAgICBsaW1pdDogMTAwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRCeTogeyBjb2x1bW46ICduYW1lJywgb3JkZXI6ICdhc2MnIH0sXG5cdCogICAgIHNlYXJjaDogJ2pvbidcblx0KiAgIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3QocGF0aCwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuXHRcdHZhciBfdGhpczEzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYm9keSA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX1NFQVJDSF9PUFRJT05TKSwgb3B0aW9ucyksIHt9LCB7IHByZWZpeDogcGF0aCB8fCBcIlwiIH0pO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzMTMuZmV0Y2gsIGAke190aGlzMTMudXJsfS9vYmplY3QvbGlzdC8ke190aGlzMTMuYnVja2V0SWR9YCwgYm9keSwgeyBoZWFkZXJzOiBfdGhpczEzLmhlYWRlcnMgfSwgcGFyYW1ldGVycyksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQGV4cGVyaW1lbnRhbCB0aGlzIG1ldGhvZCBzaWduYXR1cmUgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmVcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyBzZWFyY2ggb3B0aW9uc1xuXHQqIEBwYXJhbSBwYXJhbWV0ZXJzXG5cdCovXG5cdGFzeW5jIGxpc3RWMihvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdFx0dmFyIF90aGlzMTQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBib2R5ID0gX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzMTQuZmV0Y2gsIGAke190aGlzMTQudXJsfS9vYmplY3QvbGlzdC12Mi8ke190aGlzMTQuYnVja2V0SWR9YCwgYm9keSwgeyBoZWFkZXJzOiBfdGhpczE0LmhlYWRlcnMgfSwgcGFyYW1ldGVycyksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMxNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0ZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuXHR9XG5cdHRvQmFzZTY0KGRhdGEpIHtcblx0XHRpZiAodHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuXHRcdHJldHVybiBidG9hKGRhdGEpO1xuXHR9XG5cdF9nZXRGaW5hbFBhdGgocGF0aCkge1xuXHRcdHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGgucmVwbGFjZSgvXlxcLysvLCBcIlwiKX1gO1xuXHR9XG5cdF9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCkge1xuXHRcdHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCBcIlwiKS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcblx0fVxuXHR0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyh0cmFuc2Zvcm0pIHtcblx0XHRjb25zdCBwYXJhbXMgPSBbXTtcblx0XHRpZiAodHJhbnNmb3JtLndpZHRoKSBwYXJhbXMucHVzaChgd2lkdGg9JHt0cmFuc2Zvcm0ud2lkdGh9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5oZWlnaHQpIHBhcmFtcy5wdXNoKGBoZWlnaHQ9JHt0cmFuc2Zvcm0uaGVpZ2h0fWApO1xuXHRcdGlmICh0cmFuc2Zvcm0ucmVzaXplKSBwYXJhbXMucHVzaChgcmVzaXplPSR7dHJhbnNmb3JtLnJlc2l6ZX1gKTtcblx0XHRpZiAodHJhbnNmb3JtLmZvcm1hdCkgcGFyYW1zLnB1c2goYGZvcm1hdD0ke3RyYW5zZm9ybS5mb3JtYXR9YCk7XG5cdFx0aWYgKHRyYW5zZm9ybS5xdWFsaXR5KSBwYXJhbXMucHVzaChgcXVhbGl0eT0ke3RyYW5zZm9ybS5xdWFsaXR5fWApO1xuXHRcdHJldHVybiBwYXJhbXMuam9pbihcIiZcIik7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVyc2lvbi50c1xuY29uc3QgdmVyc2lvbiA9IFwiMi45MC4wXCI7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvY29uc3RhbnRzLnRzXG5jb25zdCBERUZBVUxUX0hFQURFUlMkMSA9IHsgXCJYLUNsaWVudC1JbmZvXCI6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gIH07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpLnRzXG52YXIgU3RvcmFnZUJ1Y2tldEFwaSA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEsIG9wdHMpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdGNvbnN0IGJhc2VVcmwgPSBuZXcgVVJMKHVybCk7XG5cdFx0aWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy51c2VOZXdIb3N0bmFtZSkge1xuXHRcdFx0aWYgKC9zdXBhYmFzZVxcLihjb3xpbnxyZWQpJC8udGVzdChiYXNlVXJsLmhvc3RuYW1lKSAmJiAhYmFzZVVybC5ob3N0bmFtZS5pbmNsdWRlcyhcInN0b3JhZ2Uuc3VwYWJhc2UuXCIpKSBiYXNlVXJsLmhvc3RuYW1lID0gYmFzZVVybC5ob3N0bmFtZS5yZXBsYWNlKFwic3VwYWJhc2UuXCIsIFwic3RvcmFnZS5zdXBhYmFzZS5cIik7XG5cdFx0fVxuXHRcdHRoaXMudXJsID0gYmFzZVVybC5ocmVmLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTJDEpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoJDEoZmV0Y2gkMSk7XG5cdH1cblx0LyoqXG5cdCogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbGwgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0LlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIFF1ZXJ5IHBhcmFtZXRlcnMgZm9yIGxpc3RpbmcgYnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zLmxpbWl0IE1heGltdW0gbnVtYmVyIG9mIGJ1Y2tldHMgdG8gcmV0dXJuXG5cdCogQHBhcmFtIG9wdGlvbnMub2Zmc2V0IE51bWJlciBvZiBidWNrZXRzIHRvIHNraXBcblx0KiBAcGFyYW0gb3B0aW9ucy5zb3J0Q29sdW1uIENvbHVtbiB0byBzb3J0IGJ5ICgnaWQnLCAnbmFtZScsICdjcmVhdGVkX2F0JywgJ3VwZGF0ZWRfYXQnKVxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRPcmRlciBTb3J0IG9yZGVyICgnYXNjJyBvciAnZGVzYycpXG5cdCogQHBhcmFtIG9wdGlvbnMuc2VhcmNoIFNlYXJjaCB0ZXJtIHRvIGZpbHRlciBidWNrZXQgbmFtZXNcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBhcnJheSBvZiBidWNrZXRzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGJ1Y2tldHNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmxpc3RCdWNrZXRzKClcblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIExpc3QgYnVja2V0cyB3aXRoIG9wdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmxpc3RCdWNrZXRzKHtcblx0KiAgICAgbGltaXQ6IDEwLFxuXHQqICAgICBvZmZzZXQ6IDAsXG5cdCogICAgIHNvcnRDb2x1bW46ICdjcmVhdGVkX2F0Jyxcblx0KiAgICAgc29ydE9yZGVyOiAnZGVzYycsXG5cdCogICAgIHNlYXJjaDogJ3Byb2QnXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgcXVlcnlTdHJpbmcgPSBfdGhpcy5saXN0QnVja2V0T3B0aW9uc1RvUXVlcnlTdHJpbmcob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBnZXQoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vYnVja2V0JHtxdWVyeVN0cmluZ31gLCB7IGhlYWRlcnM6IF90aGlzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gcmV0cmlldmUuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgYnVja2V0IGRldGFpbHMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEdldCBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmdldEJ1Y2tldCgnYXZhdGFycycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJpZFwiOiBcImF2YXRhcnNcIixcblx0KiAgICAgXCJuYW1lXCI6IFwiYXZhdGFyc1wiLFxuXHQqICAgICBcIm93bmVyXCI6IFwiXCIsXG5cdCogICAgIFwicHVibGljXCI6IGZhbHNlLFxuXHQqICAgICBcImZpbGVfc2l6ZV9saW1pdFwiOiAxMDI0LFxuXHQqICAgICBcImFsbG93ZWRfbWltZV90eXBlc1wiOiBbXG5cdCogICAgICAgXCJpbWFnZS9wbmdcIlxuXHQqICAgICBdLFxuXHQqICAgICBcImNyZWF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIixcblx0KiAgICAgXCJ1cGRhdGVkX2F0XCI6IFwiMjAyNC0wNS0yMlQyMjoyNjowNS4xMDBaXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldEJ1Y2tldChpZCkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBnZXQoX3RoaXMyLmZldGNoLCBgJHtfdGhpczIudXJsfS9idWNrZXQvJHtpZH1gLCB7IGhlYWRlcnM6IF90aGlzMi5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQ3JlYXRlcyBhIG5ldyBTdG9yYWdlIGJ1Y2tldFxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG5cdCogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy4gQnkgZGVmYXVsdCwgYnVja2V0cyBhcmUgcHJpdmF0ZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cblx0KiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cblx0KiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuXHQqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG5cdCogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cblx0KiBAcGFyYW0gb3B0aW9ucy50eXBlIChwcml2YXRlLWJldGEpIHNwZWNpZmllcyB0aGUgYnVja2V0IHR5cGUuIHNlZSBgQnVja2V0VHlwZWAgZm9yIG1vcmUgZGV0YWlscy5cblx0KiAgIC0gZGVmYXVsdCBidWNrZXQgdHlwZSBpcyBgU1RBTkRBUkRgXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbmV3bHkgY3JlYXRlZCBidWNrZXQgbmFtZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGUgQ3JlYXRlIGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuY3JlYXRlQnVja2V0KCdhdmF0YXJzJywge1xuXHQqICAgICBwdWJsaWM6IGZhbHNlLFxuXHQqICAgICBhbGxvd2VkTWltZVR5cGVzOiBbJ2ltYWdlL3BuZyddLFxuXHQqICAgICBmaWxlU2l6ZUxpbWl0OiAxMDI0XG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibmFtZVwiOiBcImF2YXRhcnNcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KGlkLCBvcHRpb25zID0geyBwdWJsaWM6IGZhbHNlIH0pIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdCQxKF90aGlzMy5mZXRjaCwgYCR7X3RoaXMzLnVybH0vYnVja2V0YCwge1xuXHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdG5hbWU6IGlkLFxuXHRcdFx0XHRcdHR5cGU6IG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRwdWJsaWM6IG9wdGlvbnMucHVibGljLFxuXHRcdFx0XHRcdGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuXHRcdFx0XHRcdGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBVcGRhdGVzIGEgU3RvcmFnZSBidWNrZXRcblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJ1Y2tldCB5b3UgYXJlIHVwZGF0aW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLnB1YmxpYyBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgYnVja2V0LiBQdWJsaWMgYnVja2V0cyBkb24ndCByZXF1aXJlIGFuIGF1dGhvcml6YXRpb24gdG9rZW4gdG8gZG93bmxvYWQgb2JqZWN0cywgYnV0IHN0aWxsIHJlcXVpcmUgYSB2YWxpZCB0b2tlbiBmb3IgYWxsIG90aGVyIG9wZXJhdGlvbnMuXG5cdCogQHBhcmFtIG9wdGlvbnMuZmlsZVNpemVMaW1pdCBzcGVjaWZpZXMgdGhlIG1heCBmaWxlIHNpemUgaW4gYnl0ZXMgdGhhdCBjYW4gYmUgdXBsb2FkZWQgdG8gdGhpcyBidWNrZXQuXG5cdCogVGhlIGdsb2JhbCBmaWxlIHNpemUgbGltaXQgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIHRoaXMgdmFsdWUuXG5cdCogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggZG9lc24ndCBzZXQgYSBwZXIgYnVja2V0IGZpbGUgc2l6ZSBsaW1pdC5cblx0KiBAcGFyYW0gb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzIHNwZWNpZmllcyB0aGUgYWxsb3dlZCBtaW1lIHR5cGVzIHRoYXQgdGhpcyBidWNrZXQgY2FuIGFjY2VwdCBkdXJpbmcgdXBsb2FkLlxuXHQqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIG51bGwsIHdoaWNoIGFsbG93cyBmaWxlcyB3aXRoIGFsbCBtaW1lIHR5cGVzIHRvIGJlIHVwbG9hZGVkLlxuXHQqIEVhY2ggbWltZSB0eXBlIHNwZWNpZmllZCBjYW4gYmUgYSB3aWxkY2FyZCwgZS5nLiBpbWFnZS8qLCBvciBhIHNwZWNpZmljIG1pbWUgdHlwZSwgZS5nLiBpbWFnZS9wbmcuXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgc3VjY2VzcyBtZXNzYWdlIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBVcGRhdGUgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC51cGRhdGVCdWNrZXQoJ2F2YXRhcnMnLCB7XG5cdCogICAgIHB1YmxpYzogZmFsc2UsXG5cdCogICAgIGFsbG93ZWRNaW1lVHlwZXM6IFsnaW1hZ2UvcG5nJ10sXG5cdCogICAgIGZpbGVTaXplTGltaXQ6IDEwMjRcblx0KiAgIH0pXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IHVwZGF0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgdXBkYXRlQnVja2V0KGlkLCBvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHB1dChfdGhpczQuZmV0Y2gsIGAke190aGlzNC51cmx9L2J1Y2tldC8ke2lkfWAsIHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRuYW1lOiBpZCxcblx0XHRcdFx0XHRwdWJsaWM6IG9wdGlvbnMucHVibGljLFxuXHRcdFx0XHRcdGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuXHRcdFx0XHRcdGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzXG5cdFx0XHRcdH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKipcblx0KiBSZW1vdmVzIGFsbCBvYmplY3RzIGluc2lkZSBhIHNpbmdsZSBidWNrZXQuXG5cdCpcblx0KiBAY2F0ZWdvcnkgRmlsZSBCdWNrZXRzXG5cdCogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIEVtcHR5IGJ1Y2tldFxuXHQqIGBgYGpzXG5cdCogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2Vcblx0KiAgIC5zdG9yYWdlXG5cdCogICAuZW1wdHlCdWNrZXQoJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiB7XG5cdCogICAgIFwibWVzc2FnZVwiOiBcIlN1Y2Nlc3NmdWxseSBlbXB0aWVkXCJcblx0KiAgIH0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGVtcHR5QnVja2V0KGlkKSB7XG5cdFx0dmFyIF90aGlzNSA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QkMShfdGhpczUuZmV0Y2gsIGAke190aGlzNS51cmx9L2J1Y2tldC8ke2lkfS9lbXB0eWAsIHt9LCB7IGhlYWRlcnM6IF90aGlzNS5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNS5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogRGVsZXRlcyBhbiBleGlzdGluZyBidWNrZXQuIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdC5cblx0KiBZb3UgbXVzdCBmaXJzdCBgZW1wdHkoKWAgdGhlIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlLlxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIERlbGV0ZSBidWNrZXRcblx0KiBgYGBqc1xuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmRlbGV0ZUJ1Y2tldCgnYXZhdGFycycpXG5cdCogYGBgXG5cdCpcblx0KiBSZXNwb25zZTpcblx0KiBgYGBqc29uXG5cdCoge1xuXHQqICAgXCJkYXRhXCI6IHtcblx0KiAgICAgXCJtZXNzYWdlXCI6IFwiU3VjY2Vzc2Z1bGx5IGRlbGV0ZWRcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlQnVja2V0KGlkKSB7XG5cdFx0dmFyIF90aGlzNiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHJlbW92ZShfdGhpczYuZmV0Y2gsIGAke190aGlzNi51cmx9L2J1Y2tldC8ke2lkfWAsIHt9LCB7IGhlYWRlcnM6IF90aGlzNi5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNi5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0bGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpIHtcblx0XHRjb25zdCBwYXJhbXMgPSB7fTtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKFwibGltaXRcIiBpbiBvcHRpb25zKSBwYXJhbXMubGltaXQgPSBTdHJpbmcob3B0aW9ucy5saW1pdCk7XG5cdFx0XHRpZiAoXCJvZmZzZXRcIiBpbiBvcHRpb25zKSBwYXJhbXMub2Zmc2V0ID0gU3RyaW5nKG9wdGlvbnMub2Zmc2V0KTtcblx0XHRcdGlmIChvcHRpb25zLnNlYXJjaCkgcGFyYW1zLnNlYXJjaCA9IG9wdGlvbnMuc2VhcmNoO1xuXHRcdFx0aWYgKG9wdGlvbnMuc29ydENvbHVtbikgcGFyYW1zLnNvcnRDb2x1bW4gPSBvcHRpb25zLnNvcnRDb2x1bW47XG5cdFx0XHRpZiAob3B0aW9ucy5zb3J0T3JkZXIpIHBhcmFtcy5zb3J0T3JkZXIgPSBvcHRpb25zLnNvcnRPcmRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/IFwiP1wiICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpLnRvU3RyaW5nKCkgOiBcIlwiO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvcGFja2FnZXMvU3RvcmFnZUFuYWx5dGljc0NsaWVudC50c1xuLyoqXG4qIENsaWVudCBjbGFzcyBmb3IgbWFuYWdpbmcgQW5hbHl0aWNzIEJ1Y2tldHMgdXNpbmcgSWNlYmVyZyB0YWJsZXNcbiogUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIGxpc3RpbmcsIGFuZCBkZWxldGluZyBhbmFseXRpY3MgYnVja2V0c1xuKi9cbnZhciBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50ID0gY2xhc3Mge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZUFuYWx5dGljc0NsaWVudCBpbnN0YW5jZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEBwYXJhbSB1cmwgLSBUaGUgYmFzZSBVUkwgZm9yIHRoZSBzdG9yYWdlIEFQSVxuXHQqIEBwYXJhbSBoZWFkZXJzIC0gSFRUUCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gcmVxdWVzdHNcblx0KiBAcGFyYW0gZmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGNsaWVudCA9IG5ldyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50KHVybCwgaGVhZGVycylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoJDEpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuXHRcdHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9IRUFERVJTJDEpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoJDEoZmV0Y2gkMSk7XG5cdH1cblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlXG5cdCogV2hlbiBlbmFibGVkLCBmYWlsZWQgb3BlcmF0aW9ucyB3aWxsIHRocm93IGluc3RlYWQgb2YgcmV0dXJuaW5nIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBBbmFseXRpY3MgQnVja2V0c1xuXHQqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuXHQqL1xuXHR0aHJvd09uRXJyb3IoKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIG5ldyBhbmFseXRpY3MgYnVja2V0IHVzaW5nIEljZWJlcmcgdGFibGVzXG5cdCogQW5hbHl0aWNzIGJ1Y2tldHMgYXJlIG9wdGltaXplZCBmb3IgYW5hbHl0aWNhbCBxdWVyaWVzIGFuZCBkYXRhIHByb2Nlc3Npbmdcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gbmFtZSBBIHVuaXF1ZSBuYW1lIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmdcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBuZXdseSBjcmVhdGVkIGFuYWx5dGljcyBidWNrZXQgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIENyZWF0ZSBhbmFseXRpY3MgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5jcmVhdGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm5hbWVcIjogXCJhbmFseXRpY3MtZGF0YVwiLFxuXHQqICAgICBcInR5cGVcIjogXCJBTkFMWVRJQ1NcIixcblx0KiAgICAgXCJmb3JtYXRcIjogXCJpY2ViZXJnXCIsXG5cdCogICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiLFxuXHQqICAgICBcInVwZGF0ZWRfYXRcIjogXCIyMDI0LTA1LTIyVDIyOjI2OjA1LjEwMFpcIlxuXHQqICAgfSxcblx0KiAgIFwiZXJyb3JcIjogbnVsbFxuXHQqIH1cblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlQnVja2V0KG5hbWUpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0JDEoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vYnVja2V0YCwgeyBuYW1lIH0sIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgdGhlIGRldGFpbHMgb2YgYWxsIEFuYWx5dGljcyBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3Rcblx0KiBPbmx5IHJldHVybnMgYnVja2V0cyBvZiB0eXBlICdBTkFMWVRJQ1MnXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgUXVlcnkgcGFyYW1ldGVycyBmb3IgbGlzdGluZyBidWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMubGltaXQgTWF4aW11bSBudW1iZXIgb2YgYnVja2V0cyB0byByZXR1cm5cblx0KiBAcGFyYW0gb3B0aW9ucy5vZmZzZXQgTnVtYmVyIG9mIGJ1Y2tldHMgdG8gc2tpcFxuXHQqIEBwYXJhbSBvcHRpb25zLnNvcnRDb2x1bW4gQ29sdW1uIHRvIHNvcnQgYnkgKCduYW1lJywgJ2NyZWF0ZWRfYXQnLCAndXBkYXRlZF9hdCcpXG5cdCogQHBhcmFtIG9wdGlvbnMuc29ydE9yZGVyIFNvcnQgb3JkZXIgKCdhc2MnIG9yICdkZXNjJylcblx0KiBAcGFyYW0gb3B0aW9ucy5zZWFyY2ggU2VhcmNoIHRlcm0gdG8gZmlsdGVyIGJ1Y2tldCBuYW1lc1xuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGFycmF5IG9mIGFuYWx5dGljcyBidWNrZXRzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZSBMaXN0IGFuYWx5dGljcyBidWNrZXRzXG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5saXN0QnVja2V0cyh7XG5cdCogICAgIGxpbWl0OiAxMCxcblx0KiAgICAgb2Zmc2V0OiAwLFxuXHQqICAgICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG5cdCogICAgIHNvcnRPcmRlcjogJ2Rlc2MnXG5cdCogICB9KVxuXHQqIGBgYFxuXHQqXG5cdCogUmVzcG9uc2U6XG5cdCogYGBganNvblxuXHQqIHtcblx0KiAgIFwiZGF0YVwiOiBbXG5cdCogICAgIHtcblx0KiAgICAgICBcIm5hbWVcIjogXCJhbmFseXRpY3MtZGF0YVwiLFxuXHQqICAgICAgIFwidHlwZVwiOiBcIkFOQUxZVElDU1wiLFxuXHQqICAgICAgIFwiZm9ybWF0XCI6IFwiaWNlYmVyZ1wiLFxuXHQqICAgICAgIFwiY3JlYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiLFxuXHQqICAgICAgIFwidXBkYXRlZF9hdFwiOiBcIjIwMjQtMDUtMjJUMjI6MjY6MDUuMTAwWlwiXG5cdCogICAgIH1cblx0KiAgIF0sXG5cdCogICBcImVycm9yXCI6IG51bGxcblx0KiB9XG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGxpc3RCdWNrZXRzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgcXVlcnlQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG5cdFx0XHRpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5saW1pdCkgIT09IHZvaWQgMCkgcXVlcnlQYXJhbXMuc2V0KFwibGltaXRcIiwgb3B0aW9ucy5saW1pdC50b1N0cmluZygpKTtcblx0XHRcdGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgIT09IHZvaWQgMCkgcXVlcnlQYXJhbXMuc2V0KFwib2Zmc2V0XCIsIG9wdGlvbnMub2Zmc2V0LnRvU3RyaW5nKCkpO1xuXHRcdFx0aWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0Q29sdW1uKSBxdWVyeVBhcmFtcy5zZXQoXCJzb3J0Q29sdW1uXCIsIG9wdGlvbnMuc29ydENvbHVtbik7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNvcnRPcmRlcikgcXVlcnlQYXJhbXMuc2V0KFwic29ydE9yZGVyXCIsIG9wdGlvbnMuc29ydE9yZGVyKTtcblx0XHRcdGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VhcmNoKSBxdWVyeVBhcmFtcy5zZXQoXCJzZWFyY2hcIiwgb3B0aW9ucy5zZWFyY2gpO1xuXHRcdFx0Y29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuXHRcdFx0Y29uc3QgdXJsID0gcXVlcnlTdHJpbmcgPyBgJHtfdGhpczIudXJsfS9idWNrZXQ/JHtxdWVyeVN0cmluZ31gIDogYCR7X3RoaXMyLnVybH0vYnVja2V0YDtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IGdldChfdGhpczIuZmV0Y2gsIHVybCwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhbiBleGlzdGluZyBhbmFseXRpY3MgYnVja2V0XG5cdCogQSBidWNrZXQgY2FuJ3QgYmUgZGVsZXRlZCB3aXRoIGV4aXN0aW5nIG9iamVjdHMgaW5zaWRlIGl0XG5cdCogWW91IG11c3QgZmlyc3QgZW1wdHkgdGhlIGJ1Y2tldCBiZWZvcmUgZGVsZXRpb25cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcGFyYW0gYnVja2V0TmFtZSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byBkZWxldGVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggcmVzcG9uc2UgY29udGFpbmluZyBzdWNjZXNzIG1lc3NhZ2Ugb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlIERlbGV0ZSBhbmFseXRpY3MgYnVja2V0XG5cdCogYGBganNcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC5hbmFseXRpY3Ncblx0KiAgIC5kZWxldGVCdWNrZXQoJ2FuYWx5dGljcy1kYXRhJylcblx0KiBgYGBcblx0KlxuXHQqIFJlc3BvbnNlOlxuXHQqIGBgYGpzb25cblx0KiB7XG5cdCogICBcImRhdGFcIjoge1xuXHQqICAgICBcIm1lc3NhZ2VcIjogXCJTdWNjZXNzZnVsbHkgZGVsZXRlZFwiXG5cdCogICB9LFxuXHQqICAgXCJlcnJvclwiOiBudWxsXG5cdCogfVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQoYnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCByZW1vdmUoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9idWNrZXQvJHtidWNrZXROYW1lfWAsIHt9LCB7IGhlYWRlcnM6IF90aGlzMy5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzMy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqXG5cdCogQGFscGhhXG5cdCpcblx0KiBHZXQgYW4gSWNlYmVyZyBSRVNUIENhdGFsb2cgY2xpZW50IGNvbmZpZ3VyZWQgZm9yIGEgc3BlY2lmaWMgYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIFVzZSB0aGlzIHRvIHBlcmZvcm0gYWR2YW5jZWQgdGFibGUgYW5kIG5hbWVzcGFjZSBvcGVyYXRpb25zIHdpdGhpbiB0aGUgYnVja2V0XG5cdCogVGhlIHJldHVybmVkIGNsaWVudCBwcm92aWRlcyBmdWxsIGFjY2VzcyB0byB0aGUgQXBhY2hlIEljZWJlcmcgUkVTVCBDYXRhbG9nIEFQSVxuXHQqIHdpdGggdGhlIFN1cGFiYXNlIGB7IGRhdGEsIGVycm9yIH1gIHBhdHRlcm4gZm9yIGNvbnNpc3RlbnQgZXJyb3IgaGFuZGxpbmcgb24gYWxsIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IEFuYWx5dGljcyBCdWNrZXRzXG5cdCogQHBhcmFtIGJ1Y2tldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgYW5hbHl0aWNzIGJ1Y2tldCAod2FyZWhvdXNlKSB0byBjb25uZWN0IHRvXG5cdCogQHJldHVybnMgVGhlIHdyYXBwZWQgSWNlYmVyZyBjYXRhbG9nIGNsaWVudFxuXHQqIEB0aHJvd3Mge1N0b3JhZ2VFcnJvcn0gSWYgdGhlIGJ1Y2tldCBuYW1lIGlzIGludmFsaWRcblx0KlxuXHQqIEBleGFtcGxlIEdldCBjYXRhbG9nIGFuZCBjcmVhdGUgdGFibGVcblx0KiBgYGBqc1xuXHQqIC8vIEZpcnN0LCBjcmVhdGUgYW4gYW5hbHl0aWNzIGJ1Y2tldFxuXHQqIGNvbnN0IHsgZGF0YTogYnVja2V0LCBlcnJvcjogYnVja2V0RXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLmFuYWx5dGljc1xuXHQqICAgLmNyZWF0ZUJ1Y2tldCgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gR2V0IHRoZSBJY2ViZXJnIGNhdGFsb2cgZm9yIHRoYXQgYnVja2V0XG5cdCogY29uc3QgY2F0YWxvZyA9IHN1cGFiYXNlLnN0b3JhZ2UuYW5hbHl0aWNzLmZyb20oJ2FuYWx5dGljcy1kYXRhJylcblx0KlxuXHQqIC8vIENyZWF0ZSBhIG5hbWVzcGFjZVxuXHQqIGNvbnN0IHsgZXJyb3I6IG5zRXJyb3IgfSA9IGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqXG5cdCogLy8gQ3JlYXRlIGEgdGFibGUgd2l0aCBzY2hlbWFcblx0KiBjb25zdCB7IGRhdGE6IHRhYmxlTWV0YWRhdGEsIGVycm9yOiB0YWJsZUVycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmNyZWF0ZVRhYmxlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddIH0sXG5cdCogICB7XG5cdCogICAgIG5hbWU6ICdldmVudHMnLFxuXHQqICAgICBzY2hlbWE6IHtcblx0KiAgICAgICB0eXBlOiAnc3RydWN0Jyxcblx0KiAgICAgICBmaWVsZHM6IFtcblx0KiAgICAgICAgIHsgaWQ6IDEsIG5hbWU6ICdpZCcsIHR5cGU6ICdsb25nJywgcmVxdWlyZWQ6IHRydWUgfSxcblx0KiAgICAgICAgIHsgaWQ6IDIsIG5hbWU6ICd0aW1lc3RhbXAnLCB0eXBlOiAndGltZXN0YW1wJywgcmVxdWlyZWQ6IHRydWUgfSxcblx0KiAgICAgICAgIHsgaWQ6IDMsIG5hbWU6ICd1c2VyX2lkJywgdHlwZTogJ3N0cmluZycsIHJlcXVpcmVkOiBmYWxzZSB9XG5cdCogICAgICAgXSxcblx0KiAgICAgICAnc2NoZW1hLWlkJzogMCxcblx0KiAgICAgICAnaWRlbnRpZmllci1maWVsZC1pZHMnOiBbMV1cblx0KiAgICAgfSxcblx0KiAgICAgJ3BhcnRpdGlvbi1zcGVjJzoge1xuXHQqICAgICAgICdzcGVjLWlkJzogMCxcblx0KiAgICAgICBmaWVsZHM6IFtdXG5cdCogICAgIH0sXG5cdCogICAgICd3cml0ZS1vcmRlcic6IHtcblx0KiAgICAgICAnb3JkZXItaWQnOiAwLFxuXHQqICAgICAgIGZpZWxkczogW11cblx0KiAgICAgfSxcblx0KiAgICAgcHJvcGVydGllczoge1xuXHQqICAgICAgICd3cml0ZS5mb3JtYXQuZGVmYXVsdCc6ICdwYXJxdWV0J1xuXHQqICAgICB9XG5cdCogICB9XG5cdCogKVxuXHQqIGBgYFxuXHQqXG5cdCogQGV4YW1wbGUgTGlzdCB0YWJsZXMgaW4gbmFtZXNwYWNlXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gTGlzdCBhbGwgdGFibGVzIGluIHRoZSBkZWZhdWx0IG5hbWVzcGFjZVxuXHQqIGNvbnN0IHsgZGF0YTogdGFibGVzLCBlcnJvcjogbGlzdEVycm9yIH0gPSBhd2FpdCBjYXRhbG9nLmxpc3RUYWJsZXMoeyBuYW1lc3BhY2U6IFsnZGVmYXVsdCddIH0pXG5cdCogaWYgKGxpc3RFcnJvcikge1xuXHQqICAgaWYgKGxpc3RFcnJvci5pc05vdEZvdW5kKCkpIHtcblx0KiAgICAgY29uc29sZS5sb2coJ05hbWVzcGFjZSBub3QgZm91bmQnKVxuXHQqICAgfVxuXHQqICAgcmV0dXJuXG5cdCogfVxuXHQqIGNvbnNvbGUubG9nKHRhYmxlcykgLy8gW3sgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSwgbmFtZTogJ2V2ZW50cycgfV1cblx0KiBgYGBcblx0KlxuXHQqIEBleGFtcGxlIFdvcmtpbmcgd2l0aCBuYW1lc3BhY2VzXG5cdCogYGBganNcblx0KiBjb25zdCBjYXRhbG9nID0gc3VwYWJhc2Uuc3RvcmFnZS5hbmFseXRpY3MuZnJvbSgnYW5hbHl0aWNzLWRhdGEnKVxuXHQqXG5cdCogLy8gTGlzdCBhbGwgbmFtZXNwYWNlc1xuXHQqIGNvbnN0IHsgZGF0YTogbmFtZXNwYWNlcyB9ID0gYXdhaXQgY2F0YWxvZy5saXN0TmFtZXNwYWNlcygpXG5cdCpcblx0KiAvLyBDcmVhdGUgbmFtZXNwYWNlIHdpdGggcHJvcGVydGllc1xuXHQqIGF3YWl0IGNhdGFsb2cuY3JlYXRlTmFtZXNwYWNlKFxuXHQqICAgeyBuYW1lc3BhY2U6IFsncHJvZHVjdGlvbiddIH0sXG5cdCogICB7IHByb3BlcnRpZXM6IHsgb3duZXI6ICdkYXRhLXRlYW0nLCBlbnY6ICdwcm9kJyB9IH1cblx0KiApXG5cdCogYGBgXG5cdCpcblx0KiBAZXhhbXBsZSBDbGVhbnVwIG9wZXJhdGlvbnNcblx0KiBgYGBqc1xuXHQqIGNvbnN0IGNhdGFsb2cgPSBzdXBhYmFzZS5zdG9yYWdlLmFuYWx5dGljcy5mcm9tKCdhbmFseXRpY3MtZGF0YScpXG5cdCpcblx0KiAvLyBEcm9wIHRhYmxlIHdpdGggcHVyZ2Ugb3B0aW9uIChyZW1vdmVzIGFsbCBkYXRhKVxuXHQqIGNvbnN0IHsgZXJyb3I6IGRyb3BFcnJvciB9ID0gYXdhaXQgY2F0YWxvZy5kcm9wVGFibGUoXG5cdCogICB7IG5hbWVzcGFjZTogWydkZWZhdWx0J10sIG5hbWU6ICdldmVudHMnIH0sXG5cdCogICB7IHB1cmdlOiB0cnVlIH1cblx0KiApXG5cdCpcblx0KiBpZiAoZHJvcEVycm9yPy5pc05vdEZvdW5kKCkpIHtcblx0KiAgIGNvbnNvbGUubG9nKCdUYWJsZSBkb2VzIG5vdCBleGlzdCcpXG5cdCogfVxuXHQqXG5cdCogLy8gRHJvcCBuYW1lc3BhY2UgKG11c3QgYmUgZW1wdHkpXG5cdCogYXdhaXQgY2F0YWxvZy5kcm9wTmFtZXNwYWNlKHsgbmFtZXNwYWNlOiBbJ2RlZmF1bHQnXSB9KVxuXHQqIGBgYFxuXHQqXG5cdCogQHJlbWFya3Ncblx0KiBUaGlzIG1ldGhvZCBwcm92aWRlcyBhIGJyaWRnZSBiZXR3ZWVuIFN1cGFiYXNlJ3MgYnVja2V0IG1hbmFnZW1lbnQgYW5kIHRoZSBzdGFuZGFyZFxuXHQqIEFwYWNoZSBJY2ViZXJnIFJFU1QgQ2F0YWxvZyBBUEkuIFRoZSBidWNrZXQgbmFtZSBtYXBzIHRvIHRoZSBJY2ViZXJnIHdhcmVob3VzZSBwYXJhbWV0ZXIuXG5cdCogQWxsIGF1dGhlbnRpY2F0aW9uIGFuZCBjb25maWd1cmF0aW9uIGlzIGhhbmRsZWQgYXV0b21hdGljYWxseSB1c2luZyB5b3VyIFN1cGFiYXNlIGNyZWRlbnRpYWxzLlxuXHQqXG5cdCogKipFcnJvciBIYW5kbGluZyoqOiBJbnZhbGlkIGJ1Y2tldCBuYW1lcyB0aHJvdyBpbW1lZGlhdGVseS4gQWxsIGNhdGFsb2dcblx0KiBvcGVyYXRpb25zIHJldHVybiBgeyBkYXRhLCBlcnJvciB9YCB3aGVyZSBlcnJvcnMgYXJlIGBJY2ViZXJnRXJyb3JgIGluc3RhbmNlcyBmcm9tIGljZWJlcmctanMuXG5cdCogVXNlIGhlbHBlciBtZXRob2RzIGxpa2UgYGVycm9yLmlzTm90Rm91bmQoKWAgb3IgY2hlY2sgYGVycm9yLnN0YXR1c2AgZm9yIHNwZWNpZmljIGVycm9yIGhhbmRsaW5nLlxuXHQqIFVzZSBgLnRocm93T25FcnJvcigpYCBvbiB0aGUgYW5hbHl0aWNzIGNsaWVudCBpZiB5b3UgcHJlZmVyIGV4Y2VwdGlvbnMgZm9yIGNhdGFsb2cgb3BlcmF0aW9ucy5cblx0KlxuXHQqICoqQ2xlYW51cCBPcGVyYXRpb25zKio6IFdoZW4gdXNpbmcgYGRyb3BUYWJsZWAsIHRoZSBgcHVyZ2U6IHRydWVgIG9wdGlvbiBwZXJtYW5lbnRseVxuXHQqIGRlbGV0ZXMgYWxsIHRhYmxlIGRhdGEuIFdpdGhvdXQgaXQsIHRoZSB0YWJsZSBpcyBtYXJrZWQgYXMgZGVsZXRlZCBidXQgZGF0YSByZW1haW5zLlxuXHQqXG5cdCogKipMaWJyYXJ5IERlcGVuZGVuY3kqKjogVGhlIHJldHVybmVkIGNhdGFsb2cgd3JhcHMgYEljZWJlcmdSZXN0Q2F0YWxvZ2AgZnJvbSBpY2ViZXJnLWpzLlxuXHQqIEZvciBjb21wbGV0ZSBBUEkgZG9jdW1lbnRhdGlvbiBhbmQgYWR2YW5jZWQgdXNhZ2UsIHJlZmVyIHRvIHRoZVxuXHQqIFtpY2ViZXJnLWpzIGRvY3VtZW50YXRpb25dKGh0dHBzOi8vc3VwYWJhc2UuZ2l0aHViLmlvL2ljZWJlcmctanMvKS5cblx0Ki9cblx0ZnJvbShidWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0aWYgKCFpc1ZhbGlkQnVja2V0TmFtZShidWNrZXROYW1lKSkgdGhyb3cgbmV3IFN0b3JhZ2VFcnJvcihcIkludmFsaWQgYnVja2V0IG5hbWU6IEZpbGUsIGZvbGRlciwgYW5kIGJ1Y2tldCBuYW1lcyBtdXN0IGZvbGxvdyBBV1Mgb2JqZWN0IGtleSBuYW1pbmcgZ3VpZGVsaW5lcyBhbmQgc2hvdWxkIGF2b2lkIHRoZSB1c2Ugb2YgYW55IG90aGVyIGNoYXJhY3RlcnMuXCIpO1xuXHRcdGNvbnN0IGNhdGFsb2cgPSBuZXcgSWNlYmVyZ1Jlc3RDYXRhbG9nKHtcblx0XHRcdGJhc2VVcmw6IHRoaXMudXJsLFxuXHRcdFx0Y2F0YWxvZ05hbWU6IGJ1Y2tldE5hbWUsXG5cdFx0XHRhdXRoOiB7XG5cdFx0XHRcdHR5cGU6IFwiY3VzdG9tXCIsXG5cdFx0XHRcdGdldEhlYWRlcnM6IGFzeW5jICgpID0+IF90aGlzNC5oZWFkZXJzXG5cdFx0XHR9LFxuXHRcdFx0ZmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0XHRjb25zdCBzaG91bGRUaHJvd09uRXJyb3IgPSB0aGlzLnNob3VsZFRocm93T25FcnJvcjtcblx0XHRyZXR1cm4gbmV3IFByb3h5KGNhdGFsb2csIHsgZ2V0KHRhcmdldCwgcHJvcCkge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSB0YXJnZXRbcHJvcF07XG5cdFx0XHRpZiAodHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiB2YWx1ZTtcblx0XHRcdHJldHVybiBhc3luYyAoLi4uYXJncykgPT4ge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBhd2FpdCB2YWx1ZS5hcHBseSh0YXJnZXQsIGFyZ3MpLFxuXHRcdFx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdGlmIChzaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gfSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9jb25zdGFudHMudHNcbmNvbnN0IERFRkFVTFRfSEVBREVSUyA9IHtcblx0XCJYLUNsaWVudC1JbmZvXCI6IGBzdG9yYWdlLWpzLyR7dmVyc2lvbn1gLFxuXHRcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL2Vycm9ycy50c1xuLyoqXG4qIEJhc2UgZXJyb3IgY2xhc3MgZm9yIGFsbCBTdG9yYWdlIFZlY3RvcnMgZXJyb3JzXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSkge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMuX19pc1N0b3JhZ2VWZWN0b3JzRXJyb3IgPSB0cnVlO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNFcnJvclwiO1xuXHR9XG59O1xuLyoqXG4qIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBTdG9yYWdlVmVjdG9yc0Vycm9yXG4qIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIFN0b3JhZ2VWZWN0b3JzRXJyb3JcbiovXG5mdW5jdGlvbiBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpIHtcblx0cmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCAmJiBcIl9faXNTdG9yYWdlVmVjdG9yc0Vycm9yXCIgaW4gZXJyb3I7XG59XG4vKipcbiogQVBJIGVycm9yIHJldHVybmVkIGZyb20gUzMgVmVjdG9ycyBzZXJ2aWNlXG4qIEluY2x1ZGVzIEhUVFAgc3RhdHVzIGNvZGUgYW5kIHNlcnZpY2Utc3BlY2lmaWMgZXJyb3IgY29kZVxuKi9cbnZhciBTdG9yYWdlVmVjdG9yc0FwaUVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlVmVjdG9yc0Vycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJTdG9yYWdlVmVjdG9yc0FwaUVycm9yXCI7XG5cdFx0dGhpcy5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcblx0fVxuXHR0b0pTT04oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdG5hbWU6IHRoaXMubmFtZSxcblx0XHRcdG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGVcblx0XHR9O1xuXHR9XG59O1xuLyoqXG4qIFVua25vd24gZXJyb3IgdGhhdCBkb2Vzbid0IG1hdGNoIGV4cGVjdGVkIGVycm9yIHBhdHRlcm5zXG4qIFdyYXBzIHRoZSBvcmlnaW5hbCBlcnJvciBmb3IgZGVidWdnaW5nXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yID0gY2xhc3MgZXh0ZW5kcyBTdG9yYWdlVmVjdG9yc0Vycm9yIHtcblx0Y29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuXHRcdHN1cGVyKG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9IFwiU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3JcIjtcblx0XHR0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuXHR9XG59O1xuLyoqXG4qIEVycm9yIGNvZGVzIHNwZWNpZmljIHRvIFMzIFZlY3RvcnMgQVBJXG4qIE1hcHMgQVdTIHNlcnZpY2UgZXJyb3JzIHRvIGFwcGxpY2F0aW9uLWZyaWVuZGx5IGVycm9yIGNvZGVzXG4qL1xubGV0IFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDEpIHtcblx0LyoqIEludGVybmFsIHNlcnZlciBmYXVsdCAoSFRUUCA1MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJJbnRlcm5hbEVycm9yXCJdID0gXCJJbnRlcm5hbEVycm9yXCI7XG5cdC8qKiBSZXNvdXJjZSBhbHJlYWR5IGV4aXN0cyAvIGNvbmZsaWN0IChIVFRQIDQwOSkgKi9cblx0U3RvcmFnZVZlY3RvcnNFcnJvckNvZGUkMVtcIlMzVmVjdG9yQ29uZmxpY3RFeGNlcHRpb25cIl0gPSBcIlMzVmVjdG9yQ29uZmxpY3RFeGNlcHRpb25cIjtcblx0LyoqIFJlc291cmNlIG5vdCBmb3VuZCAoSFRUUCA0MDQpICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCJdID0gXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCI7XG5cdC8qKiBEZWxldGUgYnVja2V0IHdoaWxlIG5vdCBlbXB0eSAoSFRUUCA0MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5XCJdID0gXCJTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5XCI7XG5cdC8qKiBFeGNlZWRzIGJ1Y2tldCBxdW90YS9saW1pdCAoSFRUUCA0MDApICovXG5cdFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDFbXCJTM1ZlY3Rvck1heEJ1Y2tldHNFeGNlZWRlZFwiXSA9IFwiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIjtcblx0LyoqIEV4Y2VlZHMgaW5kZXggcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuXHRTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxW1wiUzNWZWN0b3JNYXhJbmRleGVzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCI7XG5cdHJldHVybiBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSQxO1xufSh7fSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9oZWxwZXJzLnRzXG4vKipcbiogUmVzb2x2ZXMgdGhlIGZldGNoIGltcGxlbWVudGF0aW9uIHRvIHVzZVxuKiBVc2VzIGN1c3RvbSBmZXRjaCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIHVzZXMgbmF0aXZlIGZldGNoXG4qXG4qIEBwYXJhbSBjdXN0b21GZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuKiBAcmV0dXJucyBSZXNvbHZlZCBmZXRjaCBmdW5jdGlvblxuKi9cbmNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuXHRpZiAoY3VzdG9tRmV0Y2gpIHJldHVybiAoLi4uYXJncykgPT4gY3VzdG9tRmV0Y2goLi4uYXJncyk7XG5cdHJldHVybiAoLi4uYXJncykgPT4gZmV0Y2goLi4uYXJncyk7XG59O1xuLyoqXG4qIFJlc29sdmVzIHRoZSBSZXNwb25zZSBjb25zdHJ1Y3RvciB0byB1c2VcbiogUmV0dXJucyBuYXRpdmUgUmVzcG9uc2UgY29uc3RydWN0b3JcbipcbiogQHJldHVybnMgUmVzcG9uc2UgY29uc3RydWN0b3JcbiovXG5jb25zdCByZXNvbHZlUmVzcG9uc2UgPSAoKSA9PiB7XG5cdHJldHVybiBSZXNwb25zZTtcbn07XG4vKipcbiogRGV0ZXJtaW5lIGlmIGlucHV0IGlzIGEgcGxhaW4gb2JqZWN0XG4qIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbipcbiogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2tcbiogQHJldHVybnMgVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdFxuKiBAc291cmNlIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvaXMtcGxhaW4tb2JqXG4qL1xuY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG5cdHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTtcbn07XG4vKipcbiogTm9ybWFsaXplcyBhIG51bWJlciBhcnJheSB0byBmbG9hdDMyIGZvcm1hdFxuKiBFbnN1cmVzIGFsbCB2ZWN0b3IgdmFsdWVzIGFyZSB2YWxpZCAzMi1iaXQgZmxvYXRzXG4qXG4qIEBwYXJhbSB2YWx1ZXMgLSBBcnJheSBvZiBudW1iZXJzIHRvIG5vcm1hbGl6ZVxuKiBAcmV0dXJucyBOb3JtYWxpemVkIGZsb2F0MzIgYXJyYXlcbiovXG5jb25zdCBub3JtYWxpemVUb0Zsb2F0MzIgPSAodmFsdWVzKSA9PiB7XG5cdHJldHVybiBBcnJheS5mcm9tKG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzKSk7XG59O1xuLyoqXG4qIFZhbGlkYXRlcyB2ZWN0b3IgZGltZW5zaW9ucyBtYXRjaCBleHBlY3RlZCBkaW1lbnNpb25cbiogVGhyb3dzIGVycm9yIGlmIGRpbWVuc2lvbnMgZG9uJ3QgbWF0Y2hcbipcbiogQHBhcmFtIHZlY3RvciAtIFZlY3RvciBkYXRhIHRvIHZhbGlkYXRlXG4qIEBwYXJhbSBleHBlY3RlZERpbWVuc2lvbiAtIEV4cGVjdGVkIHZlY3RvciBkaW1lbnNpb25cbiogQHRocm93cyBFcnJvciBpZiBkaW1lbnNpb25zIGRvbid0IG1hdGNoXG4qL1xuY29uc3QgdmFsaWRhdGVWZWN0b3JEaW1lbnNpb24gPSAodmVjdG9yLCBleHBlY3RlZERpbWVuc2lvbikgPT4ge1xuXHRpZiAoZXhwZWN0ZWREaW1lbnNpb24gIT09IHZvaWQgMCAmJiB2ZWN0b3IuZmxvYXQzMi5sZW5ndGggIT09IGV4cGVjdGVkRGltZW5zaW9uKSB0aHJvdyBuZXcgRXJyb3IoYFZlY3RvciBkaW1lbnNpb24gbWlzbWF0Y2g6IGV4cGVjdGVkICR7ZXhwZWN0ZWREaW1lbnNpb259LCBnb3QgJHt2ZWN0b3IuZmxvYXQzMi5sZW5ndGh9YCk7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL3ZlY3RvcnMvZmV0Y2gudHNcbi8qKlxuKiBFeHRyYWN0cyBlcnJvciBtZXNzYWdlIGZyb20gdmFyaW91cyBlcnJvciByZXNwb25zZSBmb3JtYXRzXG4qIEBwYXJhbSBlcnIgLSBFcnJvciBvYmplY3QgZnJvbSBBUElcbiogQHJldHVybnMgSHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuKi9cbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyKSA9PiBlcnIubXNnIHx8IGVyci5tZXNzYWdlIHx8IGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fCBlcnIuZXJyb3IgfHwgSlNPTi5zdHJpbmdpZnkoZXJyKTtcbi8qKlxuKiBIYW5kbGVzIGZldGNoIGVycm9ycyBhbmQgY29udmVydHMgdGhlbSB0byBTdG9yYWdlVmVjdG9ycyBlcnJvciB0eXBlc1xuKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgY2F1Z2h0IGZyb20gZmV0Y2hcbiogQHBhcmFtIHJlamVjdCAtIFByb21pc2UgcmVqZWN0aW9uIGZ1bmN0aW9uXG4qIEBwYXJhbSBvcHRpb25zIC0gRmV0Y2ggb3B0aW9ucyB0aGF0IG1heSBhZmZlY3QgZXJyb3IgaGFuZGxpbmdcbiovXG5jb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiB7XG5cdGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgXCJzdGF0dXNcIiBpbiBlcnJvciAmJiBcIm9rXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkge1xuXHRcdGNvbnN0IHN0YXR1cyA9IGVycm9yLnN0YXR1cyB8fCA1MDA7XG5cdFx0Y29uc3QgcmVzcG9uc2VFcnJvciA9IGVycm9yO1xuXHRcdGlmICh0eXBlb2YgcmVzcG9uc2VFcnJvci5qc29uID09PSBcImZ1bmN0aW9uXCIpIHJlc3BvbnNlRXJyb3IuanNvbigpLnRoZW4oKGVycikgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IChlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuc3RhdHVzQ29kZSkgfHwgKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5jb2RlKSB8fCBzdGF0dXMgKyBcIlwiO1xuXHRcdFx0cmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyKSwgc3RhdHVzLCBzdGF0dXNDb2RlKSk7XG5cdFx0fSkuY2F0Y2goKCkgPT4ge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRyZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IocmVzcG9uc2VFcnJvci5zdGF0dXNUZXh0IHx8IGBIVFRQICR7c3RhdHVzfSBlcnJvcmAsIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH0pO1xuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArIFwiXCI7XG5cdFx0XHRyZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IocmVzcG9uc2VFcnJvci5zdGF0dXNUZXh0IHx8IGBIVFRQICR7c3RhdHVzfSBlcnJvcmAsIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuXHRcdH1cblx0fSBlbHNlIHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSk7XG59O1xuLyoqXG4qIEJ1aWxkcyByZXF1ZXN0IHBhcmFtZXRlcnMgZm9yIGZldGNoIGNhbGxzXG4qIEBwYXJhbSBtZXRob2QgLSBIVFRQIG1ldGhvZFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzIGxpa2UgQWJvcnRTaWduYWxcbiogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgKHdpbGwgYmUgSlNPTiBzdHJpbmdpZmllZCBpZiBwbGFpbiBvYmplY3QpXG4qIEByZXR1cm5zIENvbXBsZXRlIGZldGNoIHJlcXVlc3QgcGFyYW1ldGVyc1xuKi9cbmNvbnN0IF9nZXRSZXF1ZXN0UGFyYW1zID0gKG1ldGhvZCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkgPT4ge1xuXHRjb25zdCBwYXJhbXMgPSB7XG5cdFx0bWV0aG9kLFxuXHRcdGhlYWRlcnM6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycykgfHwge31cblx0fTtcblx0aWYgKG1ldGhvZCA9PT0gXCJHRVRcIiB8fCAhYm9keSkgcmV0dXJuIHBhcmFtcztcblx0aWYgKGlzUGxhaW5PYmplY3QoYm9keSkpIHtcblx0XHRwYXJhbXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuXHRcdHBhcmFtcy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdH0gZWxzZSBwYXJhbXMuYm9keSA9IGJvZHk7XG5cdHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgcGFyYW1zKSwgcGFyYW1ldGVycyk7XG59O1xuLyoqXG4qIEludGVybmFsIHJlcXVlc3QgaGFuZGxlciB0aGF0IHdyYXBzIGZldGNoIHdpdGggZXJyb3IgaGFuZGxpbmdcbiogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiogQHBhcmFtIG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4qIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4qIEBwYXJhbSBwYXJhbWV0ZXJzIC0gQWRkaXRpb25hbCBmZXRjaCBwYXJhbWV0ZXJzXG4qIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5XG4qIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2Ugb3IgZXJyb3JcbiovXG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKS50aGVuKChyZXN1bHQpID0+IHtcblx0XHRcdGlmICghcmVzdWx0Lm9rKSB0aHJvdyByZXN1bHQ7XG5cdFx0XHRpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5vUmVzb2x2ZUpzb24pIHJldHVybiByZXN1bHQ7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKTtcblx0XHRcdGlmICghY29udGVudFR5cGUgfHwgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vanNvblwiKSkgcmV0dXJuIHt9O1xuXHRcdFx0cmV0dXJuIHJlc3VsdC5qc29uKCk7XG5cdFx0fSkudGhlbigoZGF0YSkgPT4gcmVzb2x2ZShkYXRhKSkuY2F0Y2goKGVycm9yKSA9PiBoYW5kbGVFcnJvcihlcnJvciwgcmVqZWN0LCBvcHRpb25zKSk7XG5cdH0pO1xufVxuLyoqXG4qIFBlcmZvcm1zIGEgUE9TVCByZXF1ZXN0XG4qIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4qIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSB0byBiZSBKU09OIHN0cmluZ2lmaWVkXG4qIEBwYXJhbSBvcHRpb25zIC0gQ3VzdG9tIGZldGNoIG9wdGlvbnNcbiogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBhcnNlZCByZXNwb25zZVxuKi9cbmFzeW5jIGZ1bmN0aW9uIHBvc3QoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG5cdHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBcIlBPU1RcIiwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL1ZlY3RvckluZGV4QXBpLnRzXG4vKipcbiogQGhpZGRlblxuKiBCYXNlIGltcGxlbWVudGF0aW9uIGZvciB2ZWN0b3IgaW5kZXggb3BlcmF0aW9ucy5cbiogVXNlIHtAbGluayBWZWN0b3JCdWNrZXRTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JylgIGluc3RlYWQuXG4qL1xudmFyIFZlY3RvckluZGV4QXBpID0gY2xhc3Mge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JJbmRleEFwaSBpbnN0YW5jZSAqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG5cdFx0dGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuXHRcdHRoaXMuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcblx0XHR0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoJDEpO1xuXHR9XG5cdC8qKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlICovXG5cdHRocm93T25FcnJvcigpIHtcblx0XHR0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblx0LyoqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IHdpdGhpbiBhIGJ1Y2tldCAqL1xuXHRhc3luYyBjcmVhdGVJbmRleChvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9DcmVhdGVJbmRleGAsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4ICovXG5cdGFzeW5jIGdldEluZGV4KHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSkge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0SW5kZXhgLCB7XG5cdFx0XHRcdFx0dmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdFx0XHRpbmRleE5hbWVcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogTGlzdHMgdmVjdG9yIGluZGV4ZXMgd2l0aGluIGEgYnVja2V0IHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RJbmRleGVzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L0xpc3RJbmRleGVzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogRGVsZXRlcyBhIHZlY3RvciBpbmRleCBhbmQgYWxsIGl0cyBkYXRhICovXG5cdGFzeW5jIGRlbGV0ZUluZGV4KHZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vRGVsZXRlSW5kZXhgLCB7XG5cdFx0XHRcdFx0dmVjdG9yQnVja2V0TmFtZSxcblx0XHRcdFx0XHRpbmRleE5hbWVcblx0XHRcdFx0fSwgeyBoZWFkZXJzOiBfdGhpczQuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczQuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi92ZWN0b3JzL1ZlY3RvckRhdGFBcGkudHNcbi8qKlxuKiBAaGlkZGVuXG4qIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMuXG4qIFVzZSB7QGxpbmsgVmVjdG9ySW5kZXhTY29wZX0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnYnVja2V0JykuaW5kZXgoJ2lkeCcpYCBpbnN0ZWFkLlxuKi9cbnZhciBWZWN0b3JEYXRhQXBpID0gY2xhc3Mge1xuXHQvKiogQ3JlYXRlcyBhIG5ldyBWZWN0b3JEYXRhQXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuXHRcdHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gkMSk7XG5cdH1cblx0LyoqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbSBpbiB0aGUgcmVzcG9uc2UgKi9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKiogSW5zZXJ0cyBvciB1cGRhdGVzIHZlY3RvcnMgaW4gYmF0Y2ggKDEtNTAwIHBlciByZXF1ZXN0KSAqL1xuXHRhc3luYyBwdXRWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAob3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy52ZWN0b3JzLmxlbmd0aCA+IDUwMCkgdGhyb3cgbmV3IEVycm9yKFwiVmVjdG9yIGJhdGNoIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwMCBpdGVtc1wiKTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMuZmV0Y2gsIGAke190aGlzLnVybH0vUHV0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMuaGVhZGVycyB9KSB8fCB7fSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBSZXRyaWV2ZXMgdmVjdG9ycyBieSB0aGVpciBrZXlzIGluIGJhdGNoICovXG5cdGFzeW5jIGdldFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzMi5mZXRjaCwgYCR7X3RoaXMyLnVybH0vR2V0VmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMyLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMyLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIExpc3RzIHZlY3RvcnMgaW4gYW4gaW5kZXggd2l0aCBwYWdpbmF0aW9uICovXG5cdGFzeW5jIGxpc3RWZWN0b3JzKG9wdGlvbnMpIHtcblx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudENvdW50ICE9PSB2b2lkIDApIHtcblx0XHRcdFx0aWYgKG9wdGlvbnMuc2VnbWVudENvdW50IDwgMSB8fCBvcHRpb25zLnNlZ21lbnRDb3VudCA+IDE2KSB0aHJvdyBuZXcgRXJyb3IoXCJzZWdtZW50Q291bnQgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE2XCIpO1xuXHRcdFx0XHRpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggIT09IHZvaWQgMCkge1xuXHRcdFx0XHRcdGlmIChvcHRpb25zLnNlZ21lbnRJbmRleCA8IDAgfHwgb3B0aW9ucy5zZWdtZW50SW5kZXggPj0gb3B0aW9ucy5zZWdtZW50Q291bnQpIHRocm93IG5ldyBFcnJvcihgc2VnbWVudEluZGV4IG11c3QgYmUgYmV0d2VlbiAwIGFuZCAke29wdGlvbnMuc2VnbWVudENvdW50IC0gMX1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpczMuZmV0Y2gsIGAke190aGlzMy51cmx9L0xpc3RWZWN0b3JzYCwgb3B0aW9ucywgeyBoZWFkZXJzOiBfdGhpczMuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczMuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIHVzaW5nIGFwcHJveGltYXRlIG5lYXJlc3QgbmVpZ2hib3Igc2VhcmNoICovXG5cdGFzeW5jIHF1ZXJ5VmVjdG9ycyhvcHRpb25zKSB7XG5cdFx0dmFyIF90aGlzNCA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXM0LmZldGNoLCBgJHtfdGhpczQudXJsfS9RdWVyeVZlY3RvcnNgLCBvcHRpb25zLCB7IGhlYWRlcnM6IF90aGlzNC5oZWFkZXJzIH0pLFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzNC5zaG91bGRUaHJvd09uRXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IG51bGwsXG5cdFx0XHRcdGVycm9yXG5cdFx0XHR9O1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXHR9XG5cdC8qKiBEZWxldGVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaCAoMS01MDAgcGVyIHJlcXVlc3QpICovXG5cdGFzeW5jIGRlbGV0ZVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfdGhpczUgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRpZiAob3B0aW9ucy5rZXlzLmxlbmd0aCA8IDEgfHwgb3B0aW9ucy5rZXlzLmxlbmd0aCA+IDUwMCkgdGhyb3cgbmV3IEVycm9yKFwiS2V5cyBiYXRjaCBzaXplIG11c3QgYmUgYmV0d2VlbiAxIGFuZCA1MDAgaXRlbXNcIik7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNS5mZXRjaCwgYCR7X3RoaXM1LnVybH0vRGVsZXRlVmVjdG9yc2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXM1LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM1LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9WZWN0b3JCdWNrZXRBcGkudHNcbi8qKlxuKiBAaGlkZGVuXG4qIEJhc2UgaW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBidWNrZXQgb3BlcmF0aW9ucy5cbiogVXNlIHtAbGluayBTdG9yYWdlVmVjdG9yc0NsaWVudH0gdmlhIGBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnNgIGluc3RlYWQuXG4qL1xudmFyIFZlY3RvckJ1Y2tldEFwaSA9IGNsYXNzIHtcblx0LyoqIENyZWF0ZXMgYSBuZXcgVmVjdG9yQnVja2V0QXBpIGluc3RhbmNlICovXG5cdGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCQxKSB7XG5cdFx0dGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcblx0XHR0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG5cdFx0dGhpcy5oZWFkZXJzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuXHRcdHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gkMSk7XG5cdH1cblx0LyoqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbSBpbiB0aGUgcmVzcG9uc2UgKi9cblx0dGhyb3dPbkVycm9yKCkge1xuXHRcdHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXHQvKiogQ3JlYXRlcyBhIG5ldyB2ZWN0b3IgYnVja2V0ICovXG5cdGFzeW5jIGNyZWF0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzID0gdGhpcztcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogYXdhaXQgcG9zdChfdGhpcy5mZXRjaCwgYCR7X3RoaXMudXJsfS9DcmVhdGVWZWN0b3JCdWNrZXRgLCB7IHZlY3RvckJ1Y2tldE5hbWUgfSwgeyBoZWFkZXJzOiBfdGhpcy5oZWFkZXJzIH0pIHx8IHt9LFxuXHRcdFx0XHRlcnJvcjogbnVsbFxuXHRcdFx0fTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKF90aGlzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIFJldHJpZXZlcyBtZXRhZGF0YSBmb3IgYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0ICovXG5cdGFzeW5jIGdldEJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMyLmZldGNoLCBgJHtfdGhpczIudXJsfS9HZXRWZWN0b3JCdWNrZXRgLCB7IHZlY3RvckJ1Y2tldE5hbWUgfSwgeyBoZWFkZXJzOiBfdGhpczIuaGVhZGVycyB9KSxcblx0XHRcdFx0ZXJyb3I6IG51bGxcblx0XHRcdH07XG5cdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGlmIChfdGhpczIuc2hvdWxkVGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSByZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBudWxsLFxuXHRcdFx0XHRlcnJvclxuXHRcdFx0fTtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXHQvKiogTGlzdHMgdmVjdG9yIGJ1Y2tldHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb24gKi9cblx0YXN5bmMgbGlzdEJ1Y2tldHMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGRhdGE6IGF3YWl0IHBvc3QoX3RoaXMzLmZldGNoLCBgJHtfdGhpczMudXJsfS9MaXN0VmVjdG9yQnVja2V0c2AsIG9wdGlvbnMsIHsgaGVhZGVyczogX3RoaXMzLmhlYWRlcnMgfSksXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXMzLnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cblx0LyoqIERlbGV0ZXMgYSB2ZWN0b3IgYnVja2V0IChtdXN0IGJlIGVtcHR5IGZpcnN0KSAqL1xuXHRhc3luYyBkZWxldGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRkYXRhOiBhd2FpdCBwb3N0KF90aGlzNC5mZXRjaCwgYCR7X3RoaXM0LnVybH0vRGVsZXRlVmVjdG9yQnVja2V0YCwgeyB2ZWN0b3JCdWNrZXROYW1lIH0sIHsgaGVhZGVyczogX3RoaXM0LmhlYWRlcnMgfSkgfHwge30sXG5cdFx0XHRcdGVycm9yOiBudWxsXG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoX3RoaXM0LnNob3VsZFRocm93T25FcnJvcikgdGhyb3cgZXJyb3I7XG5cdFx0XHRpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkgcmV0dXJuIHtcblx0XHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdFx0ZXJyb3Jcblx0XHRcdH07XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9saWIvdmVjdG9ycy9TdG9yYWdlVmVjdG9yc0NsaWVudC50c1xuLyoqXG4qXG4qIEBhbHBoYVxuKlxuKiBNYWluIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBTMyBWZWN0b3JzIEFQSVxuKiBQcm92aWRlcyBhY2Nlc3MgdG8gYnVja2V0LCBpbmRleCwgYW5kIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcbipcbiogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cbipcbiogKipVc2FnZSBQYXR0ZXJuczoqKlxuKlxuKiBgYGB0eXBlc2NyaXB0XG4qIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4qICAuc3RvcmFnZVxuKiAgLnZlY3RvcnNcbiogIC5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4qXG4qIC8vIEFjY2VzcyBpbmRleCBvcGVyYXRpb25zIHZpYSBidWNrZXRzXG4qIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cycsXG4qICAgZGF0YVR5cGU6ICdmbG9hdDMyJyxcbiogICBkaW1lbnNpb246IDE1MzYsXG4qICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnXG4qIH0pXG4qXG4qIC8vIEFjY2VzcyB2ZWN0b3Igb3BlcmF0aW9ucyB2aWEgaW5kZXhcbiogY29uc3QgaW5kZXggPSBidWNrZXQuaW5kZXgoJ2RvY3VtZW50cycpXG4qIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuKiAgIHZlY3RvcnM6IFtcbiogICAgIHsga2V5OiAnZG9jLTEnLCBkYXRhOiB7IGZsb2F0MzI6IFsuLi5dIH0sIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm8nIH0gfVxuKiAgIF1cbiogfSlcbipcbiogLy8gUXVlcnkgc2ltaWxhciB2ZWN0b3JzXG4qIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcbiogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbLi4uXSB9LFxuKiAgIHRvcEs6IDUsXG4qICAgcmV0dXJuRGlzdGFuY2U6IHRydWVcbiogfSlcbiogYGBgXG4qL1xudmFyIFN0b3JhZ2VWZWN0b3JzQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBWZWN0b3JCdWNrZXRBcGkge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBTdG9yYWdlVmVjdG9yc0NsaWVudCB0aGF0IGNhbiBtYW5hZ2UgYnVja2V0cywgaW5kZXhlcywgYW5kIHZlY3RvcnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHVybCAtIEJhc2UgVVJMIG9mIHRoZSBTdG9yYWdlIFZlY3RvcnMgUkVTVCBBUEkuXG5cdCogQHBhcmFtIG9wdGlvbnMuaGVhZGVycyAtIE9wdGlvbmFsIGhlYWRlcnMgKGZvciBleGFtcGxlIGBBdXRob3JpemF0aW9uYCkgYXBwbGllZCB0byBldmVyeSByZXF1ZXN0LlxuXHQqIEBwYXJhbSBvcHRpb25zLmZldGNoIC0gT3B0aW9uYWwgY3VzdG9tIGBmZXRjaGAgaW1wbGVtZW50YXRpb24gZm9yIG5vbi1icm93c2VyIHJ1bnRpbWVzLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgY2xpZW50ID0gbmV3IFN0b3JhZ2VWZWN0b3JzQ2xpZW50KHVybCwgb3B0aW9ucylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcih1cmwsIG9wdGlvbnMuaGVhZGVycyB8fCB7fSwgb3B0aW9ucy5mZXRjaCk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcblx0KiBSZXR1cm5zIGEgc2NvcGVkIGNsaWVudCBmb3IgaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zIHdpdGhpbiB0aGUgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0XG5cdCogQHJldHVybnMgQnVja2V0LXNjb3BlZCBjbGllbnQgd2l0aCBpbmRleCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRmcm9tKHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHRyZXR1cm4gbmV3IFZlY3RvckJ1Y2tldFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIHRoaXMuZmV0Y2gpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBDcmVhdGVzIGEgbmV3IHZlY3RvciBidWNrZXRcblx0KiBWZWN0b3IgYnVja2V0cyBhcmUgY29udGFpbmVycyBmb3IgdmVjdG9yIGluZGV4ZXMgYW5kIHRoZWlyIGRhdGFcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIFVuaXF1ZSBuYW1lIGZvciB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuY3JlYXRlQnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBjcmVhdGVCdWNrZXQodmVjdG9yQnVja2V0TmFtZSkge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCA9ICgpID0+IHN1cGVyLmNyZWF0ZUJ1Y2tldCwgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCgpLmNhbGwoX3RoaXMsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldFxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBidWNrZXQgbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5nZXRCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG5cdCpcblx0KiBjb25zb2xlLmxvZygnQnVja2V0IGNyZWF0ZWQ6JywgZGF0YT8udmVjdG9yQnVja2V0LmNyZWF0aW9uVGltZSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0QnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRHZXRCdWNrZXQgPSAoKSA9PiBzdXBlci5nZXRCdWNrZXQsIF90aGlzMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0R2V0QnVja2V0KCkuY2FsbChfdGhpczIsIHZlY3RvckJ1Y2tldE5hbWUpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyBhbGwgdmVjdG9yIGJ1Y2tldHMgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb25cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGZpbHRlcnMgKHByZWZpeCwgbWF4UmVzdWx0cywgbmV4dFRva2VuKVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBsaXN0IG9mIGJ1Y2tldHMgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG5cdCogICAuc3RvcmFnZVxuXHQqICAgLnZlY3RvcnNcblx0KiAgIC5saXN0QnVja2V0cyh7IHByZWZpeDogJ2VtYmVkZGluZ3MtJyB9KVxuXHQqXG5cdCogZGF0YT8udmVjdG9yQnVja2V0cy5mb3JFYWNoKGJ1Y2tldCA9PiB7XG5cdCogICBjb25zb2xlLmxvZyhidWNrZXQudmVjdG9yQnVja2V0TmFtZSlcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0QnVja2V0cyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cyA9ICgpID0+IHN1cGVyLmxpc3RCdWNrZXRzLCBfdGhpczMgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldExpc3RCdWNrZXRzKCkuY2FsbChfdGhpczMsIG9wdGlvbnMpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIGEgdmVjdG9yIGJ1Y2tldCAoYnVja2V0IG11c3QgYmUgZW1wdHkpXG5cdCogQWxsIGluZGV4ZXMgbXVzdCBiZSBkZWxldGVkIGJlZm9yZSBkZWxldGluZyB0aGUgYnVja2V0XG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIHZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSB2ZWN0b3IgYnVja2V0IHRvIGRlbGV0ZVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG5cdCpcblx0KiBAZXhhbXBsZVxuXHQqIGBgYHR5cGVzY3JpcHRcblx0KiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuXHQqICAgLnN0b3JhZ2Vcblx0KiAgIC52ZWN0b3JzXG5cdCogICAuZGVsZXRlQnVja2V0KCdlbWJlZGRpbmdzLW9sZCcpXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0ID0gKCkgPT4gc3VwZXIuZGVsZXRlQnVja2V0LCBfdGhpczQgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldERlbGV0ZUJ1Y2tldCgpLmNhbGwoX3RoaXM0LCB2ZWN0b3JCdWNrZXROYW1lKTtcblx0fVxufTtcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG4qIFByb3ZpZGVzIGluZGV4IG1hbmFnZW1lbnQgYW5kIGFjY2VzcyB0byB2ZWN0b3Igb3BlcmF0aW9uc1xuKlxuKiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuKi9cbnZhciBWZWN0b3JCdWNrZXRTY29wZSA9IGNsYXNzIGV4dGVuZHMgVmVjdG9ySW5kZXhBcGkge1xuXHQvKipcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBoZWxwZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHNjb3BlcyBhbGwgaW5kZXggb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0LlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIGZldGNoJDEpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEpO1xuXHRcdHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIEluZGV4IGNvbmZpZ3VyYXRpb24gKHZlY3RvckJ1Y2tldE5hbWUgaXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGF3YWl0IGJ1Y2tldC5jcmVhdGVJbmRleCh7XG5cdCogICBpbmRleE5hbWU6ICdkb2N1bWVudHMtb3BlbmFpJyxcblx0KiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG5cdCogICBkaW1lbnNpb246IDE1MzYsXG5cdCogICBkaXN0YW5jZU1ldHJpYzogJ2Nvc2luZScsXG5cdCogICBtZXRhZGF0YUNvbmZpZ3VyYXRpb246IHtcblx0KiAgICAgbm9uRmlsdGVyYWJsZU1ldGFkYXRhS2V5czogWydyYXdfdGV4dCddXG5cdCogICB9XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldENyZWF0ZUluZGV4ID0gKCkgPT4gc3VwZXIuY3JlYXRlSW5kZXgsIF90aGlzNSA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0Q3JlYXRlSW5kZXgoKS5jYWxsKF90aGlzNSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwgeyB2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczUudmVjdG9yQnVja2V0TmFtZSB9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIExpc3RzIGluZGV4ZXMgaW4gdGhpcyBidWNrZXRcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuXHQqIEByZXR1cm5zIFByb21pc2Ugd2l0aCByZXNwb25zZSBjb250YWluaW5nIGluZGV4ZXMgYXJyYXkgYW5kIHBhZ2luYXRpb24gdG9rZW4gb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0Lmxpc3RJbmRleGVzKHsgcHJlZml4OiAnZG9jdW1lbnRzLScgfSlcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgbGlzdEluZGV4ZXMob3B0aW9ucyA9IHt9KSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMgPSAoKSA9PiBzdXBlci5saXN0SW5kZXhlcywgX3RoaXM2ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0SW5kZXhlcygpLmNhbGwoX3RoaXM2LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7IHZlY3RvckJ1Y2tldE5hbWU6IF90aGlzNi52ZWN0b3JCdWNrZXROYW1lIH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUmV0cmlldmVzIG1ldGFkYXRhIGZvciBhIHNwZWNpZmljIGluZGV4IGluIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gcmV0cmlldmVcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggaW5kZXggbWV0YWRhdGEgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0LmdldEluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBjb25zb2xlLmxvZygnRGltZW5zaW9uOicsIGRhdGE/LmluZGV4LmRpbWVuc2lvbilcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZ2V0SW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0R2V0SW5kZXggPSAoKSA9PiBzdXBlci5nZXRJbmRleCwgX3RoaXM3ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRJbmRleCgpLmNhbGwoX3RoaXM3LCBfdGhpczcudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogRGVsZXRlcyBhbiBpbmRleCBmcm9tIHRoaXMgYnVja2V0XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXggdG8gZGVsZXRlXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGJ1Y2tldCA9IHN1cGFiYXNlLnN0b3JhZ2UudmVjdG9ycy5mcm9tKCdlbWJlZGRpbmdzLXByb2QnKVxuXHQqIGF3YWl0IGJ1Y2tldC5kZWxldGVJbmRleCgnb2xkLWluZGV4Jylcblx0KiBgYGBcblx0Ki9cblx0YXN5bmMgZGVsZXRlSW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0dmFyIF9zdXBlcnByb3BfZ2V0RGVsZXRlSW5kZXggPSAoKSA9PiBzdXBlci5kZWxldGVJbmRleCwgX3RoaXM4ID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCgpLmNhbGwoX3RoaXM4LCBfdGhpczgudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIG9wZXJhdGlvbnMgZm9yIGEgc3BlY2lmaWMgaW5kZXggd2l0aGluIHRoaXMgYnVja2V0XG5cdCogUmV0dXJucyBhIHNjb3BlZCBjbGllbnQgZm9yIHZlY3RvciBkYXRhIG9wZXJhdGlvbnNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXhcblx0KiBAcmV0dXJucyBJbmRleC1zY29wZWQgY2xpZW50IHdpdGggdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqXG5cdCogLy8gSW5zZXJ0IHZlY3RvcnNcblx0KiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcblx0KiAgIHZlY3RvcnM6IFtcblx0KiAgICAgeyBrZXk6ICdkb2MtMScsIGRhdGE6IHsgZmxvYXQzMjogWy4uLl0gfSwgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRybycgfSB9XG5cdCogICBdXG5cdCogfSlcblx0KlxuXHQqIC8vIFF1ZXJ5IHNpbWlsYXIgdmVjdG9yc1xuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcblx0KiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFsuLi5dIH0sXG5cdCogICB0b3BLOiA1XG5cdCogfSlcblx0KiBgYGBcblx0Ki9cblx0aW5kZXgoaW5kZXhOYW1lKSB7XG5cdFx0cmV0dXJuIG5ldyBWZWN0b3JJbmRleFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHRoaXMudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCB0aGlzLmZldGNoKTtcblx0fVxufTtcbi8qKlxuKlxuKiBAYWxwaGFcbipcbiogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXhcbiogUHJvdmlkZXMgdmVjdG9yIGRhdGEgb3BlcmF0aW9ucyAocHV0LCBnZXQsIGxpc3QsIHF1ZXJ5LCBkZWxldGUpXG4qXG4qICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG4qL1xudmFyIFZlY3RvckluZGV4U2NvcGUgPSBjbGFzcyBleHRlbmRzIFZlY3RvckRhdGFBcGkge1xuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQ3JlYXRlcyBhIGhlbHBlciB0aGF0IGF1dG9tYXRpY2FsbHkgc2NvcGVzIGFsbCB2ZWN0b3Igb3BlcmF0aW9ucyB0byB0aGUgcHJvdmlkZWQgYnVja2V0L2luZGV4IG5hbWVzLlxuXHQqXG5cdCogKipQdWJsaWMgYWxwaGE6KiogVGhpcyBBUEkgaXMgcGFydCBvZiBhIHB1YmxpYyBhbHBoYSByZWxlYXNlIGFuZCBtYXkgbm90IGJlIGF2YWlsYWJsZSB0byB5b3VyIGFjY291bnQgdHlwZS5cblx0KlxuXHQqIEBjYXRlZ29yeSBWZWN0b3IgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBgYGBcblx0Ki9cblx0Y29uc3RydWN0b3IodXJsLCBoZWFkZXJzLCB2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUsIGZldGNoJDEpIHtcblx0XHRzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoJDEpO1xuXHRcdHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG5cdFx0dGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWU7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciBpbnNlcnRpb24gb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcblx0KiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuXHQqICAgdmVjdG9yczogW1xuXHQqICAgICB7XG5cdCogICAgICAga2V5OiAnZG9jLTEnLFxuXHQqICAgICAgIGRhdGE6IHsgZmxvYXQzMjogWzAuMSwgMC4yLCAuLi5dIH0sXG5cdCogICAgICAgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRyb2R1Y3Rpb24nLCBwYWdlOiAxIH1cblx0KiAgICAgfVxuXHQqICAgXVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIHB1dFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMgPSAoKSA9PiBzdXBlci5wdXRWZWN0b3JzLCBfdGhpczkgPSB0aGlzO1xuXHRcdHJldHVybiBfc3VwZXJwcm9wX2dldFB1dFZlY3RvcnMoKS5jYWxsKF90aGlzOSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXM5LnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzOS5pbmRleE5hbWVcblx0XHR9KSk7XG5cdH1cblx0LyoqXG5cdCpcblx0KiBAYWxwaGFcblx0KlxuXHQqIFJldHJpZXZlcyB2ZWN0b3JzIGJ5IGtleXMgZnJvbSB0aGlzIGluZGV4XG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgcmV0cmlldmFsIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXguZ2V0VmVjdG9ycyh7XG5cdCogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJ10sXG5cdCogICByZXR1cm5NZXRhZGF0YTogdHJ1ZVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGdldFZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldEdldFZlY3RvcnMgPSAoKSA9PiBzdXBlci5nZXRWZWN0b3JzLCBfdGhpczEwID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRHZXRWZWN0b3JzKCkuY2FsbChfdGhpczEwLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEwLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTAuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBMaXN0cyB2ZWN0b3JzIGluIHRoaXMgaW5kZXggd2l0aCBwYWdpbmF0aW9uXG5cdCogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyBidWNrZXQgYW5kIGluZGV4IG5hbWVzXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHBhcmFtIG9wdGlvbnMgLSBMaXN0aW5nIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgdmVjdG9ycyBhcnJheSBhbmQgcGFnaW5hdGlvbiB0b2tlbiBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgubGlzdFZlY3RvcnMoe1xuXHQqICAgbWF4UmVzdWx0czogNTAwLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBsaXN0VmVjdG9ycyhvcHRpb25zID0ge30pIHtcblx0XHR2YXIgX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycyA9ICgpID0+IHN1cGVyLmxpc3RWZWN0b3JzLCBfdGhpczExID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXRMaXN0VmVjdG9ycygpLmNhbGwoX3RoaXMxMSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdGlvbnMpLCB7fSwge1xuXHRcdFx0dmVjdG9yQnVja2V0TmFtZTogX3RoaXMxMS52ZWN0b3JCdWNrZXROYW1lLFxuXHRcdFx0aW5kZXhOYW1lOiBfdGhpczExLmluZGV4TmFtZVxuXHRcdH0pKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIFF1ZXJ5IG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIHJlc3BvbnNlIGNvbnRhaW5pbmcgbWF0Y2hlcyBhcnJheSBvZiBzaW1pbGFyIHZlY3RvcnMgb3JkZXJlZCBieSBkaXN0YW5jZSBvciBlcnJvclxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgaW5kZXggPSBzdXBhYmFzZS5zdG9yYWdlLnZlY3RvcnMuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcblx0KiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuXHQqICAgdG9wSzogNSxcblx0KiAgIGZpbHRlcjogeyBjYXRlZ29yeTogJ3RlY2huaWNhbCcgfSxcblx0KiAgIHJldHVybkRpc3RhbmNlOiB0cnVlLFxuXHQqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcblx0KiB9KVxuXHQqIGBgYFxuXHQqL1xuXHRhc3luYyBxdWVyeVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycyA9ICgpID0+IHN1cGVyLnF1ZXJ5VmVjdG9ycywgX3RoaXMxMiA9IHRoaXM7XG5cdFx0cmV0dXJuIF9zdXBlcnByb3BfZ2V0UXVlcnlWZWN0b3JzKCkuY2FsbChfdGhpczEyLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEyLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTIuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBEZWxldGVzIHZlY3RvcnMgYnkga2V5cyBmcm9tIHRoaXMgaW5kZXhcblx0KiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgVmVjdG9yIEJ1Y2tldHNcblx0KiBAcGFyYW0gb3B0aW9ucyAtIERlbGV0aW9uIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG5cdCogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3Jcblx0KlxuXHQqIEBleGFtcGxlXG5cdCogYGBgdHlwZXNjcmlwdFxuXHQqIGNvbnN0IGluZGV4ID0gc3VwYWJhc2Uuc3RvcmFnZS52ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcblx0KiBhd2FpdCBpbmRleC5kZWxldGVWZWN0b3JzKHtcblx0KiAgIGtleXM6IFsnZG9jLTEnLCAnZG9jLTInLCAnZG9jLTMnXVxuXHQqIH0pXG5cdCogYGBgXG5cdCovXG5cdGFzeW5jIGRlbGV0ZVZlY3RvcnMob3B0aW9ucykge1xuXHRcdHZhciBfc3VwZXJwcm9wX2dldERlbGV0ZVZlY3RvcnMgPSAoKSA9PiBzdXBlci5kZWxldGVWZWN0b3JzLCBfdGhpczEzID0gdGhpcztcblx0XHRyZXR1cm4gX3N1cGVycHJvcF9nZXREZWxldGVWZWN0b3JzKCkuY2FsbChfdGhpczEzLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0aW9ucyksIHt9LCB7XG5cdFx0XHR2ZWN0b3JCdWNrZXROYW1lOiBfdGhpczEzLnZlY3RvckJ1Y2tldE5hbWUsXG5cdFx0XHRpbmRleE5hbWU6IF90aGlzMTMuaW5kZXhOYW1lXG5cdFx0fSkpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvU3RvcmFnZUNsaWVudC50c1xudmFyIFN0b3JhZ2VDbGllbnQgPSBjbGFzcyBleHRlbmRzIFN0b3JhZ2VCdWNrZXRBcGkge1xuXHQvKipcblx0KiBDcmVhdGVzIGEgY2xpZW50IGZvciBTdG9yYWdlIGJ1Y2tldHMsIGZpbGVzLCBhbmFseXRpY3MsIGFuZCB2ZWN0b3JzLlxuXHQqXG5cdCogQGNhdGVnb3J5IEZpbGUgQnVja2V0c1xuXHQqIEBleGFtcGxlXG5cdCogYGBgdHNcblx0KiBpbXBvcnQgeyBTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG5cdCpcblx0KiBjb25zdCBzdG9yYWdlID0gbmV3IFN0b3JhZ2VDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jby9zdG9yYWdlL3YxJywge1xuXHQqICAgYXBpa2V5OiAncHVibGljLWFub24ta2V5Jyxcblx0KiB9KVxuXHQqIGNvbnN0IGF2YXRhcnMgPSBzdG9yYWdlLmZyb20oJ2F2YXRhcnMnKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gkMSwgb3B0cykge1xuXHRcdHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gkMSwgb3B0cyk7XG5cdH1cblx0LyoqXG5cdCogUGVyZm9ybSBmaWxlIG9wZXJhdGlvbiBpbiBhIGJ1Y2tldC5cblx0KlxuXHQqIEBjYXRlZ29yeSBGaWxlIEJ1Y2tldHNcblx0KiBAcGFyYW0gaWQgVGhlIGJ1Y2tldCBpZCB0byBvcGVyYXRlIG9uLlxuXHQqXG5cdCogQGV4YW1wbGVcblx0KiBgYGB0eXBlc2NyaXB0XG5cdCogY29uc3QgYXZhdGFycyA9IHN1cGFiYXNlLnN0b3JhZ2UuZnJvbSgnYXZhdGFycycpXG5cdCogYGBgXG5cdCovXG5cdGZyb20oaWQpIHtcblx0XHRyZXR1cm4gbmV3IFN0b3JhZ2VGaWxlQXBpKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIGlkLCB0aGlzLmZldGNoKTtcblx0fVxuXHQvKipcblx0KlxuXHQqIEBhbHBoYVxuXHQqXG5cdCogQWNjZXNzIHZlY3RvciBzdG9yYWdlIG9wZXJhdGlvbnMuXG5cdCpcblx0KiAqKlB1YmxpYyBhbHBoYToqKiBUaGlzIEFQSSBpcyBwYXJ0IG9mIGEgcHVibGljIGFscGhhIHJlbGVhc2UgYW5kIG1heSBub3QgYmUgYXZhaWxhYmxlIHRvIHlvdXIgYWNjb3VudCB0eXBlLlxuXHQqXG5cdCogQGNhdGVnb3J5IFZlY3RvciBCdWNrZXRzXG5cdCogQHJldHVybnMgQSBTdG9yYWdlVmVjdG9yc0NsaWVudCBpbnN0YW5jZSBjb25maWd1cmVkIHdpdGggdGhlIGN1cnJlbnQgc3RvcmFnZSBzZXR0aW5ncy5cblx0Ki9cblx0Z2V0IHZlY3RvcnMoKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCh0aGlzLnVybCArIFwiL3ZlY3RvclwiLCB7XG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHR9XG5cdC8qKlxuXHQqXG5cdCogQGFscGhhXG5cdCpcblx0KiBBY2Nlc3MgYW5hbHl0aWNzIHN0b3JhZ2Ugb3BlcmF0aW9ucyB1c2luZyBJY2ViZXJnIHRhYmxlcy5cblx0KlxuXHQqICoqUHVibGljIGFscGhhOioqIFRoaXMgQVBJIGlzIHBhcnQgb2YgYSBwdWJsaWMgYWxwaGEgcmVsZWFzZSBhbmQgbWF5IG5vdCBiZSBhdmFpbGFibGUgdG8geW91ciBhY2NvdW50IHR5cGUuXG5cdCpcblx0KiBAY2F0ZWdvcnkgQW5hbHl0aWNzIEJ1Y2tldHNcblx0KiBAcmV0dXJucyBBIFN0b3JhZ2VBbmFseXRpY3NDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG5cdCovXG5cdGdldCBhbmFseXRpY3MoKSB7XG5cdFx0cmV0dXJuIG5ldyBTdG9yYWdlQW5hbHl0aWNzQ2xpZW50KHRoaXMudXJsICsgXCIvaWNlYmVyZ1wiLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gpO1xuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IFN0b3JhZ2VBbmFseXRpY3NDbGllbnQsIFN0b3JhZ2VBcGlFcnJvciwgU3RvcmFnZUNsaWVudCwgU3RvcmFnZUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yLCBTdG9yYWdlVmVjdG9yc0FwaUVycm9yLCBTdG9yYWdlVmVjdG9yc0NsaWVudCwgU3RvcmFnZVZlY3RvcnNFcnJvciwgU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUsIFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yLCBWZWN0b3JCdWNrZXRBcGksIFZlY3RvckJ1Y2tldFNjb3BlLCBWZWN0b3JEYXRhQXBpLCBWZWN0b3JJbmRleEFwaSwgVmVjdG9ySW5kZXhTY29wZSwgaXNQbGFpbk9iamVjdCwgaXNTdG9yYWdlRXJyb3IsIGlzU3RvcmFnZVZlY3RvcnNFcnJvciwgbm9ybWFsaXplVG9GbG9hdDMyLCByZXNvbHZlRmV0Y2gsIHJlc29sdmVSZXNwb25zZSwgdmFsaWRhdGVWZWN0b3JEaW1lbnNpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiSWNlYmVyZ1Jlc3RDYXRhbG9nIiwiU3RvcmFnZUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJfX2lzU3RvcmFnZUVycm9yIiwibmFtZSIsImlzU3RvcmFnZUVycm9yIiwiZXJyb3IiLCJTdG9yYWdlQXBpRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwidG9KU09OIiwiU3RvcmFnZVVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJyZXNvbHZlRmV0Y2gkMSIsImN1c3RvbUZldGNoIiwiYXJncyIsImZldGNoIiwicmVzb2x2ZVJlc3BvbnNlJDEiLCJSZXNwb25zZSIsInJlY3Vyc2l2ZVRvQ2FtZWwiLCJpdGVtIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwIiwiZWwiLCJPYmplY3QiLCJyZXN1bHQiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwibmV3S2V5IiwicmVwbGFjZSIsImMiLCJ0b1VwcGVyQ2FzZSIsImlzUGxhaW5PYmplY3QkMSIsInByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpdGVyYXRvciIsImlzVmFsaWRCdWNrZXROYW1lIiwiYnVja2V0TmFtZSIsImxlbmd0aCIsInRyaW0iLCJpbmNsdWRlcyIsInRlc3QiLCJfdHlwZW9mIiwibyIsIm8kMSIsInRvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJ0b1Byb3BlcnR5S2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJvd25LZXlzIiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInIkMSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQyIiwiYXJndW1lbnRzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfZ2V0RXJyb3JNZXNzYWdlJDEiLCJlcnIiLCJfZXJyJGVycm9yIiwibXNnIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJKU09OIiwic3RyaW5naWZ5IiwiaGFuZGxlRXJyb3IkMSIsInJlamVjdCIsIm9wdGlvbnMiLCJub1Jlc29sdmVKc29uIiwianNvbiIsInRoZW4iLCJjYXRjaCIsIl9nZXRSZXF1ZXN0UGFyYW1zJDEiLCJtZXRob2QiLCJwYXJhbWV0ZXJzIiwiYm9keSIsInBhcmFtcyIsImhlYWRlcnMiLCJkdXBsZXgiLCJfaGFuZGxlUmVxdWVzdCQxIiwiZmV0Y2hlciIsInVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwib2siLCJkYXRhIiwiZ2V0IiwicG9zdCQxIiwicHV0IiwiaGVhZCIsInJlbW92ZSIsIlN0cmVhbURvd25sb2FkQnVpbGRlciIsImRvd25sb2FkRm4iLCJzaG91bGRUaHJvd09uRXJyb3IiLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJleGVjdXRlIiwiX3RoaXMiLCJfU3ltYm9sJHRvU3RyaW5nVGFnIiwiQmxvYkRvd25sb2FkQnVpbGRlciIsInByb21pc2UiLCJhc1N0cmVhbSIsImdldFByb21pc2UiLCJmaW5hbGx5Iiwib25maW5hbGx5IiwiYmxvYiIsIkRFRkFVTFRfU0VBUkNIX09QVElPTlMiLCJsaW1pdCIsIm9mZnNldCIsInNvcnRCeSIsImNvbHVtbiIsIm9yZGVyIiwiREVGQVVMVF9GSUxFX09QVElPTlMiLCJjYWNoZUNvbnRyb2wiLCJjb250ZW50VHlwZSIsInVwc2VydCIsIlN0b3JhZ2VGaWxlQXBpIiwiYnVja2V0SWQiLCJmZXRjaCQxIiwidGhyb3dPbkVycm9yIiwidXBsb2FkT3JVcGRhdGUiLCJwYXRoIiwiZmlsZUJvZHkiLCJmaWxlT3B0aW9ucyIsIm1ldGFkYXRhIiwiQmxvYiIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiZW5jb2RlTWV0YWRhdGEiLCJoYXMiLCJ0b0Jhc2U2NCIsIlJlYWRhYmxlU3RyZWFtIiwicGlwZSIsImNsZWFuUGF0aCIsIl9yZW1vdmVFbXB0eUZvbGRlcnMiLCJfcGF0aCIsIl9nZXRGaW5hbFBhdGgiLCJpZCIsIklkIiwiZnVsbFBhdGgiLCJLZXkiLCJ1cGxvYWQiLCJ1cGxvYWRUb1NpZ25lZFVybCIsInRva2VuIiwiX3RoaXMzIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwic2V0IiwidG9TdHJpbmciLCJjcmVhdGVTaWduZWRVcGxvYWRVcmwiLCJfdGhpczQiLCJzaWduZWRVcmwiLCJ1cGRhdGUiLCJtb3ZlIiwiZnJvbVBhdGgiLCJ0b1BhdGgiLCJfdGhpczYiLCJzb3VyY2VLZXkiLCJkZXN0aW5hdGlvbktleSIsImRlc3RpbmF0aW9uQnVja2V0IiwiY29weSIsIl90aGlzNyIsImNyZWF0ZVNpZ25lZFVybCIsImV4cGlyZXNJbiIsIl90aGlzOCIsInRyYW5zZm9ybSIsImRvd25sb2FkUXVlcnlQYXJhbSIsImRvd25sb2FkIiwiZW5jb2RlVVJJIiwic2lnbmVkVVJMIiwiY3JlYXRlU2lnbmVkVXJscyIsInBhdGhzIiwiX3RoaXM5IiwiZGF0dW0iLCJyZW5kZXJQYXRoIiwidHJhbnNmb3JtYXRpb25RdWVyeSIsInRyYW5zZm9ybU9wdHNUb1F1ZXJ5U3RyaW5nIiwicXVlcnlTdHJpbmciLCJpbmZvIiwiX3RoaXMxMCIsImV4aXN0cyIsIl90aGlzMTEiLCJnZXRQdWJsaWNVcmwiLCJfcXVlcnlTdHJpbmciLCJqb2luIiwicHVibGljVXJsIiwiX3RoaXMxMiIsInByZWZpeGVzIiwibGlzdCIsIl90aGlzMTMiLCJwcmVmaXgiLCJsaXN0VjIiLCJfdGhpczE0IiwiQnVmZmVyIiwiZnJvbSIsImJ0b2EiLCJ3aWR0aCIsImhlaWdodCIsInJlc2l6ZSIsImZvcm1hdCIsInF1YWxpdHkiLCJ2ZXJzaW9uIiwiREVGQVVMVF9IRUFERVJTJDEiLCJTdG9yYWdlQnVja2V0QXBpIiwib3B0cyIsImJhc2VVcmwiLCJ1c2VOZXdIb3N0bmFtZSIsImhvc3RuYW1lIiwiaHJlZiIsImxpc3RCdWNrZXRzIiwibGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nIiwiZ2V0QnVja2V0IiwiX3RoaXMyIiwiY3JlYXRlQnVja2V0IiwicHVibGljIiwidHlwZSIsImZpbGVfc2l6ZV9saW1pdCIsImZpbGVTaXplTGltaXQiLCJhbGxvd2VkX21pbWVfdHlwZXMiLCJhbGxvd2VkTWltZVR5cGVzIiwidXBkYXRlQnVja2V0IiwiZW1wdHlCdWNrZXQiLCJfdGhpczUiLCJkZWxldGVCdWNrZXQiLCJzZWFyY2giLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwiVVJMU2VhcmNoUGFyYW1zIiwiU3RvcmFnZUFuYWx5dGljc0NsaWVudCIsInF1ZXJ5UGFyYW1zIiwiY2F0YWxvZyIsImNhdGFsb2dOYW1lIiwiYXV0aCIsImdldEhlYWRlcnMiLCJQcm94eSIsInRhcmdldCIsInByb3AiLCJERUZBVUxUX0hFQURFUlMiLCJTdG9yYWdlVmVjdG9yc0Vycm9yIiwiX19pc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJTdG9yYWdlVmVjdG9yc0FwaUVycm9yIiwiU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IiLCJTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSIsIlN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlJDEiLCJyZXNvbHZlRmV0Y2giLCJyZXNvbHZlUmVzcG9uc2UiLCJpc1BsYWluT2JqZWN0Iiwibm9ybWFsaXplVG9GbG9hdDMyIiwidmFsdWVzIiwiRmxvYXQzMkFycmF5IiwidmFsaWRhdGVWZWN0b3JEaW1lbnNpb24iLCJ2ZWN0b3IiLCJleHBlY3RlZERpbWVuc2lvbiIsImZsb2F0MzIiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiaGFuZGxlRXJyb3IiLCJyZXNwb25zZUVycm9yIiwiY29kZSIsInN0YXR1c1RleHQiLCJfZ2V0UmVxdWVzdFBhcmFtcyIsIl9oYW5kbGVSZXF1ZXN0IiwicG9zdCIsIlZlY3RvckluZGV4QXBpIiwiY3JlYXRlSW5kZXgiLCJnZXRJbmRleCIsInZlY3RvckJ1Y2tldE5hbWUiLCJpbmRleE5hbWUiLCJsaXN0SW5kZXhlcyIsImRlbGV0ZUluZGV4IiwiVmVjdG9yRGF0YUFwaSIsInB1dFZlY3RvcnMiLCJ2ZWN0b3JzIiwiZ2V0VmVjdG9ycyIsImxpc3RWZWN0b3JzIiwic2VnbWVudENvdW50Iiwic2VnbWVudEluZGV4IiwicXVlcnlWZWN0b3JzIiwiZGVsZXRlVmVjdG9ycyIsIlZlY3RvckJ1Y2tldEFwaSIsIlN0b3JhZ2VWZWN0b3JzQ2xpZW50IiwiVmVjdG9yQnVja2V0U2NvcGUiLCJfc3VwZXJwcm9wX2dldENyZWF0ZUJ1Y2tldCIsIl9zdXBlcnByb3BfZ2V0R2V0QnVja2V0IiwiX3N1cGVycHJvcF9nZXRMaXN0QnVja2V0cyIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlQnVja2V0IiwiX3N1cGVycHJvcF9nZXRDcmVhdGVJbmRleCIsIl9zdXBlcnByb3BfZ2V0TGlzdEluZGV4ZXMiLCJfc3VwZXJwcm9wX2dldEdldEluZGV4IiwiX3N1cGVycHJvcF9nZXREZWxldGVJbmRleCIsImluZGV4IiwiVmVjdG9ySW5kZXhTY29wZSIsIl9zdXBlcnByb3BfZ2V0UHV0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0R2V0VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0TGlzdFZlY3RvcnMiLCJfc3VwZXJwcm9wX2dldFF1ZXJ5VmVjdG9ycyIsIl9zdXBlcnByb3BfZ2V0RGVsZXRlVmVjdG9ycyIsIlN0b3JhZ2VDbGllbnQiLCJhbmFseXRpY3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/index.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/index.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthAdminApi),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient),\n/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthPKCECodeVerifierMissingError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.CustomAuthError),\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsRelayError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.GoTrueAdminApi),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.GoTrueClient),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimePresence),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES),\n/* harmony export */   SupabaseClient: () => (/* binding */ SupabaseClient),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.WebSocketFactory),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthPKCECodeVerifierMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthPKCECodeVerifierMissingError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.lockInternals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.processLock)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/index.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/storage-js */ \"(ssr)/./node_modules/@supabase/storage-js/dist/index.mjs\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/auth-js */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\n\n\n\n\n\n\n//#region src/lib/version.ts\nconst version = \"2.90.0\";\n//#endregion\n//#region src/lib/constants.ts\nlet JS_ENV = \"\";\nif (typeof Deno !== \"undefined\") JS_ENV = \"deno\";\nelse if (typeof document !== \"undefined\") JS_ENV = \"web\";\nelse if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") JS_ENV = \"react-native\";\nelse JS_ENV = \"node\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `supabase-js-${JS_ENV}/${version}`\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {};\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/typeof.js\nfunction _typeof(o) {\n    \"@babel/helpers - typeof\";\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n        return typeof o$1;\n    } : function(o$1) {\n        return o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, _typeof(o);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPrimitive.js\nfunction toPrimitive(t, r) {\n    if (\"object\" != _typeof(t) || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n        var i = e.call(t, r || \"default\");\n        if (\"object\" != _typeof(i)) return i;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === r ? String : Number)(t);\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/toPropertyKey.js\nfunction toPropertyKey(t) {\n    var i = toPrimitive(t, \"string\");\n    return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/defineProperty.js\nfunction _defineProperty(e, r, t) {\n    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n        value: t,\n        enumerable: !0,\n        configurable: !0,\n        writable: !0\n    }) : e[r] = t, e;\n}\n//#endregion\n//#region \\0@oxc-project+runtime@0.101.0/helpers/objectSpread2.js\nfunction ownKeys(e, r) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n        var o = Object.getOwnPropertySymbols(e);\n        r && (o = o.filter(function(r$1) {\n            return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n        })), t.push.apply(t, o);\n    }\n    return t;\n}\nfunction _objectSpread2(e) {\n    for(var r = 1; r < arguments.length; r++){\n        var t = null != arguments[r] ? arguments[r] : {};\n        r % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n            _defineProperty(e, r$1, t[r$1]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n            Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n        });\n    }\n    return e;\n}\n//#endregion\n//#region src/lib/fetch.ts\nconst resolveFetch = (customFetch)=>{\n    if (customFetch) return (...args)=>customFetch(...args);\n    return (...args)=>fetch(...args);\n};\nconst resolveHeadersConstructor = ()=>{\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch$1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return async (input, init)=>{\n        var _await$getAccessToken;\n        const accessToken = (_await$getAccessToken = await getAccessToken()) !== null && _await$getAccessToken !== void 0 ? _await$getAccessToken : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has(\"apikey\")) headers.set(\"apikey\", supabaseKey);\n        if (!headers.has(\"Authorization\")) headers.set(\"Authorization\", `Bearer ${accessToken}`);\n        return fetch$1(input, _objectSpread2(_objectSpread2({}, init), {}, {\n            headers\n        }));\n    };\n};\n//#endregion\n//#region src/lib/helpers.ts\nfunction ensureTrailingSlash(url) {\n    return url.endsWith(\"/\") ? url : url + \"/\";\n}\nfunction applySettingDefaults(options, defaults) {\n    var _DEFAULT_GLOBAL_OPTIO, _globalOptions$header;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS$1, auth: DEFAULT_AUTH_OPTIONS$1, realtime: DEFAULT_REALTIME_OPTIONS$1, global: DEFAULT_GLOBAL_OPTIONS$1 } = defaults;\n    const result = {\n        db: _objectSpread2(_objectSpread2({}, DEFAULT_DB_OPTIONS$1), dbOptions),\n        auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS$1), authOptions),\n        realtime: _objectSpread2(_objectSpread2({}, DEFAULT_REALTIME_OPTIONS$1), realtimeOptions),\n        storage: {},\n        global: _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_GLOBAL_OPTIONS$1), globalOptions), {}, {\n            headers: _objectSpread2(_objectSpread2({}, (_DEFAULT_GLOBAL_OPTIO = DEFAULT_GLOBAL_OPTIONS$1 === null || DEFAULT_GLOBAL_OPTIONS$1 === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS$1.headers) !== null && _DEFAULT_GLOBAL_OPTIO !== void 0 ? _DEFAULT_GLOBAL_OPTIO : {}), (_globalOptions$header = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _globalOptions$header !== void 0 ? _globalOptions$header : {})\n        }),\n        accessToken: async ()=>\"\"\n    };\n    if (options.accessToken) result.accessToken = options.accessToken;\n    else delete result.accessToken;\n    return result;\n}\n/**\n* Validates a Supabase client URL\n*\n* @param {string} supabaseUrl - The Supabase client URL string.\n* @returns {URL} - The validated base URL.\n* @throws {Error}\n*/ function validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) throw new Error(\"supabaseUrl is required.\");\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) throw new Error(\"Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.\");\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    } catch (_unused) {\n        throw Error(\"Invalid supabaseUrl: Provided URL is malformed.\");\n    }\n}\n//#endregion\n//#region src/lib/SupabaseAuthClient.ts\nvar SupabaseAuthClient = class extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_2__.AuthClient {\n    constructor(options){\n        super(options);\n    }\n};\n//#endregion\n//#region src/SupabaseClient.ts\n/**\n* Supabase Client.\n*\n* An isomorphic Javascript client for interacting with Postgres.\n*/ var SupabaseClient = class {\n    /**\n\t* Create a new client for use in the browser.\n\t* @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n\t* @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n\t* @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n\t* @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n\t* @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n\t* @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n\t* @param options.realtime Options passed along to realtime-js constructor.\n\t* @param options.storage Options passed along to the storage-js constructor.\n\t* @param options.global.fetch A custom fetch implementation.\n\t* @param options.global.headers Any additional headers to send with each network request.\n\t* @example\n\t* ```ts\n\t* import { createClient } from '@supabase/supabase-js'\n\t*\n\t* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n\t* const { data } = await supabase.from('profiles').select('*')\n\t* ```\n\t*/ constructor(supabaseUrl, supabaseKey, options){\n        var _settings$auth$storag, _settings$global$head;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = validateSupabaseUrl(supabaseUrl);\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        this.realtimeUrl = new URL(\"realtime/v1\", baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(\"http\", \"ws\");\n        this.authUrl = new URL(\"auth/v1\", baseUrl);\n        this.storageUrl = new URL(\"storage/v1\", baseUrl);\n        this.functionsUrl = new URL(\"functions/v1\", baseUrl);\n        const defaultStorageKey = `sb-${baseUrl.hostname.split(\".\")[0]}-auth-token`;\n        const DEFAULTS = {\n            db: DEFAULT_DB_OPTIONS,\n            realtime: DEFAULT_REALTIME_OPTIONS,\n            auth: _objectSpread2(_objectSpread2({}, DEFAULT_AUTH_OPTIONS), {}, {\n                storageKey: defaultStorageKey\n            }),\n            global: DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_settings$auth$storag = settings.auth.storageKey) !== null && _settings$auth$storag !== void 0 ? _settings$auth$storag : \"\";\n        this.headers = (_settings$global$head = settings.global.headers) !== null && _settings$global$head !== void 0 ? _settings$global$head : {};\n        if (!settings.accessToken) {\n            var _settings$auth;\n            this.auth = this._initSupabaseAuthClient((_settings$auth = settings.auth) !== null && _settings$auth !== void 0 ? _settings$auth : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                }\n            });\n        }\n        this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(_objectSpread2({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        if (this.accessToken) this.accessToken().then((token)=>this.realtime.setAuth(token)).catch((e)=>console.warn(\"Failed to set initial Realtime auth token:\", e));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(new URL(\"rest/v1\", baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch\n        });\n        this.storage = new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_3__.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) this._listenForAuthEvents();\n    }\n    /**\n\t* Supabase Functions allows you to deploy and invoke edge functions.\n\t*/ get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_4__.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n\t* Perform a query on a table or a view.\n\t*\n\t* @param relation - The table or view name to query\n\t*/ from(relation) {\n        return this.rest.from(relation);\n    }\n    /**\n\t* Select a schema to query or perform an function (rpc) call.\n\t*\n\t* The schema needs to be on the list of exposed schemas inside Supabase.\n\t*\n\t* @param schema - The schema to query\n\t*/ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    /**\n\t* Perform a function call.\n\t*\n\t* @param fn - The function name to call\n\t* @param args - The arguments to pass to the function call\n\t* @param options - Named parameters\n\t* @param options.head - When set to `true`, `data` will not be returned.\n\t* Useful if you only need the count.\n\t* @param options.get - When set to `true`, the function will be called with\n\t* read-only access mode.\n\t* @param options.count - Count algorithm to use to count rows returned by the\n\t* function. Only applicable for [set-returning\n\t* functions](https://www.postgresql.org/docs/current/functions-srf.html).\n\t*\n\t* `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n\t* hood.\n\t*\n\t* `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n\t* statistics under the hood.\n\t*\n\t* `\"estimated\"`: Uses exact count for low numbers and planned count for high\n\t* numbers.\n\t*/ rpc(fn, args = {}, options = {\n        head: false,\n        get: false,\n        count: void 0\n    }) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n\t* Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n\t*\n\t* @param {string} name - The name of the Realtime channel.\n\t* @param {Object} opts - The options to pass to the Realtime channel.\n\t*\n\t*/ channel(name, opts = {\n        config: {}\n    }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n\t* Returns all Realtime channels.\n\t*/ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n\t* Unsubscribes and removes Realtime channel from Realtime client.\n\t*\n\t* @param {RealtimeChannel} channel - The name of the Realtime channel.\n\t*\n\t*/ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n\t* Unsubscribes and removes all Realtime channels from Realtime client.\n\t*/ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    async _getAccessToken() {\n        var _this = this;\n        var _data$session$access_, _data$session;\n        if (_this.accessToken) return await _this.accessToken();\n        const { data } = await _this.auth.getSession();\n        return (_data$session$access_ = (_data$session = data.session) === null || _data$session === void 0 ? void 0 : _data$session.access_token) !== null && _data$session$access_ !== void 0 ? _data$session$access_ : _this.supabaseKey;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug, throwOnError }, headers, fetch$1) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: _objectSpread2(_objectSpread2({}, authHeaders), headers),\n            storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            throwOnError,\n            fetch: fetch$1,\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === \"authorization\")\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl.href, _objectSpread2(_objectSpread2({}, options), {}, {\n            params: _objectSpread2(_objectSpread2({}, {\n                apikey: this.supabaseKey\n            }), options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        return this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = void 0;\n        }\n    }\n};\n//#endregion\n//#region src/index.ts\n/**\n* Creates a new Supabase Client.\n*\n* @example\n* ```ts\n* import { createClient } from '@supabase/supabase-js'\n*\n* const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')\n* const { data, error } = await supabase.from('profiles').select('*')\n* ```\n*/ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new SupabaseClient(supabaseUrl, supabaseKey, options);\n};\nfunction shouldShowDeprecationWarning() {\n    if (false) {}\n    const _process = globalThis[\"process\"];\n    if (!_process) return false;\n    const processVersion = _process[\"version\"];\n    if (processVersion === void 0 || processVersion === null) return false;\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) return false;\n    return parseInt(versionMatch[1], 10) <= 18;\n}\nif (shouldShowDeprecationWarning()) console.warn(\"  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217\");\n//#endregion\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUo7QUFDOUU7QUFDbEI7QUFDRjtBQUNOO0FBRVY7QUFFSjtBQUVqQyw0QkFBNEI7QUFDNUIsTUFBTVcsVUFBVTtBQUVoQixZQUFZO0FBQ1osOEJBQThCO0FBQzlCLElBQUlDLFNBQVM7QUFDYixJQUFJLE9BQU9DLFNBQVMsYUFBYUQsU0FBUztLQUNyQyxJQUFJLE9BQU9FLGFBQWEsYUFBYUYsU0FBUztLQUM5QyxJQUFJLE9BQU9HLGNBQWMsZUFBZUEsVUFBVUMsT0FBTyxLQUFLLGVBQWVKLFNBQVM7S0FDdEZBLFNBQVM7QUFDZCxNQUFNSyxrQkFBa0I7SUFBRSxpQkFBaUIsQ0FBQyxZQUFZLEVBQUVMLE9BQU8sQ0FBQyxFQUFFRCxRQUFRLENBQUM7QUFBQztBQUM5RSxNQUFNTyx5QkFBeUI7SUFBRUMsU0FBU0Y7QUFBZ0I7QUFDMUQsTUFBTUcscUJBQXFCO0lBQUVDLFFBQVE7QUFBUztBQUM5QyxNQUFNQyx1QkFBdUI7SUFDNUJDLGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFVBQVU7QUFDWDtBQUNBLE1BQU1DLDJCQUEyQixDQUFDO0FBRWxDLFlBQVk7QUFDWiwwREFBMEQ7QUFDMUQsU0FBU0MsUUFBUUMsQ0FBQztJQUNqQjtJQUNBLE9BQU9ELFVBQVUsY0FBYyxPQUFPRSxVQUFVLFlBQVksT0FBT0EsT0FBT0MsUUFBUSxHQUFHLFNBQVNDLEdBQUc7UUFDaEcsT0FBTyxPQUFPQTtJQUNmLElBQUksU0FBU0EsR0FBRztRQUNmLE9BQU9BLE9BQU8sY0FBYyxPQUFPRixVQUFVRSxJQUFJQyxXQUFXLEtBQUtILFVBQVVFLFFBQVFGLE9BQU9JLFNBQVMsR0FBRyxXQUFXLE9BQU9GO0lBQ3pILEdBQUdKLFFB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QUM7QUFFakQsWUFBWTtBQUMwSSxDQUN0SixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWRkaW5nLWd1ZXN0LWFwcC8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9pbmRleC5tanM/NDkzYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGdW5jdGlvblJlZ2lvbiwgRnVuY3Rpb25zQ2xpZW50LCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25zRmV0Y2hFcnJvciwgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yIH0gZnJvbSBcIkBzdXBhYmFzZS9mdW5jdGlvbnMtanNcIjtcbmltcG9ydCB7IFBvc3RncmVzdENsaWVudCwgUG9zdGdyZXN0RXJyb3IgfSBmcm9tIFwiQHN1cGFiYXNlL3Bvc3RncmVzdC1qc1wiO1xuaW1wb3J0IHsgUmVhbHRpbWVDbGllbnQgfSBmcm9tIFwiQHN1cGFiYXNlL3JlYWx0aW1lLWpzXCI7XG5pbXBvcnQgeyBTdG9yYWdlQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9zdG9yYWdlLWpzXCI7XG5pbXBvcnQgeyBBdXRoQ2xpZW50IH0gZnJvbSBcIkBzdXBhYmFzZS9hdXRoLWpzXCI7XG5cbmV4cG9ydCAqIGZyb20gXCJAc3VwYWJhc2UvcmVhbHRpbWUtanNcIlxuXG5leHBvcnQgKiBmcm9tIFwiQHN1cGFiYXNlL2F1dGgtanNcIlxuXG4vLyNyZWdpb24gc3JjL2xpYi92ZXJzaW9uLnRzXG5jb25zdCB2ZXJzaW9uID0gXCIyLjkwLjBcIjtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9jb25zdGFudHMudHNcbmxldCBKU19FTlYgPSBcIlwiO1xuaWYgKHR5cGVvZiBEZW5vICE9PSBcInVuZGVmaW5lZFwiKSBKU19FTlYgPSBcImRlbm9cIjtcbmVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgSlNfRU5WID0gXCJ3ZWJcIjtcbmVsc2UgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwiUmVhY3ROYXRpdmVcIikgSlNfRU5WID0gXCJyZWFjdC1uYXRpdmVcIjtcbmVsc2UgSlNfRU5WID0gXCJub2RlXCI7XG5jb25zdCBERUZBVUxUX0hFQURFUlMgPSB7IFwiWC1DbGllbnQtSW5mb1wiOiBgc3VwYWJhc2UtanMtJHtKU19FTlZ9LyR7dmVyc2lvbn1gIH07XG5jb25zdCBERUZBVUxUX0dMT0JBTF9PUFRJT05TID0geyBoZWFkZXJzOiBERUZBVUxUX0hFQURFUlMgfTtcbmNvbnN0IERFRkFVTFRfREJfT1BUSU9OUyA9IHsgc2NoZW1hOiBcInB1YmxpY1wiIH07XG5jb25zdCBERUZBVUxUX0FVVEhfT1BUSU9OUyA9IHtcblx0YXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcblx0cGVyc2lzdFNlc3Npb246IHRydWUsXG5cdGRldGVjdFNlc3Npb25JblVybDogdHJ1ZSxcblx0Zmxvd1R5cGU6IFwiaW1wbGljaXRcIlxufTtcbmNvbnN0IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyA9IHt9O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdHlwZW9mLmpzXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcblx0XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXHRyZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG8kMSkge1xuXHRcdHJldHVybiB0eXBlb2YgbyQxO1xuXHR9IDogZnVuY3Rpb24obyQxKSB7XG5cdFx0cmV0dXJuIG8kMSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvJDEuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvJDEgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG8kMTtcblx0fSwgX3R5cGVvZihvKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXG5mdW5jdGlvbiB0b1ByaW1pdGl2ZSh0LCByKSB7XG5cdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuXHR2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcblx0aWYgKHZvaWQgMCAhPT0gZSkge1xuXHRcdHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuXHRcdGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcblx0fVxuXHRyZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBcXDBAb3hjLXByb2plY3QrcnVudGltZUAwLjEwMS4wL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1xuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG5cdHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG5cdHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIFxcMEBveGMtcHJvamVjdCtydW50aW1lQDAuMTAxLjAvaGVscGVycy9kZWZpbmVQcm9wZXJ0eS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIsIHQpIHtcblx0cmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG5cdFx0dmFsdWU6IHQsXG5cdFx0ZW51bWVyYWJsZTogITAsXG5cdFx0Y29uZmlndXJhYmxlOiAhMCxcblx0XHR3cml0YWJsZTogITBcblx0fSkgOiBlW3JdID0gdCwgZTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gXFwwQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC4xMDEuMC9oZWxwZXJzL29iamVjdFNwcmVhZDIuanNcbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuXHR2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuXHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcblx0XHRyICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByJDEpLmVudW1lcmFibGU7XG5cdFx0fSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG5cdH1cblx0cmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG5cdGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG5cdFx0dmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuXHRcdHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0X2RlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcblx0XHR9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciQxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIkMSkpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL2ZldGNoLnRzXG5jb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcblx0aWYgKGN1c3RvbUZldGNoKSByZXR1cm4gKC4uLmFyZ3MpID0+IGN1c3RvbUZldGNoKC4uLmFyZ3MpO1xuXHRyZXR1cm4gKC4uLmFyZ3MpID0+IGZldGNoKC4uLmFyZ3MpO1xufTtcbmNvbnN0IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IgPSAoKSA9PiB7XG5cdHJldHVybiBIZWFkZXJzO1xufTtcbmNvbnN0IGZldGNoV2l0aEF1dGggPSAoc3VwYWJhc2VLZXksIGdldEFjY2Vzc1Rva2VuLCBjdXN0b21GZXRjaCkgPT4ge1xuXHRjb25zdCBmZXRjaCQxID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcblx0Y29uc3QgSGVhZGVyc0NvbnN0cnVjdG9yID0gcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvcigpO1xuXHRyZXR1cm4gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG5cdFx0dmFyIF9hd2FpdCRnZXRBY2Nlc3NUb2tlbjtcblx0XHRjb25zdCBhY2Nlc3NUb2tlbiA9IChfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbigpKSAhPT0gbnVsbCAmJiBfYXdhaXQkZ2V0QWNjZXNzVG9rZW4gIT09IHZvaWQgMCA/IF9hd2FpdCRnZXRBY2Nlc3NUb2tlbiA6IHN1cGFiYXNlS2V5O1xuXHRcdGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnNDb25zdHJ1Y3Rvcihpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycyk7XG5cdFx0aWYgKCFoZWFkZXJzLmhhcyhcImFwaWtleVwiKSkgaGVhZGVycy5zZXQoXCJhcGlrZXlcIiwgc3VwYWJhc2VLZXkpO1xuXHRcdGlmICghaGVhZGVycy5oYXMoXCJBdXRob3JpemF0aW9uXCIpKSBoZWFkZXJzLnNldChcIkF1dGhvcml6YXRpb25cIiwgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuXHRcdHJldHVybiBmZXRjaCQxKGlucHV0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaW5pdCksIHt9LCB7IGhlYWRlcnMgfSkpO1xuXHR9O1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2xpYi9oZWxwZXJzLnRzXG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHVybCkge1xuXHRyZXR1cm4gdXJsLmVuZHNXaXRoKFwiL1wiKSA/IHVybCA6IHVybCArIFwiL1wiO1xufVxuZnVuY3Rpb24gYXBwbHlTZXR0aW5nRGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdHMpIHtcblx0dmFyIF9ERUZBVUxUX0dMT0JBTF9PUFRJTywgX2dsb2JhbE9wdGlvbnMkaGVhZGVyO1xuXHRjb25zdCB7IGRiOiBkYk9wdGlvbnMsIGF1dGg6IGF1dGhPcHRpb25zLCByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLCBnbG9iYWw6IGdsb2JhbE9wdGlvbnMgfSA9IG9wdGlvbnM7XG5cdGNvbnN0IHsgZGI6IERFRkFVTFRfREJfT1BUSU9OUyQxLCBhdXRoOiBERUZBVUxUX0FVVEhfT1BUSU9OUyQxLCByZWFsdGltZTogREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEsIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyQxIH0gPSBkZWZhdWx0cztcblx0Y29uc3QgcmVzdWx0ID0ge1xuXHRcdGRiOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9EQl9PUFRJT05TJDEpLCBkYk9wdGlvbnMpLFxuXHRcdGF1dGg6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyQxKSwgYXV0aE9wdGlvbnMpLFxuXHRcdHJlYWx0aW1lOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEpLCByZWFsdGltZU9wdGlvbnMpLFxuXHRcdHN0b3JhZ2U6IHt9LFxuXHRcdGdsb2JhbDogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSksIGdsb2JhbE9wdGlvbnMpLCB7fSwgeyBoZWFkZXJzOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgKF9ERUZBVUxUX0dMT0JBTF9PUFRJTyA9IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMSA9PT0gbnVsbCB8fCBERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IERFRkFVTFRfR0xPQkFMX09QVElPTlMkMS5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfREVGQVVMVF9HTE9CQUxfT1BUSU8gIT09IHZvaWQgMCA/IF9ERUZBVUxUX0dMT0JBTF9PUFRJTyA6IHt9KSwgKF9nbG9iYWxPcHRpb25zJGhlYWRlciA9IGdsb2JhbE9wdGlvbnMgPT09IG51bGwgfHwgZ2xvYmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfZ2xvYmFsT3B0aW9ucyRoZWFkZXIgIT09IHZvaWQgMCA/IF9nbG9iYWxPcHRpb25zJGhlYWRlciA6IHt9KSB9KSxcblx0XHRhY2Nlc3NUb2tlbjogYXN5bmMgKCkgPT4gXCJcIlxuXHR9O1xuXHRpZiAob3B0aW9ucy5hY2Nlc3NUb2tlbikgcmVzdWx0LmFjY2Vzc1Rva2VuID0gb3B0aW9ucy5hY2Nlc3NUb2tlbjtcblx0ZWxzZSBkZWxldGUgcmVzdWx0LmFjY2Vzc1Rva2VuO1xuXHRyZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4qIFZhbGlkYXRlcyBhIFN1cGFiYXNlIGNsaWVudCBVUkxcbipcbiogQHBhcmFtIHtzdHJpbmd9IHN1cGFiYXNlVXJsIC0gVGhlIFN1cGFiYXNlIGNsaWVudCBVUkwgc3RyaW5nLlxuKiBAcmV0dXJucyB7VVJMfSAtIFRoZSB2YWxpZGF0ZWQgYmFzZSBVUkwuXG4qIEB0aHJvd3Mge0Vycm9yfVxuKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU3VwYWJhc2VVcmwoc3VwYWJhc2VVcmwpIHtcblx0Y29uc3QgdHJpbW1lZFVybCA9IHN1cGFiYXNlVXJsID09PSBudWxsIHx8IHN1cGFiYXNlVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdXBhYmFzZVVybC50cmltKCk7XG5cdGlmICghdHJpbW1lZFVybCkgdGhyb3cgbmV3IEVycm9yKFwic3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuXCIpO1xuXHRpZiAoIXRyaW1tZWRVcmwubWF0Y2goL15odHRwcz86XFwvXFwvL2kpKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN1cGFiYXNlVXJsOiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwuXCIpO1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgVVJMKGVuc3VyZVRyYWlsaW5nU2xhc2godHJpbW1lZFVybCkpO1xuXHR9IGNhdGNoIChfdW51c2VkKSB7XG5cdFx0dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHN1cGFiYXNlVXJsOiBQcm92aWRlZCBVUkwgaXMgbWFsZm9ybWVkLlwiKTtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvbGliL1N1cGFiYXNlQXV0aENsaWVudC50c1xudmFyIFN1cGFiYXNlQXV0aENsaWVudCA9IGNsYXNzIGV4dGVuZHMgQXV0aENsaWVudCB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRzdXBlcihvcHRpb25zKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL1N1cGFiYXNlQ2xpZW50LnRzXG4vKipcbiogU3VwYWJhc2UgQ2xpZW50LlxuKlxuKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuKi9cbnZhciBTdXBhYmFzZUNsaWVudCA9IGNsYXNzIHtcblx0LyoqXG5cdCogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuXHQqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuXHQqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuXHQqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuXHQqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cblx0KiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cblx0KiBAcGFyYW0gb3B0aW9ucy5zdG9yYWdlIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHRoZSBzdG9yYWdlLWpzIGNvbnN0cnVjdG9yLlxuXHQqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5mZXRjaCBBIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cblx0KiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuaGVhZGVycyBBbnkgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBlYWNoIG5ldHdvcmsgcmVxdWVzdC5cblx0KiBAZXhhbXBsZVxuXHQqIGBgYHRzXG5cdCogaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuXHQqXG5cdCogY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoJ2h0dHBzOi8veHl6Y29tcGFueS5zdXBhYmFzZS5jbycsICdwdWJsaWMtYW5vbi1rZXknKVxuXHQqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2UuZnJvbSgncHJvZmlsZXMnKS5zZWxlY3QoJyonKVxuXHQqIGBgYFxuXHQqL1xuXHRjb25zdHJ1Y3RvcihzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcblx0XHR2YXIgX3NldHRpbmdzJGF1dGgkc3RvcmFnLCBfc2V0dGluZ3MkZ2xvYmFsJGhlYWQ7XG5cdFx0dGhpcy5zdXBhYmFzZVVybCA9IHN1cGFiYXNlVXJsO1xuXHRcdHRoaXMuc3VwYWJhc2VLZXkgPSBzdXBhYmFzZUtleTtcblx0XHRjb25zdCBiYXNlVXJsID0gdmFsaWRhdGVTdXBhYmFzZVVybChzdXBhYmFzZVVybCk7XG5cdFx0aWYgKCFzdXBhYmFzZUtleSkgdGhyb3cgbmV3IEVycm9yKFwic3VwYWJhc2VLZXkgaXMgcmVxdWlyZWQuXCIpO1xuXHRcdHRoaXMucmVhbHRpbWVVcmwgPSBuZXcgVVJMKFwicmVhbHRpbWUvdjFcIiwgYmFzZVVybCk7XG5cdFx0dGhpcy5yZWFsdGltZVVybC5wcm90b2NvbCA9IHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wucmVwbGFjZShcImh0dHBcIiwgXCJ3c1wiKTtcblx0XHR0aGlzLmF1dGhVcmwgPSBuZXcgVVJMKFwiYXV0aC92MVwiLCBiYXNlVXJsKTtcblx0XHR0aGlzLnN0b3JhZ2VVcmwgPSBuZXcgVVJMKFwic3RvcmFnZS92MVwiLCBiYXNlVXJsKTtcblx0XHR0aGlzLmZ1bmN0aW9uc1VybCA9IG5ldyBVUkwoXCJmdW5jdGlvbnMvdjFcIiwgYmFzZVVybCk7XG5cdFx0Y29uc3QgZGVmYXVsdFN0b3JhZ2VLZXkgPSBgc2ItJHtiYXNlVXJsLmhvc3RuYW1lLnNwbGl0KFwiLlwiKVswXX0tYXV0aC10b2tlbmA7XG5cdFx0Y29uc3QgREVGQVVMVFMgPSB7XG5cdFx0XHRkYjogREVGQVVMVF9EQl9PUFRJT05TLFxuXHRcdFx0cmVhbHRpbWU6IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyxcblx0XHRcdGF1dGg6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyksIHt9LCB7IHN0b3JhZ2VLZXk6IGRlZmF1bHRTdG9yYWdlS2V5IH0pLFxuXHRcdFx0Z2xvYmFsOiBERUZBVUxUX0dMT0JBTF9PUFRJT05TXG5cdFx0fTtcblx0XHRjb25zdCBzZXR0aW5ncyA9IGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9LCBERUZBVUxUUyk7XG5cdFx0dGhpcy5zdG9yYWdlS2V5ID0gKF9zZXR0aW5ncyRhdXRoJHN0b3JhZyA9IHNldHRpbmdzLmF1dGguc3RvcmFnZUtleSkgIT09IG51bGwgJiYgX3NldHRpbmdzJGF1dGgkc3RvcmFnICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkYXV0aCRzdG9yYWcgOiBcIlwiO1xuXHRcdHRoaXMuaGVhZGVycyA9IChfc2V0dGluZ3MkZ2xvYmFsJGhlYWQgPSBzZXR0aW5ncy5nbG9iYWwuaGVhZGVycykgIT09IG51bGwgJiYgX3NldHRpbmdzJGdsb2JhbCRoZWFkICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkZ2xvYmFsJGhlYWQgOiB7fTtcblx0XHRpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB7XG5cdFx0XHR2YXIgX3NldHRpbmdzJGF1dGg7XG5cdFx0XHR0aGlzLmF1dGggPSB0aGlzLl9pbml0U3VwYWJhc2VBdXRoQ2xpZW50KChfc2V0dGluZ3MkYXV0aCA9IHNldHRpbmdzLmF1dGgpICE9PSBudWxsICYmIF9zZXR0aW5ncyRhdXRoICE9PSB2b2lkIDAgPyBfc2V0dGluZ3MkYXV0aCA6IHt9LCB0aGlzLmhlYWRlcnMsIHNldHRpbmdzLmdsb2JhbC5mZXRjaCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlbjtcblx0XHRcdHRoaXMuYXV0aCA9IG5ldyBQcm94eSh7fSwgeyBnZXQ6IChfLCBwcm9wKSA9PiB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL3N1cGFiYXNlLWpzOiBTdXBhYmFzZSBDbGllbnQgaXMgY29uZmlndXJlZCB3aXRoIHRoZSBhY2Nlc3NUb2tlbiBvcHRpb24sIGFjY2Vzc2luZyBzdXBhYmFzZS5hdXRoLiR7U3RyaW5nKHByb3ApfSBpcyBub3QgcG9zc2libGVgKTtcblx0XHRcdH0gfSk7XG5cdFx0fVxuXHRcdHRoaXMuZmV0Y2ggPSBmZXRjaFdpdGhBdXRoKHN1cGFiYXNlS2V5LCB0aGlzLl9nZXRBY2Nlc3NUb2tlbi5iaW5kKHRoaXMpLCBzZXR0aW5ncy5nbG9iYWwuZmV0Y2gpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSB0aGlzLl9pbml0UmVhbHRpbWVDbGllbnQoX29iamVjdFNwcmVhZDIoe1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0YWNjZXNzVG9rZW46IHRoaXMuX2dldEFjY2Vzc1Rva2VuLmJpbmQodGhpcylcblx0XHR9LCBzZXR0aW5ncy5yZWFsdGltZSkpO1xuXHRcdGlmICh0aGlzLmFjY2Vzc1Rva2VuKSB0aGlzLmFjY2Vzc1Rva2VuKCkudGhlbigodG9rZW4pID0+IHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbikpLmNhdGNoKChlKSA9PiBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2V0IGluaXRpYWwgUmVhbHRpbWUgYXV0aCB0b2tlbjpcIiwgZSkpO1xuXHRcdHRoaXMucmVzdCA9IG5ldyBQb3N0Z3Jlc3RDbGllbnQobmV3IFVSTChcInJlc3QvdjFcIiwgYmFzZVVybCkuaHJlZiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0c2NoZW1hOiBzZXR0aW5ncy5kYi5zY2hlbWEsXG5cdFx0XHRmZXRjaDogdGhpcy5mZXRjaFxuXHRcdH0pO1xuXHRcdHRoaXMuc3RvcmFnZSA9IG5ldyBTdG9yYWdlQ2xpZW50KHRoaXMuc3RvcmFnZVVybC5ocmVmLCB0aGlzLmhlYWRlcnMsIHRoaXMuZmV0Y2gsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yYWdlKTtcblx0XHRpZiAoIXNldHRpbmdzLmFjY2Vzc1Rva2VuKSB0aGlzLl9saXN0ZW5Gb3JBdXRoRXZlbnRzKCk7XG5cdH1cblx0LyoqXG5cdCogU3VwYWJhc2UgRnVuY3Rpb25zIGFsbG93cyB5b3UgdG8gZGVwbG95IGFuZCBpbnZva2UgZWRnZSBmdW5jdGlvbnMuXG5cdCovXG5cdGdldCBmdW5jdGlvbnMoKSB7XG5cdFx0cmV0dXJuIG5ldyBGdW5jdGlvbnNDbGllbnQodGhpcy5mdW5jdGlvbnNVcmwuaHJlZiwge1xuXHRcdFx0aGVhZGVyczogdGhpcy5oZWFkZXJzLFxuXHRcdFx0Y3VzdG9tRmV0Y2g6IHRoaXMuZmV0Y2hcblx0XHR9KTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgcXVlcnkgb24gYSB0YWJsZSBvciBhIHZpZXcuXG5cdCpcblx0KiBAcGFyYW0gcmVsYXRpb24gLSBUaGUgdGFibGUgb3IgdmlldyBuYW1lIHRvIHF1ZXJ5XG5cdCovXG5cdGZyb20ocmVsYXRpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5yZXN0LmZyb20ocmVsYXRpb24pO1xuXHR9XG5cdC8qKlxuXHQqIFNlbGVjdCBhIHNjaGVtYSB0byBxdWVyeSBvciBwZXJmb3JtIGFuIGZ1bmN0aW9uIChycGMpIGNhbGwuXG5cdCpcblx0KiBUaGUgc2NoZW1hIG5lZWRzIHRvIGJlIG9uIHRoZSBsaXN0IG9mIGV4cG9zZWQgc2NoZW1hcyBpbnNpZGUgU3VwYWJhc2UuXG5cdCpcblx0KiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB0byBxdWVyeVxuXHQqL1xuXHRzY2hlbWEoc2NoZW1hKSB7XG5cdFx0cmV0dXJuIHRoaXMucmVzdC5zY2hlbWEoc2NoZW1hKTtcblx0fVxuXHQvKipcblx0KiBQZXJmb3JtIGEgZnVuY3Rpb24gY2FsbC5cblx0KlxuXHQqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiBuYW1lIHRvIGNhbGxcblx0KiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24gY2FsbFxuXHQqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuXHQqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cblx0KiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG5cdCogQHBhcmFtIG9wdGlvbnMuZ2V0IC0gV2hlbiBzZXQgdG8gYHRydWVgLCB0aGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aFxuXHQqIHJlYWQtb25seSBhY2Nlc3MgbW9kZS5cblx0KiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyByZXR1cm5lZCBieSB0aGVcblx0KiBmdW5jdGlvbi4gT25seSBhcHBsaWNhYmxlIGZvciBbc2V0LXJldHVybmluZ1xuXHQqIGZ1bmN0aW9uc10oaHR0cHM6Ly93d3cucG9zdGdyZXNxbC5vcmcvZG9jcy9jdXJyZW50L2Z1bmN0aW9ucy1zcmYuaHRtbCkuXG5cdCpcblx0KiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG5cdCogaG9vZC5cblx0KlxuXHQqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG5cdCogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cblx0KlxuXHQqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcblx0KiBudW1iZXJzLlxuXHQqL1xuXHRycGMoZm4sIGFyZ3MgPSB7fSwgb3B0aW9ucyA9IHtcblx0XHRoZWFkOiBmYWxzZSxcblx0XHRnZXQ6IGZhbHNlLFxuXHRcdGNvdW50OiB2b2lkIDBcblx0fSkge1xuXHRcdHJldHVybiB0aGlzLnJlc3QucnBjKGZuLCBhcmdzLCBvcHRpb25zKTtcblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgUmVhbHRpbWUgY2hhbm5lbCB3aXRoIEJyb2FkY2FzdCwgUHJlc2VuY2UsIGFuZCBQb3N0Z3JlcyBDaGFuZ2VzLlxuXHQqXG5cdCogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cblx0KiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG5cdCpcblx0Ki9cblx0Y2hhbm5lbChuYW1lLCBvcHRzID0geyBjb25maWc6IHt9IH0pIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsdGltZS5jaGFubmVsKG5hbWUsIG9wdHMpO1xuXHR9XG5cdC8qKlxuXHQqIFJldHVybnMgYWxsIFJlYWx0aW1lIGNoYW5uZWxzLlxuXHQqL1xuXHRnZXRDaGFubmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsdGltZS5nZXRDaGFubmVscygpO1xuXHR9XG5cdC8qKlxuXHQqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBSZWFsdGltZSBjaGFubmVsIGZyb20gUmVhbHRpbWUgY2xpZW50LlxuXHQqXG5cdCogQHBhcmFtIHtSZWFsdGltZUNoYW5uZWx9IGNoYW5uZWwgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cblx0KlxuXHQqL1xuXHRyZW1vdmVDaGFubmVsKGNoYW5uZWwpIHtcblx0XHRyZXR1cm4gdGhpcy5yZWFsdGltZS5yZW1vdmVDaGFubmVsKGNoYW5uZWwpO1xuXHR9XG5cdC8qKlxuXHQqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMgZnJvbSBSZWFsdGltZSBjbGllbnQuXG5cdCovXG5cdHJlbW92ZUFsbENoYW5uZWxzKCkge1xuXHRcdHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUFsbENoYW5uZWxzKCk7XG5cdH1cblx0YXN5bmMgX2dldEFjY2Vzc1Rva2VuKCkge1xuXHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFx0dmFyIF9kYXRhJHNlc3Npb24kYWNjZXNzXywgX2RhdGEkc2Vzc2lvbjtcblx0XHRpZiAoX3RoaXMuYWNjZXNzVG9rZW4pIHJldHVybiBhd2FpdCBfdGhpcy5hY2Nlc3NUb2tlbigpO1xuXHRcdGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgX3RoaXMuYXV0aC5nZXRTZXNzaW9uKCk7XG5cdFx0cmV0dXJuIChfZGF0YSRzZXNzaW9uJGFjY2Vzc18gPSAoX2RhdGEkc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2RhdGEkc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RhdGEkc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9kYXRhJHNlc3Npb24kYWNjZXNzXyAhPT0gdm9pZCAwID8gX2RhdGEkc2Vzc2lvbiRhY2Nlc3NfIDogX3RoaXMuc3VwYWJhc2VLZXk7XG5cdH1cblx0X2luaXRTdXBhYmFzZUF1dGhDbGllbnQoeyBhdXRvUmVmcmVzaFRva2VuLCBwZXJzaXN0U2Vzc2lvbiwgZGV0ZWN0U2Vzc2lvbkluVXJsLCBzdG9yYWdlLCB1c2VyU3RvcmFnZSwgc3RvcmFnZUtleSwgZmxvd1R5cGUsIGxvY2ssIGRlYnVnLCB0aHJvd09uRXJyb3IgfSwgaGVhZGVycywgZmV0Y2gkMSkge1xuXHRcdGNvbnN0IGF1dGhIZWFkZXJzID0ge1xuXHRcdFx0QXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuc3VwYWJhc2VLZXl9YCxcblx0XHRcdGFwaWtleTogYCR7dGhpcy5zdXBhYmFzZUtleX1gXG5cdFx0fTtcblx0XHRyZXR1cm4gbmV3IFN1cGFiYXNlQXV0aENsaWVudCh7XG5cdFx0XHR1cmw6IHRoaXMuYXV0aFVybC5ocmVmLFxuXHRcdFx0aGVhZGVyczogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGF1dGhIZWFkZXJzKSwgaGVhZGVycyksXG5cdFx0XHRzdG9yYWdlS2V5LFxuXHRcdFx0YXV0b1JlZnJlc2hUb2tlbixcblx0XHRcdHBlcnNpc3RTZXNzaW9uLFxuXHRcdFx0ZGV0ZWN0U2Vzc2lvbkluVXJsLFxuXHRcdFx0c3RvcmFnZSxcblx0XHRcdHVzZXJTdG9yYWdlLFxuXHRcdFx0Zmxvd1R5cGUsXG5cdFx0XHRsb2NrLFxuXHRcdFx0ZGVidWcsXG5cdFx0XHR0aHJvd09uRXJyb3IsXG5cdFx0XHRmZXRjaDogZmV0Y2gkMSxcblx0XHRcdGhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXI6IE9iamVjdC5rZXlzKHRoaXMuaGVhZGVycykuc29tZSgoa2V5KSA9PiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJhdXRob3JpemF0aW9uXCIpXG5cdFx0fSk7XG5cdH1cblx0X2luaXRSZWFsdGltZUNsaWVudChvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWFsdGltZUNsaWVudCh0aGlzLnJlYWx0aW1lVXJsLmhyZWYsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRpb25zKSwge30sIHsgcGFyYW1zOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgeyBhcGlrZXk6IHRoaXMuc3VwYWJhc2VLZXkgfSksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpIH0pKTtcblx0fVxuXHRfbGlzdGVuRm9yQXV0aEV2ZW50cygpIHtcblx0XHRyZXR1cm4gdGhpcy5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKChldmVudCwgc2Vzc2lvbikgPT4ge1xuXHRcdFx0dGhpcy5faGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBcIkNMSUVOVFwiLCBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcblx0XHR9KTtcblx0fVxuXHRfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBzb3VyY2UsIHRva2VuKSB7XG5cdFx0aWYgKChldmVudCA9PT0gXCJUT0tFTl9SRUZSRVNIRURcIiB8fCBldmVudCA9PT0gXCJTSUdORURfSU5cIikgJiYgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gIT09IHRva2VuKSB7XG5cdFx0XHR0aGlzLmNoYW5nZWRBY2Nlc3NUb2tlbiA9IHRva2VuO1xuXHRcdFx0dGhpcy5yZWFsdGltZS5zZXRBdXRoKHRva2VuKTtcblx0XHR9IGVsc2UgaWYgKGV2ZW50ID09PSBcIlNJR05FRF9PVVRcIikge1xuXHRcdFx0dGhpcy5yZWFsdGltZS5zZXRBdXRoKCk7XG5cdFx0XHRpZiAoc291cmNlID09IFwiU1RPUkFHRVwiKSB0aGlzLmF1dGguc2lnbk91dCgpO1xuXHRcdFx0dGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB2b2lkIDA7XG5cdFx0fVxuXHR9XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvaW5kZXgudHNcbi8qKlxuKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbipcbiogQGV4YW1wbGVcbiogYGBgdHNcbiogaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuKlxuKiBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudCgnaHR0cHM6Ly94eXpjb21wYW55LnN1cGFiYXNlLmNvJywgJ3B1YmxpYy1hbm9uLWtleScpXG4qIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3Byb2ZpbGVzJykuc2VsZWN0KCcqJylcbiogYGBgXG4qL1xuY29uc3QgY3JlYXRlQ2xpZW50ID0gKHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucykgPT4ge1xuXHRyZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuZnVuY3Rpb24gc2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZygpIHtcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgX3Byb2Nlc3MgPSBnbG9iYWxUaGlzW1wicHJvY2Vzc1wiXTtcblx0aWYgKCFfcHJvY2VzcykgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBwcm9jZXNzVmVyc2lvbiA9IF9wcm9jZXNzW1widmVyc2lvblwiXTtcblx0aWYgKHByb2Nlc3NWZXJzaW9uID09PSB2b2lkIDAgfHwgcHJvY2Vzc1ZlcnNpb24gPT09IG51bGwpIHJldHVybiBmYWxzZTtcblx0Y29uc3QgdmVyc2lvbk1hdGNoID0gcHJvY2Vzc1ZlcnNpb24ubWF0Y2goL152KFxcZCspXFwuLyk7XG5cdGlmICghdmVyc2lvbk1hdGNoKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBwYXJzZUludCh2ZXJzaW9uTWF0Y2hbMV0sIDEwKSA8PSAxODtcbn1cbmlmIChzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nKCkpIGNvbnNvbGUud2FybihcIuKaoO+4jyAgTm9kZS5qcyAxOCBhbmQgYmVsb3cgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgQHN1cGFiYXNlL3N1cGFiYXNlLWpzLiBQbGVhc2UgdXBncmFkZSB0byBOb2RlLmpzIDIwIG9yIGxhdGVyLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9vcmdzL3N1cGFiYXNlL2Rpc2N1c3Npb25zLzM3MjE3XCIpO1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IEZ1bmN0aW9uUmVnaW9uLCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25zRmV0Y2hFcnJvciwgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBQb3N0Z3Jlc3RFcnJvciwgU3VwYWJhc2VDbGllbnQsIGNyZWF0ZUNsaWVudCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJGdW5jdGlvblJlZ2lvbiIsIkZ1bmN0aW9uc0NsaWVudCIsIkZ1bmN0aW9uc0Vycm9yIiwiRnVuY3Rpb25zRmV0Y2hFcnJvciIsIkZ1bmN0aW9uc0h0dHBFcnJvciIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJQb3N0Z3Jlc3RDbGllbnQiLCJQb3N0Z3Jlc3RFcnJvciIsIlJlYWx0aW1lQ2xpZW50IiwiU3RvcmFnZUNsaWVudCIsIkF1dGhDbGllbnQiLCJ2ZXJzaW9uIiwiSlNfRU5WIiwiRGVubyIsImRvY3VtZW50IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIkRFRkFVTFRfSEVBREVSUyIsIkRFRkFVTFRfR0xPQkFMX09QVElPTlMiLCJoZWFkZXJzIiwiREVGQVVMVF9EQl9PUFRJT05TIiwic2NoZW1hIiwiREVGQVVMVF9BVVRIX09QVElPTlMiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJmbG93VHlwZSIsIkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyIsIl90eXBlb2YiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvJDEiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsInRvUHJpbWl0aXZlIiwidCIsInIiLCJlIiwiaSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJ0b1Byb3BlcnR5S2V5IiwiX2RlZmluZVByb3BlcnR5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIm93bktleXMiLCJrZXlzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZmlsdGVyIiwiciQxIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsImFyZ3MiLCJmZXRjaCIsInJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IiLCJIZWFkZXJzIiwiZmV0Y2hXaXRoQXV0aCIsInN1cGFiYXNlS2V5IiwiZ2V0QWNjZXNzVG9rZW4iLCJmZXRjaCQxIiwiSGVhZGVyc0NvbnN0cnVjdG9yIiwiaW5wdXQiLCJpbml0IiwiX2F3YWl0JGdldEFjY2Vzc1Rva2VuIiwiYWNjZXNzVG9rZW4iLCJoYXMiLCJzZXQiLCJlbnN1cmVUcmFpbGluZ1NsYXNoIiwidXJsIiwiZW5kc1dpdGgiLCJhcHBseVNldHRpbmdEZWZhdWx0cyIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsIl9ERUZBVUxUX0dMT0JBTF9PUFRJTyIsIl9nbG9iYWxPcHRpb25zJGhlYWRlciIsImRiIiwiZGJPcHRpb25zIiwiYXV0aCIsImF1dGhPcHRpb25zIiwicmVhbHRpbWUiLCJyZWFsdGltZU9wdGlvbnMiLCJnbG9iYWwiLCJnbG9iYWxPcHRpb25zIiwiREVGQVVMVF9EQl9PUFRJT05TJDEiLCJERUZBVUxUX0FVVEhfT1BUSU9OUyQxIiwiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TJDEiLCJERUZBVUxUX0dMT0JBTF9PUFRJT05TJDEiLCJyZXN1bHQiLCJzdG9yYWdlIiwidmFsaWRhdGVTdXBhYmFzZVVybCIsInN1cGFiYXNlVXJsIiwidHJpbW1lZFVybCIsInRyaW0iLCJFcnJvciIsIm1hdGNoIiwiVVJMIiwiX3VudXNlZCIsIlN1cGFiYXNlQXV0aENsaWVudCIsIlN1cGFiYXNlQ2xpZW50IiwiX3NldHRpbmdzJGF1dGgkc3RvcmFnIiwiX3NldHRpbmdzJGdsb2JhbCRoZWFkIiwiYmFzZVVybCIsInJlYWx0aW1lVXJsIiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiYXV0aFVybCIsInN0b3JhZ2VVcmwiLCJmdW5jdGlvbnNVcmwiLCJkZWZhdWx0U3RvcmFnZUtleSIsImhvc3RuYW1lIiwic3BsaXQiLCJERUZBVUxUUyIsInN0b3JhZ2VLZXkiLCJzZXR0aW5ncyIsIl9zZXR0aW5ncyRhdXRoIiwiX2luaXRTdXBhYmFzZUF1dGhDbGllbnQiLCJQcm94eSIsImdldCIsIl8iLCJwcm9wIiwiX2dldEFjY2Vzc1Rva2VuIiwiYmluZCIsIl9pbml0UmVhbHRpbWVDbGllbnQiLCJ0aGVuIiwidG9rZW4iLCJzZXRBdXRoIiwiY2F0Y2giLCJjb25zb2xlIiwid2FybiIsInJlc3QiLCJocmVmIiwiX2xpc3RlbkZvckF1dGhFdmVudHMiLCJmdW5jdGlvbnMiLCJmcm9tIiwicmVsYXRpb24iLCJycGMiLCJmbiIsImhlYWQiLCJjb3VudCIsImNoYW5uZWwiLCJuYW1lIiwib3B0cyIsImNvbmZpZyIsImdldENoYW5uZWxzIiwicmVtb3ZlQ2hhbm5lbCIsInJlbW92ZUFsbENoYW5uZWxzIiwiX3RoaXMiLCJfZGF0YSRzZXNzaW9uJGFjY2Vzc18iLCJfZGF0YSRzZXNzaW9uIiwiZGF0YSIsImdldFNlc3Npb24iLCJzZXNzaW9uIiwiYWNjZXNzX3Rva2VuIiwidXNlclN0b3JhZ2UiLCJsb2NrIiwiZGVidWciLCJ0aHJvd09uRXJyb3IiLCJhdXRoSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJhcGlrZXkiLCJoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyIiwic29tZSIsImtleSIsInRvTG93ZXJDYXNlIiwicGFyYW1zIiwib25BdXRoU3RhdGVDaGFuZ2UiLCJldmVudCIsIl9oYW5kbGVUb2tlbkNoYW5nZWQiLCJzb3VyY2UiLCJjaGFuZ2VkQWNjZXNzVG9rZW4iLCJzaWduT3V0IiwiY3JlYXRlQ2xpZW50Iiwic2hvdWxkU2hvd0RlcHJlY2F0aW9uV2FybmluZyIsIl9wcm9jZXNzIiwiZ2xvYmFsVGhpcyIsInByb2Nlc3NWZXJzaW9uIiwidmVyc2lvbk1hdGNoIiwicGFyc2VJbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/index.mjs\n");

/***/ })

};
;